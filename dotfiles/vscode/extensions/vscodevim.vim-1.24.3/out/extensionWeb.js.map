{"version":3,"file":"extensionWeb.js","mappings":"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,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,OAAQ,KACf,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAO,CAAC,IAAK,KACb,KAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,MAAO,CAAC,IAAK,KACb,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,GAAM,CAAC,IAAK,KACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,KAAO,CAAC,IAAK,MACb,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,KAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,MACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAO,CAAC,IAAK,OACb,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,KAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC,IAAK,OACZ,GAAM,CAAC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","sources":["webpack://vim/webpack/universalModuleDefinition","webpack://vim/./node_modules/diff-match-patch/index.js","webpack://vim/./node_modules/events/events.js","webpack://vim/./node_modules/inherits/inherits_browser.js","webpack://vim/./node_modules/lodash/lodash.js","webpack://vim/./node_modules/os-browserify/browser.js","webpack://vim/./node_modules/parsimmon/build/parsimmon.umd.min.js","webpack://vim/./node_modules/path-browserify/index.js","webpack://vim/./node_modules/process/browser.js","webpack://vim/./node_modules/queue/index.js","webpack://vim/./node_modules/setimmediate/setImmediate.js","webpack://vim/./extensionBase.ts","webpack://vim/./src/actions/base.ts","webpack://vim/./src/actions/baseMotion.ts","webpack://vim/./src/actions/commands/actions.ts","webpack://vim/./src/actions/commands/commandLine.ts","webpack://vim/./src/actions/commands/digraphs.ts","webpack://vim/./src/actions/commands/fold.ts","webpack://vim/./src/actions/commands/insert.ts","webpack://vim/./src/actions/commands/put.ts","webpack://vim/./src/actions/commands/replace.ts","webpack://vim/./src/actions/commands/scroll.ts","webpack://vim/./src/actions/commands/search.ts","webpack://vim/./src/actions/commands/window.ts","webpack://vim/./src/actions/include-main.ts","webpack://vim/./src/actions/languages/python/motion.ts","webpack://vim/./src/actions/motion.ts","webpack://vim/./src/actions/operator.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.cmd.ts","webpack://vim/./src/actions/plugins/easymotion/easymotion.ts","webpack://vim/./src/actions/plugins/easymotion/markerGenerator.ts","webpack://vim/./src/actions/plugins/easymotion/types.ts","webpack://vim/./src/actions/plugins/pluginDefaultMappings.ts","webpack://vim/./src/actions/plugins/sneak.ts","webpack://vim/./src/actions/plugins/targets/smartQuotesMatcher.ts","webpack://vim/./src/actions/plugins/targets/targetsConfig.ts","webpack://vim/./src/actions/wrapping.ts","webpack://vim/./src/cmd_line/commandLine.ts","webpack://vim/./src/cmd_line/commands/ascii.ts","webpack://vim/./src/cmd_line/commands/bang.ts","webpack://vim/./src/cmd_line/commands/breakpoints.ts","webpack://vim/./src/cmd_line/commands/bufferDelete.ts","webpack://vim/./src/cmd_line/commands/close.ts","webpack://vim/./src/cmd_line/commands/copy.ts","webpack://vim/./src/cmd_line/commands/delete.ts","webpack://vim/./src/cmd_line/commands/digraph.ts","webpack://vim/./src/cmd_line/commands/file.ts","webpack://vim/./src/cmd_line/commands/fileInfo.ts","webpack://vim/./src/cmd_line/commands/goto.ts","webpack://vim/./src/cmd_line/commands/gotoLine.ts","webpack://vim/./src/cmd_line/commands/history.ts","webpack://vim/./src/cmd_line/commands/jumps.ts","webpack://vim/./src/cmd_line/commands/leftRightCenter.ts","webpack://vim/./src/cmd_line/commands/marks.ts","webpack://vim/./src/cmd_line/commands/nohl.ts","webpack://vim/./src/cmd_line/commands/only.ts","webpack://vim/./src/cmd_line/commands/print.ts","webpack://vim/./src/cmd_line/commands/put.ts","webpack://vim/./src/cmd_line/commands/quit.ts","webpack://vim/./src/cmd_line/commands/read.ts","webpack://vim/./src/cmd_line/commands/register.ts","webpack://vim/./src/cmd_line/commands/retab.ts","webpack://vim/./src/cmd_line/commands/set.ts","webpack://vim/./src/cmd_line/commands/sh.ts","webpack://vim/./src/cmd_line/commands/shift.ts","webpack://vim/./src/cmd_line/commands/smile.ts","webpack://vim/./src/cmd_line/commands/sort.ts","webpack://vim/./src/cmd_line/commands/substitute.ts","webpack://vim/./src/cmd_line/commands/tab.ts","webpack://vim/./src/cmd_line/commands/terminal.ts","webpack://vim/./src/cmd_line/commands/undo.ts","webpack://vim/./src/cmd_line/commands/vscode.ts","webpack://vim/./src/cmd_line/commands/wall.ts","webpack://vim/./src/cmd_line/commands/write.ts","webpack://vim/./src/cmd_line/commands/writequit.ts","webpack://vim/./src/cmd_line/commands/writequitall.ts","webpack://vim/./src/cmd_line/commands/yank.ts","webpack://vim/./src/common/matching/matcher.ts","webpack://vim/./src/common/matching/quoteMatcher.ts","webpack://vim/./src/common/matching/tagMatcher.ts","webpack://vim/./src/common/motion/cursor.ts","webpack://vim/./src/common/motion/position.ts","webpack://vim/./src/common/number/numericString.ts","webpack://vim/./src/completion/lineCompletionProvider.ts","webpack://vim/./src/configuration/configuration.ts","webpack://vim/./src/configuration/configurationValidator.ts","webpack://vim/./src/configuration/decoration.ts","webpack://vim/./src/configuration/iconfigurationValidator.ts","webpack://vim/./src/configuration/notation.ts","webpack://vim/./src/configuration/remapper.ts","webpack://vim/./src/configuration/validators/inputMethodSwitcherValidator.ts","webpack://vim/./src/configuration/validators/remappingValidator.ts","webpack://vim/./src/error.ts","webpack://vim/./src/globals.ts","webpack://vim/./src/history/historyFile.ts","webpack://vim/./src/history/historyTracker.ts","webpack://vim/./src/jumps/jump.ts","webpack://vim/./src/jumps/jumpTracker.ts","webpack://vim/./src/mode/mode.ts","webpack://vim/./src/mode/modeHandler.ts","webpack://vim/./src/mode/modeHandlerMap.ts","webpack://vim/./src/platform/browser/constants.ts","webpack://vim/./src/platform/browser/fs.ts","webpack://vim/./src/platform/browser/history.ts","webpack://vim/./src/platform/browser/loggerImpl.ts","webpack://vim/./src/register/register.ts","webpack://vim/./src/state/compositionState.ts","webpack://vim/./src/state/globalState.ts","webpack://vim/./src/state/recordedState.ts","webpack://vim/./src/state/remapState.ts","webpack://vim/./src/state/replaceState.ts","webpack://vim/./src/state/searchState.ts","webpack://vim/./src/state/substituteState.ts","webpack://vim/./src/state/vimState.ts","webpack://vim/./src/statusBar.ts","webpack://vim/./src/taskQueue.ts","webpack://vim/./src/textEditor.ts","webpack://vim/./src/textobject/paragraph.ts","webpack://vim/./src/textobject/sentence.ts","webpack://vim/./src/textobject/textobject.ts","webpack://vim/./src/textobject/util.ts","webpack://vim/./src/textobject/word.ts","webpack://vim/./src/transformations/execute.ts","webpack://vim/./src/transformations/transformations.ts","webpack://vim/./src/transformations/transformer.ts","webpack://vim/./src/util/clipboard.ts","webpack://vim/./src/util/decorationUtils.ts","webpack://vim/./src/util/externalCommand.ts","webpack://vim/./src/util/logger.ts","webpack://vim/./src/util/path.ts","webpack://vim/./src/util/specialKeys.ts","webpack://vim/./src/util/statusBarTextUtils.ts","webpack://vim/./src/util/util.ts","webpack://vim/./src/util/vscodeContext.ts","webpack://vim/./src/vimscript/exCommand.ts","webpack://vim/./src/vimscript/exCommandParser.ts","webpack://vim/./src/vimscript/expression.ts","webpack://vim/./src/vimscript/lineRange.ts","webpack://vim/./src/vimscript/parserUtils.ts","webpack://vim/./src/vimscript/pattern.ts","webpack://vim/./node_modules/untildify/index.js","webpack://vim/external commonjs \"vscode\"","webpack://vim/webpack/bootstrap","webpack://vim/webpack/runtime/global","webpack://vim/webpack/runtime/node module decorator","webpack://vim/./extensionWeb.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n","/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.21';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function',\n      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading whitespace. */\n  var reTrimStart = /^\\s+/;\n\n  /** Used to match a single whitespace character. */\n  var reWhitespace = /\\s/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /**\n   * Used to validate the `validate` option in `_.template` variable.\n   *\n   * Forbids characters which could potentially change the meaning of the function argument definition:\n   * - \"(),\" (modification of function parameters)\n   * - \"=\" (default value)\n   * - \"[]{}\" (destructuring of function parameters)\n   * - \"/\" (beginning of a comment)\n   * - whitespace\n   */\n  var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.trim`.\n   *\n   * @private\n   * @param {string} string The string to trim.\n   * @returns {string} Returns the trimmed string.\n   */\n  function baseTrim(string) {\n    return string\n      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n      : string;\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n   * character of `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the index of the last non-whitespace character.\n   */\n  function trimmedEndIndex(string) {\n    var index = string.length;\n\n    while (index-- && reWhitespace.test(string.charAt(index))) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      if (iteratees.length) {\n        iteratees = arrayMap(iteratees, function(iteratee) {\n          if (isArray(iteratee)) {\n            return function(value) {\n              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);\n            }\n          }\n          return iteratee;\n        });\n      } else {\n        iteratees = [identity];\n      }\n\n      var index = -1;\n      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n          return object;\n        }\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      var low = 0,\n          high = array == null ? 0 : array.length;\n      if (high === 0) {\n        return 0;\n      }\n\n      value = iteratee(value);\n      var valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Check that cyclic values are equal.\n      var arrStacked = stack.get(array);\n      var othStacked = stack.get(other);\n      if (arrStacked && othStacked) {\n        return arrStacked == other && othStacked == array;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Check that cyclic values are equal.\n      var objStacked = stack.get(object);\n      var othStacked = stack.get(other);\n      if (objStacked && othStacked) {\n        return objStacked == other && othStacked == object;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     *\n     * // Combining several predicates using `_.overEvery` or `_.overSome`.\n     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n     * // => objects for ['fred', 'barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 30 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = baseTrim(value);\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in\n      // and escape the comment, thus injecting code that gets evaled.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/\\s/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Throw an error if a forbidden character was found in `variable`, to prevent\n      // potential command injection attacks.\n      else if (reForbiddenIdentifierChars.test(variable)) {\n        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);\n      }\n\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return baseTrim(string);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.slice(0, trimmedEndIndex(string) + 1);\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * **Note:** Multiple values can be checked by combining several matchers\n     * using `_.overSome`\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     *\n     * // Checking for several possible values\n     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));\n     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * Following shorthands are possible for providing predicates.\n     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.\n     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     *\n     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])\n     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    define(function() {\n      return _;\n    });\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else if (freeModule) {\n    // Export for Node.js.\n    (freeModule.exports = _)._ = _;\n    // Export for CommonJS support.\n    freeExports._ = _;\n  }\n  else {\n    // Export to the global object.\n    root._ = _;\n  }\n}.call(this));\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n","!function(n,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.Parsimmon=t():n.Parsimmon=t()}(\"undefined\"!=typeof self?self:this,function(){return function(n){var t={};function r(e){if(t[e])return t[e].exports;var u=t[e]={i:e,l:!1,exports:{}};return n[e].call(u.exports,u,u.exports,r),u.l=!0,u.exports}return r.m=n,r.c=t,r.d=function(n,t,e){r.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:e})},r.r=function(n){Object.defineProperty(n,\"__esModule\",{value:!0})},r.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(t,\"a\",t),t},r.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},r.p=\"\",r(r.s=0)}([function(n,t,r){\"use strict\";function e(n){if(!(this instanceof e))return new e(n);this._=n}var u=e.prototype;function o(n,t){for(var r=0;r<n;r++)t(r)}function i(n,t,r){return function(n,t){o(t.length,function(r){n(t[r],r,t)})}(function(r,e,u){t=n(t,r,e,u)},r),t}function f(n,t){return i(function(t,r,e,u){return t.concat([n(r,e,u)])},[],t)}function a(n,t){var r={v:0,buf:t};return o(n,function(){var n;r={v:r.v<<1|(n=r.buf,n[0]>>7),buf:function(n){var t=i(function(n,t,r,e){return n.concat(r===e.length-1?Buffer.from([t,0]).readUInt16BE(0):e.readUInt16BE(r))},[],n);return Buffer.from(f(function(n){return(n<<1&65535)>>8},t))}(r.buf)}}),r}function c(){return\"undefined\"!=typeof Buffer}function s(){if(!c())throw new Error(\"Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.\")}function l(n){s();var t=i(function(n,t){return n+t},0,n);if(t%8!=0)throw new Error(\"The bits [\"+n.join(\", \")+\"] add up to \"+t+\" which is not an even number of bytes; the total should be divisible by 8\");var r,u=t/8,o=(r=function(n){return n>48},i(function(n,t){return n||(r(t)?t:n)},null,n));if(o)throw new Error(o+\" bit range requested exceeds 48 bit (6 byte) Number max.\");return new e(function(t,r){var e=u+r;return e>t.length?x(r,u.toString()+\" bytes\"):b(e,i(function(n,t){var r=a(t,n.buf);return{coll:n.coll.concat(r.v),buf:r.buf}},{coll:[],buf:t.slice(r,e)},n).coll)})}function p(n,t){return new e(function(r,e){return s(),e+t>r.length?x(e,t+\" bytes for \"+n):b(e+t,r.slice(e,e+t))})}function h(n,t){if(\"number\"!=typeof(r=t)||Math.floor(r)!==r||t<0||t>6)throw new Error(n+\" requires integer length in range [0, 6].\");var r}function d(n){return h(\"uintBE\",n),p(\"uintBE(\"+n+\")\",n).map(function(t){return t.readUIntBE(0,n)})}function v(n){return h(\"uintLE\",n),p(\"uintLE(\"+n+\")\",n).map(function(t){return t.readUIntLE(0,n)})}function g(n){return h(\"intBE\",n),p(\"intBE(\"+n+\")\",n).map(function(t){return t.readIntBE(0,n)})}function m(n){return h(\"intLE\",n),p(\"intLE(\"+n+\")\",n).map(function(t){return t.readIntLE(0,n)})}function y(n){return n instanceof e}function E(n){return\"[object Array]\"==={}.toString.call(n)}function w(n){return c()&&Buffer.isBuffer(n)}function b(n,t){return{status:!0,index:n,value:t,furthest:-1,expected:[]}}function x(n,t){return E(t)||(t=[t]),{status:!1,index:-1,value:null,furthest:n,expected:t}}function B(n,t){if(!t)return n;if(n.furthest>t.furthest)return n;var r=n.furthest===t.furthest?function(n,t){if(function(){if(void 0!==e._supportsSet)return e._supportsSet;var n=\"undefined\"!=typeof Set;return e._supportsSet=n,n}()&&Array.from){for(var r=new Set(n),u=0;u<t.length;u++)r.add(t[u]);var o=Array.from(r);return o.sort(),o}for(var i={},f=0;f<n.length;f++)i[n[f]]=!0;for(var a=0;a<t.length;a++)i[t[a]]=!0;var c=[];for(var s in i)({}).hasOwnProperty.call(i,s)&&c.push(s);return c.sort(),c}(n.expected,t.expected):t.expected;return{status:n.status,index:n.index,value:n.value,furthest:t.furthest,expected:r}}var j={};function S(n,t){if(w(n))return{offset:t,line:-1,column:-1};n in j||(j[n]={});for(var r=j[n],e=0,u=0,o=0,i=t;i>=0;){if(i in r){e=r[i].line,0===o&&(o=r[i].lineStart);break}\"\\n\"===n.charAt(i)&&(u++,0===o&&(o=i+1)),i--}var f=e+u,a=t-o;return r[t]={line:f,lineStart:o},{offset:t,line:f+1,column:a+1}}function _(n){if(!y(n))throw new Error(\"not a parser: \"+n)}function L(n,t){return\"string\"==typeof n?n.charAt(t):n[t]}function O(n){if(\"number\"!=typeof n)throw new Error(\"not a number: \"+n)}function k(n){if(\"function\"!=typeof n)throw new Error(\"not a function: \"+n)}function P(n){if(\"string\"!=typeof n)throw new Error(\"not a string: \"+n)}var q=2,A=3,I=8,F=5*I,M=4*I,z=\"  \";function R(n,t){return new Array(t+1).join(n)}function U(n,t,r){var e=t-n.length;return e<=0?n:R(r,e)+n}function W(n,t,r,e){return{from:n-t>0?n-t:0,to:n+r>e?e:n+r}}function D(n,t){var r,e,u,o,a,c=t.index,s=c.offset,l=1;if(s===n.length)return\"Got the end of the input\";if(w(n)){var p=s-s%I,h=s-p,d=W(p,F,M+I,n.length),v=f(function(n){return f(function(n){return U(n.toString(16),2,\"0\")},n)},function(n,t){var r=n.length,e=[],u=0;if(r<=t)return[n.slice()];for(var o=0;o<r;o++)e[u]||e.push([]),e[u].push(n[o]),(o+1)%t==0&&u++;return e}(n.slice(d.from,d.to).toJSON().data,I));o=function(n){return 0===n.from&&1===n.to?{from:n.from,to:n.to}:{from:n.from/I,to:Math.floor(n.to/I)}}(d),e=p/I,r=3*h,h>=4&&(r+=1),l=2,u=f(function(n){return n.length<=4?n.join(\" \"):n.slice(0,4).join(\" \")+\"  \"+n.slice(4).join(\" \")},v),(a=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(a=2)}else{var g=n.split(/\\r\\n|[\\n\\r\\u2028\\u2029]/);r=c.column-1,e=c.line-1,o=W(e,q,A,g.length),u=g.slice(o.from,o.to),a=o.to.toString().length}var m=e-o.from;return w(n)&&(a=(8*(o.to>0?o.to-1:o.to)).toString(16).length)<2&&(a=2),i(function(t,e,u){var i,f=u===m,c=f?\"> \":z;return i=w(n)?U((8*(o.from+u)).toString(16),a,\"0\"):U((o.from+u+1).toString(),a,\" \"),[].concat(t,[c+i+\" | \"+e],f?[z+R(\" \",a)+\" | \"+U(\"\",r,\" \")+R(\"^\",l)]:[])},[],u).join(\"\\n\")}function N(n,t){return[\"\\n\",\"-- PARSING FAILED \"+R(\"-\",50),\"\\n\\n\",D(n,t),\"\\n\\n\",(r=t.expected,1===r.length?\"Expected:\\n\\n\"+r[0]:\"Expected one of the following: \\n\\n\"+r.join(\", \")),\"\\n\"].join(\"\");var r}function G(n){return void 0!==n.flags?n.flags:[n.global?\"g\":\"\",n.ignoreCase?\"i\":\"\",n.multiline?\"m\":\"\",n.unicode?\"u\":\"\",n.sticky?\"y\":\"\"].join(\"\")}function C(){for(var n=[].slice.call(arguments),t=n.length,r=0;r<t;r+=1)_(n[r]);return e(function(r,e){for(var u,o=new Array(t),i=0;i<t;i+=1){if(!(u=B(n[i]._(r,e),u)).status)return u;o[i]=u.value,e=u.index}return B(b(e,o),u)})}function J(){var n=[].slice.call(arguments);if(0===n.length)throw new Error(\"seqMap needs at least one argument\");var t=n.pop();return k(t),C.apply(null,n).map(function(n){return t.apply(null,n)})}function T(){var n=[].slice.call(arguments),t=n.length;if(0===t)return Y(\"zero alternates\");for(var r=0;r<t;r+=1)_(n[r]);return e(function(t,r){for(var e,u=0;u<n.length;u+=1)if((e=B(n[u]._(t,r),e)).status)return e;return e})}function V(n,t){return H(n,t).or(X([]))}function H(n,t){return _(n),_(t),J(n,t.then(n).many(),function(n,t){return[n].concat(t)})}function K(n){P(n);var t=\"'\"+n+\"'\";return e(function(r,e){var u=e+n.length,o=r.slice(e,u);return o===n?b(u,o):x(e,t)})}function Q(n,t){!function(n){if(!(n instanceof RegExp))throw new Error(\"not a regexp: \"+n);for(var t=G(n),r=0;r<t.length;r++){var e=t.charAt(r);if(\"i\"!==e&&\"m\"!==e&&\"u\"!==e&&\"s\"!==e)throw new Error('unsupported regexp flag \"'+e+'\": '+n)}}(n),arguments.length>=2?O(t):t=0;var r=function(n){return RegExp(\"^(?:\"+n.source+\")\",G(n))}(n),u=\"\"+n;return e(function(n,e){var o=r.exec(n.slice(e));if(o){if(0<=t&&t<=o.length){var i=o[0],f=o[t];return b(e+i.length,f)}return x(e,\"valid match group (0 to \"+o.length+\") in \"+u)}return x(e,u)})}function X(n){return e(function(t,r){return b(r,n)})}function Y(n){return e(function(t,r){return x(r,n)})}function Z(n){if(y(n))return e(function(t,r){var e=n._(t,r);return e.index=r,e.value=\"\",e});if(\"string\"==typeof n)return Z(K(n));if(n instanceof RegExp)return Z(Q(n));throw new Error(\"not a string, regexp, or parser: \"+n)}function $(n){return _(n),e(function(t,r){var e=n._(t,r),u=t.slice(r,e.index);return e.status?x(r,'not \"'+u+'\"'):b(r,null)})}function nn(n){return k(n),e(function(t,r){var e=L(t,r);return r<t.length&&n(e)?b(r+1,e):x(r,\"a character/byte matching \"+n)})}function tn(n,t){arguments.length<2&&(t=n,n=void 0);var r=e(function(n,e){return r._=t()._,r._(n,e)});return n?r.desc(n):r}function rn(){return Y(\"fantasy-land/empty\")}u.parse=function(n){if(\"string\"!=typeof n&&!w(n))throw new Error(\".parse must be called with a string or Buffer as its argument\");var t,r=this.skip(fn)._(n,0);return t=r.status?{status:!0,value:r.value}:{status:!1,index:S(n,r.furthest),expected:r.expected},delete j[n],t},u.tryParse=function(n){var t=this.parse(n);if(t.status)return t.value;var r=N(n,t),e=new Error(r);throw e.type=\"ParsimmonError\",e.result=t,e},u.assert=function(n,t){return this.chain(function(r){return n(r)?X(r):Y(t)})},u.or=function(n){return T(this,n)},u.trim=function(n){return this.wrap(n,n)},u.wrap=function(n,t){return J(n,this,t,function(n,t){return t})},u.thru=function(n){return n(this)},u.then=function(n){return _(n),C(this,n).map(function(n){return n[1]})},u.many=function(){var n=this;return e(function(t,r){for(var e=[],u=void 0;;){if(!(u=B(n._(t,r),u)).status)return B(b(r,e),u);if(r===u.index)throw new Error(\"infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause\");r=u.index,e.push(u.value)}})},u.tieWith=function(n){return P(n),this.map(function(t){if(function(n){if(!E(n))throw new Error(\"not an array: \"+n)}(t),t.length){P(t[0]);for(var r=t[0],e=1;e<t.length;e++)P(t[e]),r+=n+t[e];return r}return\"\"})},u.tie=function(){return this.tieWith(\"\")},u.times=function(n,t){var r=this;return arguments.length<2&&(t=n),O(n),O(t),e(function(e,u){for(var o=[],i=void 0,f=void 0,a=0;a<n;a+=1){if(f=B(i=r._(e,u),f),!i.status)return f;u=i.index,o.push(i.value)}for(;a<t&&(f=B(i=r._(e,u),f),i.status);a+=1)u=i.index,o.push(i.value);return B(b(u,o),f)})},u.result=function(n){return this.map(function(){return n})},u.atMost=function(n){return this.times(0,n)},u.atLeast=function(n){return J(this.times(n),this.many(),function(n,t){return n.concat(t)})},u.map=function(n){k(n);var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(b(u.index,n(u.value)),u):u})},u.contramap=function(n){k(n);var t=this;return e(function(r,e){var u=t.parse(n(r.slice(e)));return u.status?b(e+r.length,u.value):u})},u.promap=function(n,t){return k(n),k(t),this.contramap(n).map(t)},u.skip=function(n){return C(this,n).map(function(n){return n[0]})},u.mark=function(){return J(en,this,en,function(n,t,r){return{start:n,value:t,end:r}})},u.node=function(n){return J(en,this,en,function(t,r,e){return{name:n,value:r,start:t,end:e}})},u.sepBy=function(n){return V(this,n)},u.sepBy1=function(n){return H(this,n)},u.lookahead=function(n){return this.skip(Z(n))},u.notFollowedBy=function(n){return this.skip($(n))},u.desc=function(n){E(n)||(n=[n]);var t=this;return e(function(r,e){var u=t._(r,e);return u.status||(u.expected=n),u})},u.fallback=function(n){return this.or(X(n))},u.ap=function(n){return J(n,this,function(n,t){return n(t)})},u.chain=function(n){var t=this;return e(function(r,e){var u=t._(r,e);return u.status?B(n(u.value)._(r,u.index),u):u})},u.concat=u.or,u.empty=rn,u.of=X,u[\"fantasy-land/ap\"]=u.ap,u[\"fantasy-land/chain\"]=u.chain,u[\"fantasy-land/concat\"]=u.concat,u[\"fantasy-land/empty\"]=u.empty,u[\"fantasy-land/of\"]=u.of,u[\"fantasy-land/map\"]=u.map;var en=e(function(n,t){return b(t,S(n,t))}),un=e(function(n,t){return t>=n.length?x(t,\"any character/byte\"):b(t+1,L(n,t))}),on=e(function(n,t){return b(n.length,n.slice(t))}),fn=e(function(n,t){return t<n.length?x(t,\"EOF\"):b(t,null)}),an=Q(/[0-9]/).desc(\"a digit\"),cn=Q(/[0-9]*/).desc(\"optional digits\"),sn=Q(/[a-z]/i).desc(\"a letter\"),ln=Q(/[a-z]*/i).desc(\"optional letters\"),pn=Q(/\\s*/).desc(\"optional whitespace\"),hn=Q(/\\s+/).desc(\"whitespace\"),dn=K(\"\\r\"),vn=K(\"\\n\"),gn=K(\"\\r\\n\"),mn=T(gn,vn,dn).desc(\"newline\"),yn=T(mn,fn);e.all=on,e.alt=T,e.any=un,e.cr=dn,e.createLanguage=function(n){var t={};for(var r in n)({}).hasOwnProperty.call(n,r)&&function(r){t[r]=tn(function(){return n[r](t)})}(r);return t},e.crlf=gn,e.custom=function(n){return e(n(b,x))},e.digit=an,e.digits=cn,e.empty=rn,e.end=yn,e.eof=fn,e.fail=Y,e.formatError=N,e.index=en,e.isParser=y,e.lazy=tn,e.letter=sn,e.letters=ln,e.lf=vn,e.lookahead=Z,e.makeFailure=x,e.makeSuccess=b,e.newline=mn,e.noneOf=function(n){return nn(function(t){return n.indexOf(t)<0}).desc(\"none of '\"+n+\"'\")},e.notFollowedBy=$,e.of=X,e.oneOf=function(n){for(var t=n.split(\"\"),r=0;r<t.length;r++)t[r]=\"'\"+t[r]+\"'\";return nn(function(t){return n.indexOf(t)>=0}).desc(t)},e.optWhitespace=pn,e.Parser=e,e.range=function(n,t){return nn(function(r){return n<=r&&r<=t}).desc(n+\"-\"+t)},e.regex=Q,e.regexp=Q,e.sepBy=V,e.sepBy1=H,e.seq=C,e.seqMap=J,e.seqObj=function(){for(var n,t={},r=0,u=(n=arguments,Array.prototype.slice.call(n)),o=u.length,i=0;i<o;i+=1){var f=u[i];if(!y(f)){if(E(f)&&2===f.length&&\"string\"==typeof f[0]&&y(f[1])){var a=f[0];if(Object.prototype.hasOwnProperty.call(t,a))throw new Error(\"seqObj: duplicate key \"+a);t[a]=!0,r++;continue}throw new Error(\"seqObj arguments must be parsers or [string, parser] array pairs.\")}}if(0===r)throw new Error(\"seqObj expects at least one named parser, found zero\");return e(function(n,t){for(var r,e={},i=0;i<o;i+=1){var f,a;if(E(u[i])?(f=u[i][0],a=u[i][1]):(f=null,a=u[i]),!(r=B(a._(n,t),r)).status)return r;f&&(e[f]=r.value),t=r.index}return B(b(t,e),r)})},e.string=K,e.succeed=X,e.takeWhile=function(n){return k(n),e(function(t,r){for(var e=r;e<t.length&&n(L(t,e));)e++;return b(e,t.slice(r,e))})},e.test=nn,e.whitespace=hn,e[\"fantasy-land/empty\"]=rn,e[\"fantasy-land/of\"]=X,e.Binary={bitSeq:l,bitSeqObj:function(n){s();var t={},r=0,e=f(function(n){if(E(n)){var e=n;if(2!==e.length)throw new Error(\"[\"+e.join(\", \")+\"] should be length 2, got length \"+e.length);if(P(e[0]),O(e[1]),Object.prototype.hasOwnProperty.call(t,e[0]))throw new Error(\"duplicate key in bitSeqObj: \"+e[0]);return t[e[0]]=!0,r++,e}return O(n),[null,n]},n);if(r<1)throw new Error(\"bitSeqObj expects at least one named pair, got [\"+n.join(\", \")+\"]\");var u=f(function(n){return n[0]},e);return l(f(function(n){return n[1]},e)).map(function(n){return i(function(n,t){return null!==t[0]&&(n[t[0]]=t[1]),n},{},f(function(t,r){return[t,n[r]]},u))})},byte:function(n){if(s(),O(n),n>255)throw new Error(\"Value specified to byte constructor (\"+n+\"=0x\"+n.toString(16)+\") is larger in value than a single byte.\");var t=(n>15?\"0x\":\"0x0\")+n.toString(16);return e(function(r,e){var u=L(r,e);return u===n?b(e+1,u):x(e,t)})},buffer:function(n){return p(\"buffer\",n).map(function(n){return Buffer.from(n)})},encodedString:function(n,t){return p(\"string\",t).map(function(t){return t.toString(n)})},uintBE:d,uint8BE:d(1),uint16BE:d(2),uint32BE:d(4),uintLE:v,uint8LE:v(1),uint16LE:v(2),uint32LE:v(4),intBE:g,int8BE:g(1),int16BE:g(2),int32BE:g(4),intLE:m,int8LE:m(1),int16LE:m(2),int32LE:m(4),floatBE:p(\"floatBE\",4).map(function(n){return n.readFloatBE(0)}),floatLE:p(\"floatLE\",4).map(function(n){return n.readFloatLE(0)}),doubleBE:p(\"doubleBE\",8).map(function(n){return n.readDoubleBE(0)}),doubleLE:p(\"doubleLE\",8).map(function(n){return n.readDoubleLE(0)})},n.exports=e}])});","// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var inherits = require('inherits')\nvar EventEmitter = require('events').EventEmitter\n\nmodule.exports = Queue\nmodule.exports.default = Queue\n\nfunction Queue (options) {\n  if (!(this instanceof Queue)) {\n    return new Queue(options)\n  }\n\n  EventEmitter.call(this)\n  options = options || {}\n  this.concurrency = options.concurrency || Infinity\n  this.timeout = options.timeout || 0\n  this.autostart = options.autostart || false\n  this.results = options.results || null\n  this.pending = 0\n  this.session = 0\n  this.running = false\n  this.jobs = []\n  this.timers = {}\n}\ninherits(Queue, EventEmitter)\n\nvar arrayMethods = [\n  'pop',\n  'shift',\n  'indexOf',\n  'lastIndexOf'\n]\n\narrayMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    return Array.prototype[method].apply(this.jobs, arguments)\n  }\n})\n\nQueue.prototype.slice = function (begin, end) {\n  this.jobs = this.jobs.slice(begin, end)\n  return this\n}\n\nQueue.prototype.reverse = function () {\n  this.jobs.reverse()\n  return this\n}\n\nvar arrayAddMethods = [\n  'push',\n  'unshift',\n  'splice'\n]\n\narrayAddMethods.forEach(function (method) {\n  Queue.prototype[method] = function () {\n    var methodResult = Array.prototype[method].apply(this.jobs, arguments)\n    if (this.autostart) {\n      this.start()\n    }\n    return methodResult\n  }\n})\n\nObject.defineProperty(Queue.prototype, 'length', {\n  get: function () {\n    return this.pending + this.jobs.length\n  }\n})\n\nQueue.prototype.start = function (cb) {\n  if (cb) {\n    callOnErrorOrEnd.call(this, cb)\n  }\n\n  this.running = true\n\n  if (this.pending >= this.concurrency) {\n    return\n  }\n\n  if (this.jobs.length === 0) {\n    if (this.pending === 0) {\n      done.call(this)\n    }\n    return\n  }\n\n  var self = this\n  var job = this.jobs.shift()\n  var once = true\n  var session = this.session\n  var timeoutId = null\n  var didTimeout = false\n  var resultIndex = null\n  var timeout = job.hasOwnProperty('timeout') ? job.timeout : this.timeout\n\n  function next (err, result) {\n    if (once && self.session === session) {\n      once = false\n      self.pending--\n      if (timeoutId !== null) {\n        delete self.timers[timeoutId]\n        clearTimeout(timeoutId)\n      }\n\n      if (err) {\n        self.emit('error', err, job)\n      } else if (didTimeout === false) {\n        if (resultIndex !== null) {\n          self.results[resultIndex] = Array.prototype.slice.call(arguments, 1)\n        }\n        self.emit('success', result, job)\n      }\n\n      if (self.session === session) {\n        if (self.pending === 0 && self.jobs.length === 0) {\n          done.call(self)\n        } else if (self.running) {\n          self.start()\n        }\n      }\n    }\n  }\n\n  if (timeout) {\n    timeoutId = setTimeout(function () {\n      didTimeout = true\n      if (self.listeners('timeout').length > 0) {\n        self.emit('timeout', next, job)\n      } else {\n        next()\n      }\n    }, timeout)\n    this.timers[timeoutId] = timeoutId\n  }\n\n  if (this.results) {\n    resultIndex = this.results.length\n    this.results[resultIndex] = null\n  }\n\n  this.pending++\n  self.emit('start', job)\n  var promise = job(next)\n  if (promise && promise.then && typeof promise.then === 'function') {\n    promise.then(function (result) {\n      return next(null, result)\n    }).catch(function (err) {\n      return next(err || true)\n    })\n  }\n\n  if (this.running && this.jobs.length > 0) {\n    this.start()\n  }\n}\n\nQueue.prototype.stop = function () {\n  this.running = false\n}\n\nQueue.prototype.end = function (err) {\n  clearTimers.call(this)\n  this.jobs.length = 0\n  this.pending = 0\n  done.call(this, err)\n}\n\nfunction clearTimers () {\n  for (var key in this.timers) {\n    var timeoutId = this.timers[key]\n    delete this.timers[key]\n    clearTimeout(timeoutId)\n  }\n}\n\nfunction callOnErrorOrEnd (cb) {\n  var self = this\n  this.on('error', onerror)\n  this.on('end', onend)\n\n  function onerror (err) { self.end(err) }\n  function onend (err) {\n    self.removeListener('error', onerror)\n    self.removeListener('end', onend)\n    cb(err, this.results)\n  }\n}\n\nfunction done (err) {\n  this.session++\n  this.running = false\n  this.emit('end', err)\n}\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","import * as vscode from 'vscode';\n\nimport { CompositionState } from './src/state/compositionState';\nimport { Globals } from './src/globals';\nimport { Jump } from './src/jumps/jump';\nimport { ModeHandler } from './src/mode/modeHandler';\nimport { ModeHandlerMap } from './src/mode/modeHandlerMap';\nimport { Mode } from './src/mode/mode';\nimport { Notation } from './src/configuration/notation';\nimport { Logger } from './src/util/logger';\nimport { StatusBar } from './src/statusBar';\nimport { VSCodeContext } from './src/util/vscodeContext';\nimport { ExCommandLine, SearchCommandLine } from './src/cmd_line/commandLine';\nimport { configuration } from './src/configuration/configuration';\nimport { globalState } from './src/state/globalState';\nimport { taskQueue } from './src/taskQueue';\nimport { Register } from './src/register/register';\nimport { SpecialKeys } from './src/util/specialKeys';\nimport { HistoryTracker } from './src/history/historyTracker';\n\nlet extensionContext: vscode.ExtensionContext;\nlet previousActiveEditorUri: vscode.Uri | undefined;\nlet lastClosedModeHandler: ModeHandler | null = null;\n\ninterface ICodeKeybinding {\n  after?: string[];\n  commands?: Array<{ command: string; args: any[] }>;\n}\n\nexport async function getAndUpdateModeHandler(\n  forceSyncAndUpdate = false\n): Promise<ModeHandler | undefined> {\n  const activeTextEditor = vscode.window.activeTextEditor;\n  if (activeTextEditor === undefined || activeTextEditor.document.isClosed) {\n    return undefined;\n  }\n\n  const [curHandler, isNew] = await ModeHandlerMap.getOrCreate(activeTextEditor);\n  if (isNew) {\n    extensionContext.subscriptions.push(curHandler);\n  }\n\n  curHandler.vimState.editor = activeTextEditor;\n\n  if (\n    forceSyncAndUpdate ||\n    !previousActiveEditorUri ||\n    previousActiveEditorUri !== activeTextEditor.document.uri\n  ) {\n    // We sync the cursors here because ModeHandler is specific to a document, not an editor, so we\n    // need to update our representation of the cursors when switching between editors for the same document.\n    // This will be unnecessary once #4889 is fixed.\n    curHandler.syncCursors();\n    await curHandler.updateView({ drawSelection: false, revealRange: false });\n  }\n\n  previousActiveEditorUri = activeTextEditor.document.uri;\n\n  if (curHandler.focusChanged) {\n    curHandler.focusChanged = false;\n\n    if (previousActiveEditorUri) {\n      const prevHandler = ModeHandlerMap.get(previousActiveEditorUri);\n      prevHandler!.focusChanged = true;\n    }\n  }\n\n  return curHandler;\n}\n\n/**\n * Loads and validates the user's configuration\n */\nasync function loadConfiguration() {\n  const validatorResults = await configuration.load();\n\n  Logger.configChanged(configuration);\n\n  const logger = Logger.get('Configuration');\n  logger.debug(`${validatorResults.numErrors} errors found with vim configuration`);\n\n  if (validatorResults.numErrors > 0) {\n    for (const validatorResult of validatorResults.get()) {\n      switch (validatorResult.level) {\n        case 'error':\n          logger.error(validatorResult.message);\n          break;\n        case 'warning':\n          logger.warn(validatorResult.message);\n          break;\n      }\n    }\n  }\n}\n\n/**\n * The extension's entry point\n */\nexport async function activate(context: vscode.ExtensionContext, handleLocal: boolean = true) {\n  // before we do anything else, we need to load the configuration\n  await loadConfiguration();\n\n  const logger = Logger.get('Extension Startup');\n  logger.debug('Start');\n\n  extensionContext = context;\n  extensionContext.subscriptions.push(StatusBar);\n\n  // Load state\n  Register.loadFromDisk(handleLocal);\n  await Promise.all([ExCommandLine.loadHistory(context), SearchCommandLine.loadHistory(context)]);\n\n  if (vscode.window.activeTextEditor) {\n    const filepathComponents = vscode.window.activeTextEditor.document.fileName.split(/\\\\|\\//);\n    Register.setReadonlyRegister('%', filepathComponents[filepathComponents.length - 1]);\n  }\n\n  // workspace events\n  registerEventListener(\n    context,\n    vscode.workspace.onDidChangeConfiguration,\n    async () => {\n      await loadConfiguration();\n    },\n    false\n  );\n\n  registerEventListener(context, vscode.workspace.onDidChangeTextDocument, async (event) => {\n    const textWasDeleted = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      changeEvent.contentChanges[0].text === '' &&\n      changeEvent.contentChanges[0].range.start.line !==\n        changeEvent.contentChanges[0].range.end.line;\n\n    const textWasAdded = (changeEvent: vscode.TextDocumentChangeEvent) =>\n      changeEvent.contentChanges.length === 1 &&\n      (changeEvent.contentChanges[0].text === '\\n' ||\n        changeEvent.contentChanges[0].text === '\\r\\n') &&\n      changeEvent.contentChanges[0].range.start.line ===\n        changeEvent.contentChanges[0].range.end.line;\n\n    if (textWasDeleted(event)) {\n      globalState.jumpTracker.handleTextDeleted(event.document, event.contentChanges[0].range);\n    } else if (textWasAdded(event)) {\n      globalState.jumpTracker.handleTextAdded(\n        event.document,\n        event.contentChanges[0].range,\n        event.contentChanges[0].text\n      );\n    }\n\n    // Change from VSCode editor should set document.isDirty to true but they initially don't!\n    // There is a timing issue in VSCode codebase between when the isDirty flag is set and\n    // when registered callbacks are fired. https://github.com/Microsoft/vscode/issues/11339\n    const contentChangeHandler = (modeHandler: ModeHandler) => {\n      if (modeHandler.vimState.currentMode === Mode.Insert) {\n        if (modeHandler.vimState.historyTracker.currentContentChanges === undefined) {\n          modeHandler.vimState.historyTracker.currentContentChanges = [];\n        }\n\n        modeHandler.vimState.historyTracker.currentContentChanges =\n          modeHandler.vimState.historyTracker.currentContentChanges.concat(event.contentChanges);\n      }\n    };\n\n    ModeHandlerMap.getAll()\n      .filter((modeHandler) => modeHandler.vimState.documentUri === event.document.uri)\n      .forEach((modeHandler) => {\n        contentChangeHandler(modeHandler);\n      });\n\n    if (handleLocal) {\n      setTimeout(() => {\n        if (\n          !event.document.isDirty &&\n          !event.document.isUntitled &&\n          event.document.uri.scheme !== 'vscode-notebook-cell' && // TODO: Notebooks never seem to be marked dirty...\n          event.contentChanges.length\n        ) {\n          handleContentChangedFromDisk(event.document);\n        }\n      }, 0);\n    }\n  });\n\n  registerEventListener(\n    context,\n    vscode.workspace.onDidCloseTextDocument,\n    async (closedDocument) => {\n      const documents = vscode.workspace.textDocuments;\n\n      // Delete modehandler once all tabs of this document have been closed\n      for (const uri of ModeHandlerMap.keys()) {\n        const modeHandler = ModeHandlerMap.get(uri);\n\n        let shouldDelete = false;\n        if (modeHandler == null) {\n          shouldDelete = true;\n        } else {\n          const document = modeHandler.vimState.document;\n          if (!documents.includes(document)) {\n            shouldDelete = true;\n            if (closedDocument === document) {\n              lastClosedModeHandler = modeHandler;\n            }\n          }\n        }\n\n        if (shouldDelete) {\n          ModeHandlerMap.delete(uri);\n        }\n      }\n    },\n    false\n  );\n\n  // window events\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeActiveTextEditor,\n    async () => {\n      const mhPrevious: ModeHandler | undefined = previousActiveEditorUri\n        ? ModeHandlerMap.get(previousActiveEditorUri)\n        : undefined;\n      // Track the closed editor so we can use it the next time an open event occurs.\n      // When vscode changes away from a temporary file, onDidChangeActiveTextEditor first twice.\n      // First it fires when leaving the closed editor. Then onDidCloseTextDocument first, and we delete\n      // the old ModeHandler. Then a new editor opens.\n      //\n      // This also applies to files that are merely closed, which allows you to jump back to that file similarly\n      // once a new file is opened.\n      lastClosedModeHandler = mhPrevious || lastClosedModeHandler;\n\n      const activeTextEditor = vscode.window.activeTextEditor;\n      const oldFileRegister = (await Register.get('%'))?.text;\n      const relativePath = activeTextEditor\n        ? vscode.workspace.asRelativePath(activeTextEditor.document.uri, false)\n        : '';\n\n      if (relativePath !== oldFileRegister) {\n        if (oldFileRegister && oldFileRegister !== '') {\n          Register.setReadonlyRegister('#', oldFileRegister as string);\n        }\n        Register.setReadonlyRegister('%', relativePath);\n      }\n\n      if (activeTextEditor === undefined) {\n        return;\n      }\n      taskQueue.enqueueTask(async () => {\n        const mh = await getAndUpdateModeHandler(true);\n        if (mh) {\n          globalState.jumpTracker.handleFileJump(\n            lastClosedModeHandler ? Jump.fromStateNow(lastClosedModeHandler.vimState) : null,\n            Jump.fromStateNow(mh.vimState)\n          );\n        }\n      });\n    },\n    true,\n    true\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorSelection,\n    async (e: vscode.TextEditorSelectionChangeEvent) => {\n      if (\n        vscode.window.activeTextEditor === undefined ||\n        e.textEditor.document !== vscode.window.activeTextEditor.document\n      ) {\n        // We don't care if user selection changed in a paneled window (e.g debug console/terminal)\n        return;\n      }\n\n      const mh = ModeHandlerMap.get(vscode.window.activeTextEditor.document.uri);\n      if (mh === undefined) {\n        // We don't care if there is no active editor\n        return;\n      }\n\n      if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n        const selectionsHash = e.selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        const idx = mh.selectionsChanged.ourSelections.indexOf(selectionsHash);\n        if (idx > -1) {\n          mh.selectionsChanged.ourSelections.splice(idx, 1);\n          logger.debug(\n            `Selections: Ignoring selection: ${selectionsHash}, Count left: ${mh.selectionsChanged.ourSelections.length}`\n          );\n          return;\n        } else if (mh.selectionsChanged.ignoreIntermediateSelections) {\n          logger.debug(`Selections: ignoring intermediate selection change: ${selectionsHash}`);\n          return;\n        } else if (mh.selectionsChanged.ourSelections.length > 0) {\n          // Some intermediate selection must have slipped in after setting the\n          // 'ignoreIntermediateSelections' to false. Which means we didn't count\n          // for it yet, but since we have selections to be ignored then we probably\n          // wanted this one to be ignored as well.\n          logger.warn(`Selections: Ignoring slipped selection: ${selectionsHash}`);\n          return;\n        }\n      }\n\n      // We may receive changes from other panels when, having selections in them containing the same file\n      // and changing text before the selection in current panel.\n      if (e.textEditor !== mh.vimState.editor) {\n        return;\n      }\n\n      if (mh.focusChanged) {\n        mh.focusChanged = false;\n        return;\n      }\n\n      if (mh.currentMode === Mode.EasyMotionMode) {\n        return;\n      }\n\n      taskQueue.enqueueTask(() => mh.handleSelectionChange(e));\n    },\n    true,\n    false\n  );\n\n  registerEventListener(\n    context,\n    vscode.window.onDidChangeTextEditorVisibleRanges,\n    async (e: vscode.TextEditorVisibleRangesChangeEvent) => {\n      taskQueue.enqueueTask(async () => {\n        // Scrolling the viewport clears any status bar message, even errors.\n        const mh = await getAndUpdateModeHandler();\n        if (mh && StatusBar.lastMessageTime) {\n          // TODO: Using the time elapsed works most of the time, but is a bit of a hack\n          const timeElapsed = Date.now() - Number(StatusBar.lastMessageTime);\n          if (timeElapsed > 100) {\n            StatusBar.clear(mh.vimState, true);\n          }\n        }\n      });\n    }\n  );\n\n  const compositionState = new CompositionState();\n\n  // Override VSCode commands\n  overrideCommand(context, 'type', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText += args.text;\n          if (mh.vimState.currentMode === Mode.Insert) {\n            compositionState.insertedText = true;\n            vscode.commands.executeCommand('default:type', { text: args.text });\n          }\n        } else {\n          await mh.handleKeyEvent(args.text);\n        }\n      }\n    });\n  });\n\n  overrideCommand(context, 'replacePreviousChar', async (args) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.isInComposition) {\n          compositionState.composingText =\n            compositionState.composingText.substr(\n              0,\n              compositionState.composingText.length - args.replaceCharCnt\n            ) + args.text;\n        }\n        if (compositionState.insertedText) {\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: args.text,\n            replaceCharCnt: args.replaceCharCnt,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.start;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.start;\n        }\n      } else {\n        await vscode.commands.executeCommand('default:replacePreviousChar', {\n          text: args.text,\n          replaceCharCnt: args.replaceCharCnt,\n        });\n      }\n    });\n  });\n\n  overrideCommand(context, 'compositionStart', async () => {\n    taskQueue.enqueueTask(async () => {\n      compositionState.isInComposition = true;\n    });\n  });\n\n  overrideCommand(context, 'compositionEnd', async () => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh) {\n        if (compositionState.insertedText) {\n          mh.selectionsChanged.ignoreIntermediateSelections = true;\n          await vscode.commands.executeCommand('default:replacePreviousChar', {\n            text: '',\n            replaceCharCnt: compositionState.composingText.length,\n          });\n          mh.vimState.cursorStopPosition = mh.vimState.editor.selection.active;\n          mh.vimState.cursorStartPosition = mh.vimState.editor.selection.active;\n          mh.selectionsChanged.ignoreIntermediateSelections = false;\n        }\n        const text = compositionState.composingText;\n        await mh.handleMultipleKeyEvents(text.split(''));\n      }\n      compositionState.reset();\n    });\n  });\n\n  // Register extension commands\n  registerCommand(context, 'vim.showQuickpickCmdLine', async () => {\n    const mh = await getAndUpdateModeHandler();\n    if (mh) {\n      const cmd = await vscode.window.showInputBox({\n        prompt: 'Vim command line',\n        value: '',\n        ignoreFocusOut: false,\n        valueSelection: [0, 0],\n      });\n      if (cmd) {\n        await new ExCommandLine(cmd, mh.vimState.currentMode).run(mh.vimState);\n      }\n      mh.updateView();\n    }\n  });\n\n  registerCommand(context, 'vim.remap', async (args: ICodeKeybinding) => {\n    taskQueue.enqueueTask(async () => {\n      const mh = await getAndUpdateModeHandler();\n      if (mh === undefined) {\n        return;\n      }\n\n      if (!args) {\n        throw new Error(\n          \"'args' is undefined. For this remap to work it needs to have 'args' with an '\\\"after\\\": string[]' and/or a '\\\"commands\\\": { command: string; args: any[] }[]'\"\n        );\n      }\n\n      if (args.after) {\n        for (const key of args.after) {\n          await mh.handleKeyEvent(Notation.NormalizeKey(key, configuration.leader));\n        }\n      }\n\n      if (args.commands) {\n        for (const command of args.commands) {\n          // Check if this is a vim command by looking for :\n          if (command.command.startsWith(':')) {\n            await new ExCommandLine(\n              command.command.slice(1, command.command.length),\n              mh.vimState.currentMode\n            ).run(mh.vimState);\n            mh.updateView();\n          } else {\n            vscode.commands.executeCommand(command.command, command.args);\n          }\n        }\n      }\n    });\n  });\n\n  registerCommand(context, 'toggleVim', async () => {\n    configuration.disableExtension = !configuration.disableExtension;\n    toggleExtension(configuration.disableExtension, compositionState);\n  });\n\n  for (const boundKey of configuration.boundKeyCombinations) {\n    const command = ['<Esc>', '<C-c>'].includes(boundKey.key)\n      ? async () => {\n          const mh = await getAndUpdateModeHandler();\n          if (mh && !(await forceStopRecursiveRemap(mh))) {\n            await mh.handleKeyEvent(`${boundKey.key}`);\n          }\n        }\n      : async () => {\n          const mh = await getAndUpdateModeHandler();\n          if (mh) {\n            await mh.handleKeyEvent(`${boundKey.key}`);\n          }\n        };\n    registerCommand(context, boundKey.command, async () => {\n      taskQueue.enqueueTask(command);\n    });\n  }\n\n  {\n    // Initialize mode handler for current active Text Editor at startup.\n    const modeHandler = await getAndUpdateModeHandler();\n    if (modeHandler) {\n      if (!configuration.startInInsertMode) {\n        const vimState = modeHandler.vimState;\n\n        // Make sure no cursors start on the EOL character (which is invalid in normal mode)\n        // This can happen if we quit last session in insert mode at the end of the line\n        vimState.cursors = vimState.cursors.map((cursor) => {\n          const eolColumn = vimState.document.lineAt(cursor.stop).text.length;\n          if (cursor.stop.character >= eolColumn) {\n            const character = Math.max(eolColumn - 1, 0);\n            return cursor.withNewStop(cursor.stop.with({ character }));\n          } else {\n            return cursor;\n          }\n        });\n      }\n\n      // This is called last because getAndUpdateModeHandler() will change cursor\n      modeHandler.updateView({ drawSelection: true, revealRange: false });\n    }\n  }\n\n  // Disable automatic keyboard navigation in lists, so it doesn't interfere\n  // with our list navigation keybindings\n  await VSCodeContext.set('listAutomaticKeyboardNavigation', false);\n\n  await toggleExtension(configuration.disableExtension, compositionState);\n\n  logger.debug('Finish.');\n}\n\n/**\n * Toggles the VSCodeVim extension between Enabled mode and Disabled mode. This\n * function is activated by calling the 'toggleVim' command from the Command Palette.\n *\n * @param isDisabled if true, sets VSCodeVim to Disabled mode; else sets to enabled mode\n */\nasync function toggleExtension(isDisabled: boolean, compositionState: CompositionState) {\n  await VSCodeContext.set('vim.active', !isDisabled);\n  const mh = await getAndUpdateModeHandler();\n  if (mh) {\n    if (isDisabled) {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionDisable);\n      compositionState.reset();\n      ModeHandlerMap.clear();\n    } else {\n      await mh.handleKeyEvent(SpecialKeys.ExtensionEnable);\n    }\n  }\n}\n\nfunction overrideCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (configuration.disableExtension) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    if (!vscode.window.activeTextEditor) {\n      return;\n    }\n\n    if (\n      vscode.window.activeTextEditor.document &&\n      vscode.window.activeTextEditor.document.uri.toString() === 'debug:input'\n    ) {\n      return vscode.commands.executeCommand('default:' + command, args);\n    }\n\n    return callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nexport function registerCommand(\n  context: vscode.ExtensionContext,\n  command: string,\n  callback: (...args: any[]) => any,\n  requiresActiveEditor: boolean = true\n) {\n  const disposable = vscode.commands.registerCommand(command, async (args) => {\n    if (requiresActiveEditor && !vscode.window.activeTextEditor) {\n      return;\n    }\n\n    callback(args);\n  });\n  context.subscriptions.push(disposable);\n}\n\nexport function registerEventListener<T>(\n  context: vscode.ExtensionContext,\n  event: vscode.Event<T>,\n  listener: (e: T) => void,\n  exitOnExtensionDisable = true,\n  exitOnTests = false\n) {\n  const disposable = event(async (e) => {\n    if (exitOnExtensionDisable && configuration.disableExtension) {\n      return;\n    }\n\n    if (exitOnTests && Globals.isTesting) {\n      return;\n    }\n\n    listener(e);\n  });\n  context.subscriptions.push(disposable);\n}\n\n/**\n * @returns true if there was a remap being executed to stop\n */\nasync function forceStopRecursiveRemap(mh: ModeHandler): Promise<boolean> {\n  if (mh.remapState.isCurrentlyPerformingRecursiveRemapping) {\n    mh.remapState.forceStopRecursiveRemapping = true;\n    return true;\n  }\n\n  return false;\n}\n\nfunction handleContentChangedFromDisk(document: vscode.TextDocument): void {\n  ModeHandlerMap.getAll()\n    .filter((modeHandler) => modeHandler.vimState.documentUri === document.uri)\n    .forEach((modeHandler) => {\n      modeHandler.vimState.historyTracker = new HistoryTracker(modeHandler.vimState);\n    });\n}\n","import { Position } from 'vscode';\nimport { Cursor } from '../common/motion/cursor';\nimport { Notation } from '../configuration/notation';\nimport { ActionType, IBaseAction } from \"./types\";\nimport { isTextTransformation } from '../transformations/transformations';\nimport { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\nimport { VimState } from './../state/vimState';\n\nexport abstract class BaseAction implements IBaseAction {\n  abstract readonly actionType: ActionType;\n\n  /**\n   * If true, the cursor position will be added to the jump list on completion.\n   */\n  public readonly isJump: boolean = false;\n\n  /**\n   * If true, the action will create an undo point.\n   */\n  public readonly createsUndoPoint: boolean = false;\n\n  /**\n   * If this is being run in multi cursor mode, the index of the cursor\n   * this action is being applied to.\n   */\n  public multicursorIndex: number | undefined;\n\n  /**\n   * Whether we should change `vimState.desiredColumn`\n   */\n  public readonly preservesDesiredColumn: boolean = false;\n\n  /**\n   * Modes that this action can be run in.\n   */\n  public abstract readonly modes: readonly Mode[];\n\n  /**\n   * The sequence of keys you use to trigger the action, or a list of such sequences.\n   */\n  public abstract readonly keys: readonly string[] | readonly string[][];\n\n  /**\n   * The keys pressed at the time that this action was triggered.\n   */\n  // TODO: make readonly\n  public keysPressed: string[] = [];\n\n  private static readonly isSingleNumber: RegExp = /^[0-9]$/;\n  private static readonly isSingleAlpha: RegExp = /^[a-zA-Z]$/;\n\n  /**\n   * Is this action valid in the current Vim state?\n   */\n  public doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (\n      vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode && this.actionType === 'command'\n    ) {\n      return false;\n    }\n\n    return (\n      this.modes.includes(vimState.currentMode) &&\n      BaseAction.CompareKeypressSequence(this.keys, keysPressed)\n    );\n  }\n\n  /**\n   * Could the user be in the process of doing this action.\n   */\n  public couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (\n      vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode && this.actionType === 'command'\n    ) {\n      return false;\n    }\n\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n\n    const keys2D = BaseAction.is2DArray(this.keys) ? this.keys : [this.keys];\n    const keysSlice = keys2D.map((x) => x.slice(0, keysPressed.length));\n    if (!BaseAction.CompareKeypressSequence(keysSlice, keysPressed)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public static CompareKeypressSequence(\n    one: readonly string[] | readonly string[][],\n    two: readonly string[]\n  ): boolean {\n    if (BaseAction.is2DArray(one)) {\n      for (const sequence of one) {\n        if (BaseAction.CompareKeypressSequence(sequence, two)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (one.length !== two.length) {\n      return false;\n    }\n\n    for (let i = 0, j = 0; i < one.length; i++, j++) {\n      const left = one[i];\n      const right = two[j];\n\n      if (left === right && right !== configuration.leader) {\n        continue;\n      } else if (left === '<any>') {\n        continue;\n      } else if (left === '<leader>' && right === configuration.leader) {\n        continue;\n      } else if (left === '<number>' && this.isSingleNumber.test(right)) {\n        continue;\n      } else if (left === '<alpha>' && this.isSingleAlpha.test(right)) {\n        continue;\n      } else if (left === '<character>' && !Notation.IsControlKey(right)) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  public toString(): string {\n    return this.keys.join('');\n  }\n\n  private static is2DArray<T>(x: readonly T[] | readonly T[][]): x is readonly T[][] {\n    return Array.isArray(x[0]);\n  }\n}\n\n/**\n * A command is something like <Esc>, :, v, i, etc.\n */\nexport abstract class BaseCommand extends BaseAction {\n  override actionType: ActionType = 'command' as const;\n\n  /**\n   * If isCompleteAction is true, then triggering this command is a complete action -\n   * that means that we'll go and try to run it.\n   */\n  public isCompleteAction = true;\n\n  /**\n   * In multi-cursor mode, do we run this command for every cursor, or just once?\n   */\n  public runsOnceForEveryCursor(): boolean {\n    return true;\n  }\n\n  /**\n   * If true, exec() will get called N times where N is the count.\n   *\n   * If false, exec() will only be called once, and you are expected to\n   * handle count prefixes (e.g. the 3 in 3w) yourself.\n   */\n  public readonly runsOnceForEachCountPrefix: boolean = false;\n\n  /**\n   * Run the command a single time.\n   */\n  public async exec(position: Position, vimState: VimState): Promise<void> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the command the number of times VimState wants us to.\n   */\n  public async execCount(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = this.runsOnceForEachCountPrefix ? vimState.recordedState.count || 1 : 1;\n\n    if (!this.runsOnceForEveryCursor()) {\n      for (let i = 0; i < timesToRepeat; i++) {\n        await this.exec(position, vimState);\n      }\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = 0;\n        }\n      }\n\n      return;\n    }\n\n    const resultingCursors: Cursor[] = [];\n\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Cursor(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    let cursorIndex = 0;\n    for (const { start, stop } of cursorsToIterateOver) {\n      this.multicursorIndex = cursorIndex++;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      for (let j = 0; j < timesToRepeat; j++) {\n        await this.exec(stop, vimState);\n      }\n\n      resultingCursors.push(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\nexport enum KeypressState {\n  WaitingOnKeys,\n  NoPossibleMatch,\n}\n\n/**\n * Every Vim action will be added here with the @RegisterAction decorator.\n */\nconst actionMap = new Map<Mode, Array<new () => BaseAction>>();\n\n/**\n * Gets the action that should be triggered given a key sequence.\n *\n * If there is a definitive action that matched, returns that action.\n *\n * If an action could potentially match if more keys were to be pressed, returns `KeyPressState.WaitingOnKeys`\n * (e.g. you pressed \"g\" and are about to press \"g\" action to make the full action \"gg\")\n *\n * If no action could ever match, returns `KeypressState.NoPossibleMatch`.\n */\nexport function getRelevantAction(\n  keysPressed: string[],\n  vimState: VimState\n): BaseAction | KeypressState {\n  const possibleActionsForMode = actionMap.get(vimState.currentMode) ?? [];\n\n  let hasPotentialMatch = false;\n  for (const actionType of possibleActionsForMode) {\n    // TODO: Constructing up to several hundred Actions every time we hit a key is moronic.\n    //       I think we can make `doesActionApply` and `couldActionApply` static...\n    const action = new actionType();\n    if (action.doesActionApply(vimState, keysPressed)) {\n      action.keysPressed = vimState.recordedState.actionKeys.slice(0);\n      return action;\n    }\n\n    hasPotentialMatch ||= action.couldActionApply(vimState, keysPressed);\n  }\n\n  return hasPotentialMatch ? KeypressState.WaitingOnKeys : KeypressState.NoPossibleMatch;\n}\n\nexport function RegisterAction(action: new () => BaseAction): void {\n  const actionInstance = new action();\n  for (const modeName of actionInstance.modes) {\n    let actions = actionMap.get(modeName);\n    if (!actions) {\n      actions = [];\n      actionMap.set(modeName, actions);\n    }\n\n    if (actionInstance.keys === undefined) {\n      // action that can't be called directly\n      continue;\n    }\n\n    actions.push(action);\n  }\n}\n","import { BaseAction } from './base';\nimport { Mode } from '../mode/mode';\nimport { VimState } from '../state/vimState';\nimport { clamp } from '../util/util';\nimport { Position } from 'vscode';\n\nexport function isIMovement(o: IMovement | Position): o is IMovement {\n  return (o as IMovement).start !== undefined && (o as IMovement).stop !== undefined;\n}\n\nexport enum SelectionType {\n  Concatenating, // Selections that concatenate repeated movements\n  Expanding, // Selections that expand the start and end of the previous selection\n}\n\n/**\n * The result of a (more sophisticated) Movement.\n */\nexport interface IMovement {\n  start: Position;\n  stop: Position;\n\n  /**\n   * Whether this motion succeeded. Some commands, like fx when 'x' can't be found,\n   * will not move the cursor. Furthermore, dfx won't delete *anything*, even though\n   * deleting to the current character would generally delete 1 character.\n   */\n  failed?: boolean;\n\n  /**\n   * Wheter this motion resulted in the current multicursor index being removed. This\n   * happens when multiple selections combine into one.\n   */\n  removed?: boolean;\n}\n\nexport function failedMovement(vimState: VimState): IMovement {\n  return {\n    start: vimState.cursorStartPosition,\n    stop: vimState.cursorStopPosition,\n    failed: true,\n  };\n}\n\nexport abstract class BaseMovement extends BaseAction {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  override actionType = 'motion' as const;\n\n  /**\n   * If movement can be repeated with semicolon or comma this will be true when\n   * running the repetition.\n   */\n  isRepeat = false;\n\n  /**\n   * This is for commands like $ which force the desired column to be at\n   * the end of even the longest line.\n   */\n  public setsDesiredColumnToEOL = false;\n\n  protected selectionType = SelectionType.Concatenating;\n\n  constructor(keysPressed?: string[], isRepeat?: boolean) {\n    super();\n\n    if (keysPressed) {\n      this.keysPressed = keysPressed;\n    }\n\n    if (isRepeat) {\n      this.isRepeat = isRepeat;\n    }\n  }\n\n  /**\n   * Run the movement a single time.\n   *\n   * Generally returns a new Position. If necessary, it can return an IMovement instead.\n   * Note: If returning an IMovement, make sure that repeated actions on a\n   * visual selection work. For example, V}}\n   */\n  public async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    throw new Error('Not implemented!');\n  }\n\n  /**\n   * Run the movement in an operator context a single time.\n   *\n   * Some movements operate over different ranges when used for operators.\n   */\n  protected async execActionForOperator(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position | IMovement> {\n    return this.execAction(position, vimState, firstIteration, lastIteration);\n  }\n\n  /**\n   * Run a movement count times.\n   *\n   * count: the number prefix the user entered, or 0 if they didn't enter one.\n   */\n  public async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    let result!: Position | IMovement;\n    let prevResult = failedMovement(vimState);\n    let firstMovementStart = position;\n\n    count = clamp(count, 1, 99999);\n\n    for (let i = 0; i < count; i++) {\n      const firstIteration = i === 0;\n      const lastIteration = i === count - 1;\n      result =\n        vimState.recordedState.operator && lastIteration\n          ? await this.execActionForOperator(position, vimState, firstIteration, lastIteration)\n          : await this.execAction(position, vimState, firstIteration, lastIteration);\n\n      if (result instanceof Position) {\n        /**\n         * This position will be passed to the `motion` on the next iteration,\n         * it may cause some issues when count > 1.\n         */\n        position = result;\n      } else {\n        if (result.failed) {\n          return prevResult;\n        }\n\n        if (firstIteration) {\n          firstMovementStart = result.start;\n        }\n\n        position = this.adjustPosition(position, result, lastIteration);\n        prevResult = result;\n      }\n    }\n\n    if (this.selectionType === SelectionType.Concatenating && isIMovement(result)) {\n      result.start = firstMovementStart;\n    }\n\n    return result;\n  }\n\n  protected adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop.getRightThroughLineBreaks();\n    }\n    return position;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { getCursorsAfterSync } from '../../util/util';\nimport { Clipboard } from '../../util/clipboard';\nimport { FileCommand } from './../../cmd_line/commands/file';\nimport { QuitCommand } from './../../cmd_line/commands/quit';\nimport { TabCommandType, TabCommand } from './../../cmd_line/commands/tab';\nimport { PositionDiff, earlierOf, laterOf, sorted } from './../../common/motion/position';\nimport { Cursor } from '../../common/motion/cursor';\nimport { NumericString } from './../../common/number/numericString';\nimport { configuration } from './../../configuration/configuration';\nimport {\n  Mode,\n  visualBlockGetTopLeftPosition,\n  isVisualMode,\n  visualBlockGetBottomRightPosition,\n} from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { TextEditor } from './../../textEditor';\nimport { isTextTransformation, Transformation } from './../../transformations/transformations';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { ExCommandLine, SearchCommandLine } from './../../cmd_line/commandLine';\nimport * as operator from './../operator';\nimport { StatusBar } from '../../statusBar';\nimport { reportFileInfo, reportSearch } from '../../util/statusBarTextUtils';\nimport { globalState } from '../../state/globalState';\nimport { SpecialKeys } from '../../util/specialKeys';\nimport { WordType } from '../../textobject/word';\nimport { Position } from 'vscode';\nimport { WriteQuitCommand } from '../../cmd_line/commands/writequit';\nimport { shouldWrapKey } from '../wrapping';\nimport { ErrorCode, VimError } from '../../error';\nimport { SearchDirection } from '../../vimscript/pattern';\nimport { doesFileExist } from 'platform/fs';\nimport { exCommandParser } from '../../vimscript/exCommandParser';\n\n/**\n * A very special snowflake.\n *\n * Each keystroke when typing in Insert mode is its own Action, which means naively replaying a\n * realistic insertion (via `.` or a macro) does many small insertions, which is very slow.\n * So instead, we fold all those actions after the fact into a single DocumentContentChangeAction,\n * which compresses the changes, generally into a single document edit per cursor.\n */\nexport class DocumentContentChangeAction extends BaseCommand {\n  modes = [];\n  keys = [];\n  private readonly cursorStart: Position;\n  private cursorEnd: Position;\n\n  constructor(cursorStart: Position) {\n    super();\n    this.cursorStart = cursorStart;\n    this.cursorEnd = cursorStart;\n  }\n\n  private contentChanges: vscode.TextDocumentContentChangeEvent[] = [];\n\n  public addChanges(changes: vscode.TextDocumentContentChangeEvent[], cursorPosition: Position) {\n    this.contentChanges = [...this.contentChanges, ...changes];\n    this.compressChanges();\n    this.cursorEnd = cursorPosition;\n  }\n\n  public getTransformation(positionDiff: PositionDiff): Transformation {\n    return {\n      type: 'contentChange',\n      changes: this.contentChanges,\n      diff: positionDiff,\n    };\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.contentChanges.length === 0) {\n      return;\n    }\n\n    let originalLeftBoundary = this.cursorStart;\n\n    let rightBoundary: Position = position;\n    for (const change of this.contentChanges) {\n      if (change.range.start.line < originalLeftBoundary.line) {\n        // This change should be ignored\n        const linesAffected = change.range.end.line - change.range.start.line + 1;\n        const resultLines = change.text.split('\\n').length;\n        originalLeftBoundary = originalLeftBoundary.with(\n          Math.max(0, originalLeftBoundary.line + resultLines - linesAffected)\n        );\n        continue;\n      }\n\n      // Translates diffPos from a position relative to originalLeftBoundary to one relative to position\n      const translate = (diffPos: Position): Position => {\n        const lineOffset = diffPos.line - originalLeftBoundary.line;\n        const char =\n          lineOffset === 0\n            ? position.character + diffPos.character - originalLeftBoundary.character\n            : diffPos.character;\n        // TODO: Should we document.validate() this position?\n        return new Position(Math.max(position.line + lineOffset, 0), Math.max(char, 0));\n      };\n\n      const replaceRange = new vscode.Range(\n        translate(change.range.start),\n        translate(change.range.end)\n      );\n\n      if (replaceRange.start.isAfter(rightBoundary)) {\n        // This change should be ignored as it's out of boundary\n        continue;\n      }\n\n      // Calculate new right boundary\n      const textDiffLines = change.text.split('\\n');\n      const numLinesAdded = textDiffLines.length - 1;\n      const newRightBoundary =\n        numLinesAdded === 0\n          ? new Position(replaceRange.start.line, replaceRange.start.character + change.text.length)\n          : new Position(replaceRange.start.line + numLinesAdded, textDiffLines.pop()!.length);\n\n      rightBoundary = laterOf(rightBoundary, newRightBoundary);\n\n      if (replaceRange.start.isEqual(replaceRange.end)) {\n        vimState.recordedState.transformer.insert(\n          replaceRange.start,\n          change.text,\n          PositionDiff.exactPosition(translate(this.cursorEnd))\n        );\n      } else {\n        vimState.recordedState.transformer.replace(\n          replaceRange,\n          change.text,\n          PositionDiff.exactPosition(translate(this.cursorEnd))\n        );\n      }\n    }\n  }\n\n  private compressChanges(): void {\n    function merge(\n      first: vscode.TextDocumentContentChangeEvent,\n      second: vscode.TextDocumentContentChangeEvent\n    ): vscode.TextDocumentContentChangeEvent | undefined {\n      if (first.rangeOffset + first.text.length === second.rangeOffset) {\n        // Simple concatenation\n        return {\n          text: first.text + second.text,\n          range: first.range,\n          rangeOffset: first.rangeOffset,\n          rangeLength: first.rangeLength,\n        };\n      } else if (\n        first.rangeOffset <= second.rangeOffset &&\n        first.text.length >= second.rangeLength\n      ) {\n        const start = second.rangeOffset - first.rangeOffset;\n        const end = start + second.rangeLength;\n        const text = first.text.slice(0, start) + second.text + first.text.slice(end);\n        // `second` replaces part of `first`\n        // Most often, this is the result of confirming an auto-completion\n        return {\n          text,\n          range: first.range,\n          rangeOffset: first.rangeOffset,\n          rangeLength: first.rangeLength,\n        };\n      } else {\n        // TODO: Do any of the cases falling into this `else` matter?\n        // TODO: YES - make an insertion and then autocomplete to something totally different (replace subsumes insert)\n        return undefined;\n      }\n    }\n\n    const compressed: vscode.TextDocumentContentChangeEvent[] = [];\n    let prev: vscode.TextDocumentContentChangeEvent | undefined;\n    for (const change of this.contentChanges) {\n      if (prev === undefined) {\n        prev = change;\n      } else {\n        const merged = merge(prev, change);\n        if (merged) {\n          prev = merged;\n        } else {\n          compressed.push(prev);\n          prev = change;\n        }\n      }\n    }\n    if (prev !== undefined) {\n      compressed.push(prev);\n    }\n    this.contentChanges = compressed;\n  }\n}\n\n@RegisterAction\nclass DisableExtension extends BaseCommand {\n  modes = [\n    Mode.Normal,\n    Mode.Insert,\n    Mode.Visual,\n    Mode.VisualBlock,\n    Mode.VisualLine,\n    Mode.SearchInProgressMode,\n    Mode.CommandlineInProgress,\n    Mode.Replace,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n    Mode.SurroundInputMode,\n  ];\n  keys = [SpecialKeys.ExtensionDisable];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Disabled);\n  }\n}\n\n@RegisterAction\nclass EnableExtension extends BaseCommand {\n  modes = [Mode.Disabled];\n  keys = [SpecialKeys.ExtensionEnable];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandNumber extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<number>'];\n  override isCompleteAction = false;\n  override actionType = 'number' as const;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const num = parseInt(this.keysPressed[0], 10);\n    const operatorCount = vimState.recordedState.operatorCount;\n\n    if (operatorCount > 0) {\n      const lastAction =\n        vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n      if (!(lastAction instanceof CommandNumber)) {\n        // We have set an operatorCount !== 0 after an operator, but now we got another count\n        // number so we need to multiply them.\n        vimState.recordedState.count = operatorCount * num;\n      } else {\n        // We are now getting another digit which means we need to multiply by 10 and add\n        // the new digit multiplied by operatorCount.\n        //\n        // Example: user presses '2d31w':\n        // - After '2' the number 2 is stored in 'count'\n        // - After 'd' the count (2) is stored in 'operatorCount'\n        // - After '3' the number 3 multiplied by 'operatorCount' (3 x 2 = 6) is stored in 'count'\n        // - After '1' the count is multiplied by 10 and added by number 1 multiplied by 'operatorCount'\n        //   (6 * 10 + 1 * 2 = 62)\n        // The final result will be the deletion of 62 words.\n        vimState.recordedState.count = vimState.recordedState.count * 10 + num * operatorCount;\n      }\n    } else {\n      vimState.recordedState.count = vimState.recordedState.count * 10 + num;\n    }\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const isZero = keysPressed[0] === '0';\n\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      ((isZero && vimState.recordedState.count > 0) || !isZero)\n    );\n  }\n}\n\n@RegisterAction\nexport class CommandRegister extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['\"', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1];\n\n    if (Register.isValidRegister(register)) {\n      vimState.recordedState.registerName = register;\n    } else {\n      // TODO: Changing isCompleteAction here is maybe a bit janky - should it be a function?\n      this.isCompleteAction = true;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['q', '<alpha>'],\n    ['q', '<number>'],\n    ['q', '\"'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const registerKey = this.keysPressed[1];\n    const register = registerKey.toLocaleLowerCase();\n    vimState.macro = new RecordedState();\n    vimState.macro.registerKey = registerKey;\n    vimState.macro.registerName = register;\n\n    if (!Register.isValidUppercaseRegister(registerKey) || !Register.has(register)) {\n      // TODO: this seems suspect - why are we not putting `vimState.macro` in the register? Why are we setting `registerName`?\n      const newRegister = new RecordedState();\n      newRegister.registerName = register;\n\n      vimState.recordedState.registerName = register;\n      Register.put(vimState, newRegister);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandQuitRecordMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['q'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const macro = vimState.macro;\n    if (macro === undefined) {\n      return;\n    }\n\n    const existingMacro = (await Register.get(macro.registerName))?.text;\n    if (existingMacro instanceof RecordedState) {\n      if (Register.isValidUppercaseRegister(macro.registerKey)) {\n        existingMacro.actionsRun = existingMacro.actionsRun.concat(macro.actionsRun);\n      } else {\n        existingMacro.actionsRun = macro.actionsRun;\n      }\n    }\n\n    vimState.macro = undefined;\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.macro !== undefined;\n  }\n}\n\n@RegisterAction\nclass CommandExecuteLastMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '@'];\n  override runsOnceForEachCountPrefix = true;\n  override createsUndoPoint = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const { lastInvokedMacro } = vimState;\n\n    if (lastInvokedMacro) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: lastInvokedMacro.registerName,\n        replay: 'contentChange',\n      });\n    } else {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoPreviouslyUsedRegister));\n    }\n  }\n}\n\n@RegisterAction\nclass CommandExecuteMacro extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['@', '<character>'];\n  override runsOnceForEachCountPrefix = true;\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = this.keysPressed[1].toLocaleLowerCase();\n\n    const isFilenameRegister = register === '%' || register === '#';\n    if (!Register.isValidRegister(register) || isFilenameRegister) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.InvalidRegisterName, `'${register}'`)\n      );\n    }\n\n    if (Register.has(register)) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register,\n        replay: 'contentChange',\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEsc extends BaseCommand {\n  modes = [\n    Mode.Visual,\n    Mode.VisualLine,\n    Mode.VisualBlock,\n    Mode.Normal,\n    Mode.SurroundInputMode,\n    Mode.EasyMotionMode,\n    Mode.EasyMotionInputMode,\n  ];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  override preservesDesiredColumn = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.surround = undefined;\n\n      if (vimState.isMultiCursor) {\n        vimState.cursors = [vimState.cursors[0]];\n      } else {\n        // If there's nothing to do on the vim side, we might as well call some\n        // of vscode's default \"close notification\" actions. I think we should\n        // just add to this list as needed.\n        await Promise.allSettled([\n          vscode.commands.executeCommand('closeReferenceSearchEditor'),\n          vscode.commands.executeCommand('closeMarkersNavigation'),\n          vscode.commands.executeCommand('closeDirtyDiff'),\n        ]);\n      }\n    } else {\n      if (vimState.currentMode === Mode.EasyMotionMode) {\n        vimState.easyMotion.clearDecorations(vimState.editor);\n      } else if (vimState.currentMode === Mode.SurroundInputMode) {\n        vimState.surround = undefined;\n      }\n\n      await vimState.setCurrentMode(Mode.Normal);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['i'], ['<Insert>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other\n    // actions or operators before\n    let previousActionsNumbers = true;\n    for (const prevAction of vimState.recordedState.actionsRun) {\n      if (!(prevAction instanceof CommandNumber)) {\n        previousActionsNumbers = false;\n        break;\n      }\n    }\n\n    if (vimState.recordedState.actionsRun.length === 0 || previousActionsNumbers) {\n      return super.couldActionApply(vimState, keysPressed);\n    }\n    return false;\n  }\n}\n\n@RegisterAction\nexport class CommandReplaceAtCursorFromNormalMode extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['R'];\n\n  public override runsOnceForEveryCursor(): boolean {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Replace);\n  }\n}\n\n/**\n * Our Vim implementation selects up to but not including the final character\n * of a visual selection, instead opting to render a block cursor on the final\n * character. This works for everything except VSCode's native copy command,\n * which loses the final character because it's not selected. We override that\n * copy command here by default to include the final character.\n */\n@RegisterAction\nclass CommandOverrideCopy extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock, Mode.Insert, Mode.Normal];\n  keys = ['<copy>']; // A special key - see ModeHandler\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let text = '';\n\n    if (vimState.currentMode === Mode.Visual) {\n      text = vimState.cursors\n        .map((range) => {\n          const [start, stop] = sorted(range.start, range.stop);\n          return vimState.document.getText(new vscode.Range(start, stop.getRight()));\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualLine) {\n      text = vimState.cursors\n        .map((range) => {\n          return vimState.document.getText(\n            new vscode.Range(\n              earlierOf(range.start.getLineBegin(), range.stop.getLineBegin()),\n              laterOf(range.start.getLineEnd(), range.stop.getLineEnd())\n            )\n          );\n        })\n        .join('\\n');\n    } else if (vimState.currentMode === Mode.VisualBlock) {\n      for (const { line } of TextEditor.iterateLinesInBlock(vimState)) {\n        text += line + '\\n';\n      }\n    } else if (vimState.currentMode === Mode.Insert || vimState.currentMode === Mode.Normal) {\n      text = vimState.editor.selections\n        .map((selection) => {\n          return vimState.document.getText(new vscode.Range(selection.start, selection.end));\n        })\n        .join('\\n');\n    }\n\n    const editorSelection = vimState.editor.selection;\n    const hasSelectedText = !editorSelection.active.isEqual(editorSelection.anchor);\n\n    if (hasSelectedText) {\n      await Clipboard.Copy(text);\n    }\n\n    // all vim yank operations return to normal mode.\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandCmdA extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['<D-a>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStartPosition = new Position(0, vimState.desiredColumn);\n    vimState.cursorStopPosition = new Position(\n      vimState.document.lineCount - 1,\n      vimState.desiredColumn\n    );\n    await vimState.setCurrentMode(Mode.VisualLine);\n  }\n}\n\n@RegisterAction\nclass MarkCommand extends BaseCommand {\n  keys = ['m', '<character>'];\n  modes = [Mode.Normal];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const markName = this.keysPressed[1];\n\n    vimState.historyTracker.addMark(position, markName);\n  }\n}\n\n@RegisterAction\nclass CommandShowCommandLine extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [':'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let commandLineText: string;\n    if (vimState.currentMode === Mode.Normal) {\n      if (vimState.recordedState.count) {\n        commandLineText = `.,.+${vimState.recordedState.count - 1}`;\n      } else {\n        commandLineText = '';\n      }\n    } else {\n      commandLineText = \"'<,'>\";\n    }\n\n    const previousMode = vimState.currentMode;\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n    // TODO: Change or supplement `setCurrentMode` API so this isn't necessary\n    if (vimState.modeData.mode === Mode.CommandlineInProgress) {\n      vimState.modeData.commandLine = new ExCommandLine(commandLineText, previousMode);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandShowCommandHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['q', ':'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cmd = await vscode.window.showQuickPick(ExCommandLine.history.get().slice().reverse(), {\n      placeHolder: 'Vim command history',\n      ignoreFocusOut: false,\n    });\n    if (cmd && cmd.length !== 0) {\n      await new ExCommandLine(cmd, vimState.currentMode).run(vimState);\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class CommandShowSearchHistory extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = [\n    ['q', '/'],\n    ['q', '?'],\n  ];\n\n  private direction = SearchDirection.Forward;\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public constructor(direction = SearchDirection.Forward) {\n    super();\n    this.direction = direction;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (this.keysPressed.includes('?')) {\n      this.direction = SearchDirection.Backward;\n    }\n\n    const searchState = await SearchCommandLine.showSearchHistory();\n    if (searchState) {\n      globalState.searchState = searchState;\n      globalState.hl = true;\n\n      const nextMatch = searchState.getNextSearchMatchPosition(\n        vimState,\n        vimState.cursorStartPosition,\n        this.direction\n      );\n\n      if (!nextMatch) {\n        throw VimError.fromCode(\n          this.direction > 0 ? ErrorCode.SearchHitBottom : ErrorCode.SearchHitTop,\n          searchState.searchString\n        );\n      }\n\n      vimState.cursorStopPosition = nextMatch.pos;\n      reportSearch(nextMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandDot extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['.'];\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    if (globalState.previousFullAction) {\n      const count = vimState.recordedState.count || 1;\n\n      for (let i = 0; i < count; i++) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replayRecordedState',\n          recordedState: globalState.previousFullAction,\n        });\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRepeatSubstitution extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['&'];\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Parsing the command from a string, while not ideal, is currently\n    // necessary to make this work with and without neovim integration\n    await exCommandParser.tryParse('s').command.execute(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherEndOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['o'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition,\n    ];\n  }\n}\n\n@RegisterAction\nclass CommandGoToOtherSideOfHighlightedText extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['O'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      [vimState.cursorStartPosition, vimState.cursorStopPosition] = [\n        new vscode.Position(\n          vimState.cursorStartPosition.line,\n          vimState.cursorStopPosition.character\n        ),\n        new vscode.Position(\n          vimState.cursorStopPosition.line,\n          vimState.cursorStartPosition.character\n        ),\n      ];\n    } else {\n      return new CommandGoToOtherEndOfHighlightedText().exec(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandUndo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['u'];\n  // we support a count to undo by this setting\n  override runsOnceForEachCountPrefix = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goBackHistoryStep();\n\n    if (newPosition === undefined) {\n      StatusBar.setText(vimState, 'Already at oldest change');\n    } else {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandUndoOnLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['U'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goBackHistoryStepsOnLine();\n\n    if (newPosition !== undefined) {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandRedo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-r>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newPosition = await vimState.historyTracker.goForwardHistoryStep();\n\n    if (newPosition === undefined) {\n      StatusBar.setText(vimState, 'Already at newest change');\n    } else {\n      vimState.cursors = [new Cursor(newPosition, newPosition)];\n    }\n  }\n}\n\n@RegisterAction\nclass CommandDeleteToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['D'];\n  override createsUndoPoint = true;\n  override runsOnceForEveryCursor() {\n    return true;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.isLineEnd()) {\n      return;\n    }\n\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position;\n    const end = position.getDown(linesDown).getLineEnd().getLeftThroughLineBreaks();\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class CommandYankFullLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['Y'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const linesDown = (vimState.recordedState.count || 1) - 1;\n    const start = position.getLineBegin();\n    const end = position.getDown(linesDown).getLeft();\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new operator.YankOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass CommandChangeToLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['C'];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position\n        .getDown(Math.max(0, count - 1))\n        .getLineEnd()\n        .getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass CommandClearLine extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['S'];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator(this.multicursorIndex).runRepeat(\n      vimState,\n      position,\n      vimState.recordedState.count || 1\n    );\n  }\n\n  // Don't clash with sneak\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualMode extends BaseCommand {\n  modes = [Mode.Visual];\n  keys = ['v'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandVisualMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['v'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass CommandReselectVisual extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'v'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Try to restore selection only if valid\n    if (vimState.lastVisualSelection !== undefined) {\n      let { start, end, mode } = vimState.lastVisualSelection;\n\n      if (end.line <= vimState.document.lineCount - 1) {\n        if (mode === Mode.Visual && start.isBeforeOrEqual(end)) {\n          end = end.getLeftThroughLineBreaks(true);\n        }\n\n        await vimState.setCurrentMode(mode);\n        vimState.cursorStartPosition = start;\n        vimState.cursorStopPosition = end;\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandVisualBlockMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getRight(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.VisualBlock);\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['<C-v>'], ['<C-q>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandVisualLineMode extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  keys = ['V'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.currentMode === Mode.Normal && vimState.recordedState.count > 1) {\n      vimState.cursorStopPosition = position.getDown(vimState.recordedState.count - 1);\n    }\n    await vimState.setCurrentMode(Mode.VisualLine);\n  }\n}\n\n@RegisterAction\nclass CommandExitVisualLineMode extends BaseCommand {\n  modes = [Mode.VisualLine];\n  keys = ['V'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandOpenFile extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = ['g', 'f'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let fullFilePath: string;\n    if (vimState.currentMode === Mode.Visual) {\n      fullFilePath = vimState.document.getText(vimState.editor.selection);\n    } else {\n      const range = new vscode.Range(\n        position.prevWordStart(vimState.document, { wordType: WordType.FileName, inclusive: true }),\n        position.nextWordStart(vimState.document, { wordType: WordType.FileName })\n      );\n\n      fullFilePath = vimState.document.getText(range).trim();\n    }\n\n    const fileInfo = fullFilePath.match(/(.*?(?=:[0-9]+)|.*):?([0-9]*)$/);\n    if (fileInfo) {\n      const filePath = fileInfo[1];\n      const line = parseInt(fileInfo[2], 10);\n      const fileCommand = new FileCommand({\n        name: 'edit',\n        bang: false,\n        opt: [],\n        file: filePath,\n        cmd: isNaN(line) ? undefined : { type: 'line_number', line },\n        createFileIfNotExists: false,\n      });\n      fileCommand.execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass GoToDeclaration extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['g', 'd'],\n    ['g', 'D'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.goToDeclaration');\n\n    if (vimState.editor === vscode.window.activeTextEditor) {\n      // We didn't switch to a different editor\n      vimState.cursorStopPosition = vimState.editor.selection.start;\n    }\n  }\n}\n\n@RegisterAction\nclass GoToDefinition extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-]>'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.revealDefinition');\n\n    if (vimState.editor === vscode.window.activeTextEditor) {\n      // We didn't switch to a different editor\n      vimState.cursorStopPosition = vimState.editor.selection.start;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandOpenLink extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'x'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('editor.action.openLink');\n  }\n}\n\n@RegisterAction\nclass CommandGoBackInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ';'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const prevPos = vimState.historyTracker.prevChangeInChangeList();\n\n    if (prevPos instanceof VimError) {\n      StatusBar.displayError(vimState, prevPos);\n    } else {\n      vimState.cursorStopPosition = prevPos;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandGoForwardInChangelist extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', ','];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const nextPos = vimState.historyTracker.nextChangeInChangeList();\n\n    if (nextPos instanceof VimError) {\n      StatusBar.displayError(vimState, nextPos);\n    } else {\n      vimState.cursorStopPosition = nextPos;\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLastChange extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'i'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.cursorStopPosition = vimState.cursorStartPosition =\n      vimState.historyTracker.getLastChangeEndPosition() ?? new Position(0, 0);\n\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtFirstCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['I'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition =\n      TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLineBegin extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'I'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineBegin();\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAfterCursor extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['a'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getRight();\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Only allow this command to be prefixed with a count or nothing, no other actions or operators before\n    if (!vimState.recordedState.actionsRun.every((action) => action instanceof CommandNumber)) {\n      return false;\n    }\n\n    return super.couldActionApply(vimState, keysPressed);\n  }\n}\n\n@RegisterAction\nexport class CommandInsertAtLineEnd extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['A'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.cursorStopPosition = vimState.cursorStartPosition = position.getLineEnd();\n  }\n}\n\n@RegisterAction\nexport class CommandInsertNewLineAbove extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['O'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    const charPos = position.getLineBeginRespectingIndent(vimState.document).character;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineBefore');\n    }\n\n    vimState.cursors = getCursorsAfterSync(vimState.editor);\n    const endPos = vimState.cursors[0].start.character;\n    const indentAmt = charPos - endPos;\n\n    for (let i = 0; i < count; i++) {\n      const newPos = new Position(vimState.cursors[0].start.line + i, charPos);\n      if (i === 0) {\n        vimState.cursors[0] = new Cursor(newPos, newPos);\n      } else {\n        vimState.cursors.push(new Cursor(newPos, newPos));\n      }\n      if (indentAmt >= 0) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'insertText',\n          // TODO: Use `editor.options.insertSpaces`, I think\n          text: TextEditor.setIndentationLevel('', indentAmt, configuration.expandtab),\n          position: newPos,\n          cursorIndex: i,\n          manuallySetCursorPositions: true,\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          cursorIndex: i,\n          range: new vscode.Range(newPos, new Position(newPos.line, endPos)),\n          manuallySetCursorPositions: true,\n        });\n      }\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nexport class CommandInsertNewLineBefore extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['o'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    const count = vimState.recordedState.count || 1;\n\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand('editor.action.insertLineAfter');\n    }\n    vimState.cursors = getCursorsAfterSync(vimState.editor);\n    for (let i = 1; i < count; i++) {\n      const newPos = new Position(\n        vimState.cursorStartPosition.line - i,\n        vimState.cursorStartPosition.character\n      );\n      vimState.cursors.push(new Cursor(newPos, newPos));\n\n      // Ahhhhhh. We have to manually set cursor position here as we need text\n      // transformations AND to set multiple cursors.\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertText',\n        // TODO: Use `editor.options.insertSpaces`, I think\n        text: TextEditor.setIndentationLevel('', newPos.character, configuration.expandtab),\n        position: newPos,\n        cursorIndex: i,\n        manuallySetCursorPositions: true,\n      });\n    }\n    vimState.cursors = vimState.cursors.reverse();\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateBack extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-o>'], ['<C-t>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpBack(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandNavigateForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-i>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await globalState.jumpTracker.jumpForward(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandTabNext extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 't'], ['<C-pagedown>']];\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // gt behaves differently than gT and goes to an absolute index tab\n    // (1-based), it does NOT iterate over next tabs\n    if (vimState.recordedState.count > 0) {\n      new TabCommand({\n        type: TabCommandType.Absolute,\n        count: vimState.recordedState.count - 1,\n      }).execute(vimState);\n    } else {\n      new TabCommand({\n        type: TabCommandType.Next,\n        bang: false,\n      }).execute(vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandTabPrevious extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [['g', 'T'], ['<C-pageup>']];\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new TabCommand({\n      type: TabCommandType.Previous,\n      bang: false,\n    }).execute(vimState);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['x'];\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // If line is empty, do nothing\n    if (vimState.document.lineAt(position).text.length === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position.getRight(timesToRepeat - 1).getLeftIfEOL()\n    );\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteCharWithDeleteKey extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<Del>'];\n  override runsOnceForEachCountPrefix = true;\n  override createsUndoPoint = true;\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    // If <del> has a count in front of it, then <del> deletes a character\n    // off the count. Therefore, 100<del>x, would apply 'x' 10 times.\n    // http://vimdoc.sourceforge.net/htmldoc/change.html#<Del>\n    if (vimState.recordedState.count !== 0) {\n      vimState.recordedState.count = Math.floor(vimState.recordedState.count / 10);\n\n      // Change actionsRunPressedKeys so that showCmd updates correctly\n      vimState.recordedState.actionsRunPressedKeys =\n        vimState.recordedState.count > 0 ? vimState.recordedState.count.toString().split('') : [];\n      this.isCompleteAction = false;\n    } else {\n      await new ActionDeleteChar().execCount(position, vimState);\n    }\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteLastChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['X'];\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.character === 0) {\n      return;\n    }\n\n    const timesToRepeat = vimState.recordedState.count || 1;\n\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      position.getLeft(timesToRepeat),\n      position.getLeft()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionJoin extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['J'];\n  override createsUndoPoint = true;\n  override runsOnceForEachCountPrefix = false;\n\n  private firstNonWhitespaceIndex(str: string): number {\n    for (let i = 0, len = str.length; i < len; i++) {\n      const chCode = str.charCodeAt(i);\n      if (chCode !== 32 /** space */ && chCode !== 9 /** tab */) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  public async execJoinLines(\n    startPosition: Position,\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<void> {\n    count = count - 1 || 1;\n\n    const joinspaces = configuration.joinspaces;\n\n    let startLineNumber: number;\n    let startColumn: number;\n    let endLineNumber: number;\n    let endColumn: number;\n    let columnDeltaOffset: number = 0;\n\n    if (startPosition.isEqual(position) || startPosition.line === position.line) {\n      if (position.line + 1 < vimState.document.lineCount) {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.getDown(count).line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      } else {\n        startLineNumber = position.line;\n        startColumn = 0;\n        endLineNumber = position.line;\n        endColumn = TextEditor.getLineLength(endLineNumber);\n      }\n    } else {\n      startLineNumber = startPosition.line;\n      startColumn = 0;\n      endLineNumber = position.line;\n      endColumn = TextEditor.getLineLength(endLineNumber);\n    }\n\n    let trimmedLinesContent = vimState.document.lineAt(startPosition).text;\n\n    for (let i = startLineNumber + 1; i <= endLineNumber; i++) {\n      const lineText = vimState.document.lineAt(i).text;\n\n      const firstNonWhitespaceIdx = this.firstNonWhitespaceIndex(lineText);\n\n      if (firstNonWhitespaceIdx >= 0) {\n        // Compute number of spaces to separate the lines\n        let insertSpace = ' ';\n\n        if (trimmedLinesContent === '' || trimmedLinesContent.endsWith('\\t')) {\n          insertSpace = '';\n        } else if (\n          joinspaces &&\n          (trimmedLinesContent.endsWith('.') ||\n            trimmedLinesContent.endsWith('!') ||\n            trimmedLinesContent.endsWith('?'))\n        ) {\n          insertSpace = '  ';\n        } else if (\n          joinspaces &&\n          (trimmedLinesContent.endsWith('. ') ||\n            trimmedLinesContent.endsWith('! ') ||\n            trimmedLinesContent.endsWith('? '))\n        ) {\n          insertSpace = ' ';\n        } else if (trimmedLinesContent.endsWith(' ')) {\n          insertSpace = '';\n        }\n\n        const lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx);\n\n        if (lineTextWithoutIndent.charAt(0) === ')') {\n          insertSpace = '';\n        }\n\n        trimmedLinesContent += insertSpace + lineTextWithoutIndent;\n        columnDeltaOffset = lineTextWithoutIndent.length + insertSpace.length;\n      }\n    }\n\n    const deleteStartPosition = new Position(startLineNumber, startColumn);\n    const deleteEndPosition = new Position(endLineNumber, endColumn);\n\n    if (!deleteStartPosition.isEqual(deleteEndPosition)) {\n      if (startPosition.isEqual(position)) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n          diff: PositionDiff.offset({\n            character: trimmedLinesContent.length - columnDeltaOffset - position.character,\n          }),\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: trimmedLinesContent,\n          range: new vscode.Range(deleteStartPosition, deleteEndPosition),\n          manuallySetCursorPositions: true,\n        });\n\n        vimState.cursorStartPosition = vimState.cursorStopPosition = new Position(\n          startPosition.line,\n          trimmedLinesContent.length - columnDeltaOffset\n        );\n        await vimState.setCurrentMode(Mode.Normal);\n      }\n    }\n  }\n\n  public override async execCount(position: Position, vimState: VimState): Promise<void> {\n    const cursorsToIterateOver = vimState.cursors\n      .map((x) => new Cursor(x.start, x.stop))\n      .sort((a, b) =>\n        a.start.line > b.start.line ||\n        (a.start.line === b.start.line && a.start.character > b.start.character)\n          ? 1\n          : -1\n      );\n\n    const resultingCursors: Cursor[] = [];\n    for (const [idx, { start, stop }] of cursorsToIterateOver.entries()) {\n      this.multicursorIndex = idx;\n\n      vimState.cursorStopPosition = stop;\n      vimState.cursorStartPosition = start;\n\n      await this.execJoinLines(start, stop, vimState, vimState.recordedState.count || 1);\n\n      resultingCursors.push(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition));\n\n      for (const transformation of vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = this.multicursorIndex;\n        }\n      }\n    }\n\n    vimState.cursors = resultingCursors;\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.editor.selection.start, vimState.editor.selection.end);\n\n    /**\n     * For joining lines, Visual Line behaves the same as Visual so we align the register mode here.\n     */\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n\n    vimState.currentRegisterMode = RegisterMode.CharacterWise;\n    await new ActionJoin().execJoinLines(start, end, vimState, 1);\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespace extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'J'];\n  override createsUndoPoint = true;\n\n  // gJ is essentially J without the edge cases. ;-)\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === vimState.document.lineCount - 1) {\n      return; // TODO: bell\n    }\n\n    const count = vimState.recordedState.count > 2 ? vimState.recordedState.count - 1 : 1;\n    await this.execJoin(count, position, vimState);\n  }\n\n  public async execJoin(count: number, position: Position, vimState: VimState): Promise<void> {\n    const replaceRange = new vscode.Range(\n      new Position(position.line, 0),\n      new Position(Math.min(position.line + count, vimState.document.lineCount - 1), 0).getLineEnd()\n    );\n\n    const joinedText = vimState.document.getText(replaceRange).replace(/\\r?\\n/g, '');\n\n    // Put the cursor at the start of the last joined line's text\n    const newCursorColumn =\n      joinedText.length - vimState.document.lineAt(replaceRange.end).text.length;\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range: replaceRange,\n      text: joinedText,\n      diff: PositionDiff.exactCharacter({\n        character: newCursorColumn,\n      }),\n    });\n  }\n}\n\n@RegisterAction\nclass ActionJoinNoWhitespaceVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['g', 'J'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    const count = start.line === end.line ? 1 : end.line - start.line;\n    await new ActionJoinNoWhitespace().execJoin(count, start, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacter extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['r', '<character>'];\n  override createsUndoPoint = true;\n  override runsOnceForEachCountPrefix = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const toReplace = this.keysPressed[1];\n\n    /**\n     * <character> includes <BS>, <S-BS> and <TAB> but not any control keys,\n     * so we ignore the former two keys and have a special handle for <tab>.\n     */\n\n    if (['<BS>', '<S-BS>'].includes(toReplace.toUpperCase())) {\n      return;\n    }\n\n    if (position.character + timesToRepeat > position.getLineEnd().character) {\n      return;\n    }\n\n    let endPos = new Position(position.line, position.character + timesToRepeat);\n\n    // Return if tried to repeat longer than linelength\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      return;\n    }\n\n    // If last char (not EOL char), add 1 so that replace selection is complete\n    if (endPos.character > vimState.document.lineAt(endPos).text.length) {\n      endPos = new Position(endPos.line, endPos.character + 1);\n    }\n\n    if (toReplace === '<tab>') {\n      vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n      vimState.recordedState.transformer.vscodeCommand('tab');\n      vimState.recordedState.transformer.moveCursor(\n        PositionDiff.offset({ character: -1 }),\n        this.multicursorIndex\n      );\n    } else if (toReplace === '\\n') {\n      // A newline replacement always inserts exactly one newline (regardless\n      // of count prefix) and puts the cursor on the next line.\n      // We use `insertTextVSCode` so we get the right indentation\n      vimState.recordedState.transformer.delete(new vscode.Range(position, endPos));\n      vimState.recordedState.transformer.addTransformation({\n        type: 'insertTextVSCode',\n        text: '\\n',\n      });\n    } else {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: toReplace.repeat(timesToRepeat),\n        range: new vscode.Range(position, endPos),\n        diff: PositionDiff.offset({ character: timesToRepeat - 1 }),\n      });\n    }\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisual extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['r', '<character>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    let visualSelectionOffset = 1;\n\n    // If selection is reversed, reorganize it so that the text replace logic always works\n    let [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    if (vimState.currentMode === Mode.VisualLine) {\n      [start, end] = [start.getLineBegin(), end.getLineEnd()];\n    }\n\n    // Limit to not replace EOL\n    const textLength = vimState.document.lineAt(end).text.length;\n    if (textLength <= 0) {\n      visualSelectionOffset = 0;\n    }\n    end = new Position(end.line, Math.min(end.character, textLength > 0 ? textLength - 1 : 0));\n\n    // Iterate over every line in the current selection\n    for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n      // Get line of text\n      const lineText = vimState.document.lineAt(lineNum).text;\n\n      if (start.line === end.line) {\n        // This is a visual section all on one line, only replace the part within the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character - start.character + 2).join(toInsert),\n          range: new vscode.Range(start, new Position(end.line, end.character + 1)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === start.line) {\n        // This is the first line of the selection so only replace after the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length - start.character + 1).join(toInsert),\n          range: new vscode.Range(start, new Position(start.line, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      } else if (lineNum === end.line) {\n        // This is the last line of the selection so only replace before the cursor\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(end.character + 1 + visualSelectionOffset).join(toInsert),\n          range: new vscode.Range(\n            new Position(end.line, 0),\n            new Position(end.line, end.character + visualSelectionOffset)\n          ),\n          manuallySetCursorPositions: true,\n        });\n      } else {\n        // Replace the entire line length since it is in the middle of the selection\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: Array(lineText.length + 1).join(toInsert),\n          range: new vscode.Range(new Position(lineNum, 0), new Position(lineNum, lineText.length)),\n          manuallySetCursorPositions: true,\n        });\n      }\n    }\n\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionReplaceCharacterVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['r', '<character>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let toInsert = this.keysPressed[1];\n\n    if (toInsert === '<tab>') {\n      toInsert = TextEditor.getTabCharacter(vimState.editor);\n    }\n\n    for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      if (end.isBeforeOrEqual(start)) {\n        continue;\n      }\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: Array(end.character - start.character + 1).join(toInsert),\n        range: new vscode.Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionDeleteVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['d'], ['x'], ['X']];\n  override createsUndoPoint = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const lines: string[] = [];\n\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      lines.push(line);\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range: new vscode.Range(start, end),\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionShiftDVisualBlock extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['D'];\n  override createsUndoPoint = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const lines: string[] = [];\n    for (const { start } of TextEditor.iterateLinesInBlock(vimState)) {\n      const range = new vscode.Range(start, start.getLineEnd());\n      lines.push(vimState.editor.document.getText(range));\n      vimState.recordedState.transformer.addTransformation({\n        type: 'deleteRange',\n        range,\n        manuallySetCursorPositions: true,\n      });\n    }\n\n    const topLeft = visualBlockGetTopLeftPosition(\n      vimState.cursorStopPosition,\n      vimState.cursorStartPosition\n    );\n\n    const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    vimState.cursors = [new Cursor(topLeft, topLeft)];\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['I'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { line, start } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        if (line === '' && start.character !== 0) {\n          continue;\n        }\n        cursors.push(new Cursor(start, start));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionChangeInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['c'], ['s']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    const lines: string[] = [];\n    for (const cursor of vimState.cursors) {\n      const width =\n        1 +\n        visualBlockGetBottomRightPosition(cursor.start, cursor.stop).character -\n        visualBlockGetTopLeftPosition(cursor.start, cursor.stop).character;\n      for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        // TODO: is this behavior consistent with similar actions like VisualBlock `d`?\n        lines.push(line.padEnd(width, ' '));\n        if (line) {\n          vimState.recordedState.transformer.addTransformation({\n            type: 'deleteRange',\n            range: new vscode.Range(start, end),\n            manuallySetCursorPositions: true,\n          });\n          cursors.push(new Cursor(start, start));\n        }\n      }\n    }\n    vimState.cursors = cursors;\n\n    const text = lines.length === 1 ? lines[0] : lines.join('\\n');\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nclass ActionChangeToEOLInVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['C'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const cursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState, cursor)) {\n        vimState.recordedState.transformer.delete(new vscode.Range(start, start.getLineEnd()));\n        cursors.push(new Cursor(end, end));\n      }\n    }\n    vimState.cursors = cursors;\n\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\nabstract class ActionGoToInsertVisualLineModeCommand extends BaseCommand {\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  abstract getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n\n    const resultingCursors: Cursor[] = [];\n    const cursorsOnBlankLines: Cursor[] = [];\n    for (const selection of vimState.editor.selections) {\n      const { start, end } = selection;\n\n      for (let i = start.line; i <= end.line; i++) {\n        const line = vimState.document.lineAt(i);\n\n        const cursorRange = this.getCursorRangeForLine(line, start, end);\n        if (!line.isEmptyOrWhitespace) {\n          resultingCursors.push(cursorRange);\n        } else {\n          cursorsOnBlankLines.push(cursorRange);\n        }\n      }\n    }\n\n    if (resultingCursors.length > 0) {\n      vimState.cursors = resultingCursors;\n    } else {\n      vimState.cursors = cursorsOnBlankLines;\n    }\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualLineMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['I'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Cursor {\n    const startCharacterPosition = new Position(\n      line.lineNumber,\n      line.firstNonWhitespaceCharacterIndex\n    );\n    return new Cursor(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualLineModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.VisualLine];\n  keys = ['A'];\n\n  getCursorRangeForLine(line: vscode.TextLine): Cursor {\n    const endCharacterPosition = new Position(line.lineNumber, line.range.end.character);\n    return new Cursor(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualMode extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['I'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor {\n    const startCharacterPosition =\n      line.lineNumber === selectionStart.line\n        ? selectionStart\n        : new Position(line.lineNumber, line.firstNonWhitespaceCharacterIndex);\n    return new Cursor(startCharacterPosition, startCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualModeAppend extends ActionGoToInsertVisualLineModeCommand {\n  modes = [Mode.Visual];\n  keys = ['A'];\n\n  getCursorRangeForLine(\n    line: vscode.TextLine,\n    selectionStart: Position,\n    selectionEnd: Position\n  ): Cursor {\n    const endCharacterPosition =\n      line.lineNumber === selectionEnd.line\n        ? selectionEnd\n        : new Position(line.lineNumber, line.range.end.character);\n    return new Cursor(endCharacterPosition, endCharacterPosition);\n  }\n}\n\n@RegisterAction\nclass ActionGoToInsertVisualBlockModeAppend extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = ['A'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const newCursors: Cursor[] = [];\n    for (const cursor of vimState.cursors) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      for (let lineNum = start.line; lineNum <= end.line; lineNum++) {\n        const line = vimState.document.lineAt(lineNum);\n        const insertionColumn =\n          vimState.desiredColumn === Number.POSITIVE_INFINITY\n            ? line.text.length\n            : Math.max(cursor.start.character, cursor.stop.character) + 1;\n        if (line.text.length < insertionColumn) {\n          await TextEditor.insert(\n            vimState.editor,\n            ' '.repeat(insertionColumn - line.text.length),\n            line.range.end,\n            false\n          );\n        }\n        const newCursor = new Position(lineNum, insertionColumn);\n        newCursors.push(new Cursor(newCursor, newCursor));\n      }\n    }\n\n    vimState.cursors = newCursors;\n    await vimState.setCurrentMode(Mode.Insert);\n    vimState.isFakeMultiCursor = true;\n  }\n}\n\n@RegisterAction\nexport class ActionDeleteCharVisualLineMode extends BaseCommand {\n  modes = [Mode.VisualLine];\n  keys = ['x'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEnd()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionDeleteLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['X'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.DeleteOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEnd()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualModeS extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['S'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return !configuration.surround && super.doesActionApply(vimState, keysPressed);\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualMode extends BaseCommand {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = [['C'], ['R']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      start.getLineBegin(),\n      end.getLineEnd().getLeftIfEOL()\n    );\n  }\n}\n\n@RegisterAction\nclass ActionChangeLineVisualBlockMode extends BaseCommand {\n  modes = [Mode.VisualBlock];\n  keys = [['R'], ['S']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    return new ActionChangeLineVisualMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass ActionChangeChar extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['s'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new operator.ChangeOperator(this.multicursorIndex).run(\n      vimState,\n      position,\n      position.getRight((vimState.recordedState.count || 1) - 1)\n    );\n  }\n\n  // Don't clash with surround or sneak modes!\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.doesActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.couldActionApply(vimState, keysPressed) &&\n      !configuration.sneak &&\n      !vimState.recordedState.operator\n    );\n  }\n}\n\n@RegisterAction\nclass ToggleCaseAndMoveForward extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['~'];\n  override createsUndoPoint = true;\n\n  private toggleCase(text: string): string {\n    let newText = '';\n    for (const char of text) {\n      let toggled = char.toLocaleLowerCase();\n      if (toggled === char) {\n        toggled = char.toLocaleUpperCase();\n      }\n      newText += toggled;\n    }\n    return newText;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const count = vimState.recordedState.count || 1;\n    const range = new vscode.Range(\n      position,\n      shouldWrapKey(vimState.currentMode, '~')\n        ? position.getOffsetThroughLineBreaks(count)\n        : position.getRight(count)\n    );\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range,\n      text: this.toggleCase(vimState.document.getText(range)),\n      diff: PositionDiff.exactPosition(range.end),\n    });\n  }\n}\n\nabstract class IncrementDecrementNumberAction extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override createsUndoPoint = true;\n  abstract offset: number;\n  abstract staircase: boolean;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const ranges = this.getSearchRanges(vimState);\n\n    let stepNum = 1;\n\n    for (const [idx, range] of ranges.entries()) {\n      position = range.start;\n\n      const text = vimState.document.lineAt(position).text;\n\n      // Make sure position within the text is possible and return if not\n      if (text.length <= position.character) {\n        continue;\n      }\n\n      // Start looking to the right for the next word to increment, unless we're\n      // already on a word to increment, in which case start at the beginning of\n      // that word.\n      const whereToStart = text[position.character].match(/\\s/)\n        ? position\n        : position.prevWordStart(vimState.document, { inclusive: true });\n\n      wordLoop: for (let { start, end, word } of TextEditor.iterateWords(\n        vimState.document,\n        whereToStart\n      )) {\n        if (start.isAfter(range.stop)) {\n          break;\n        }\n\n        // '-' doesn't count as a word, but is important to include in parsing\n        // the number, as long as it is not just part of the word (-foo2 for example)\n        if (text[start.character - 1] === '-' && /\\d/.test(text[start.character])) {\n          start = start.getLeft();\n          word = text[start.character] + word;\n        }\n        // Strict number parsing so \"1a\" doesn't silently get converted to \"1\"\n        do {\n          const result = NumericString.parse(word);\n          if (result === undefined) {\n            break;\n          }\n          const { num, suffixOffset } = result;\n\n          // Use suffix offset to check if current cursor is in or before detected number.\n          if (position.character < start.character + suffixOffset) {\n            const pos = await this.replaceNum(\n              vimState,\n              num,\n              this.offset * stepNum * (vimState.recordedState.count || 1),\n              start,\n              end\n            );\n\n            if (this.staircase) {\n              stepNum++;\n            }\n\n            if (vimState.currentMode === Mode.Normal) {\n              vimState.recordedState.transformer.moveCursor(\n                PositionDiff.exactPosition(pos.getLeft(num.suffix.length))\n              );\n            }\n            break wordLoop;\n          } else {\n            // For situation like this: xyz1999em199[cursor]9m\n            word = word.slice(suffixOffset);\n            start = new Position(start.line, start.character + suffixOffset);\n          }\n        } while (true);\n      }\n    }\n\n    if (isVisualMode(vimState.currentMode)) {\n      vimState.recordedState.transformer.moveCursor(PositionDiff.exactPosition(ranges[0].start));\n    }\n\n    vimState.setCurrentMode(Mode.Normal);\n  }\n\n  private async replaceNum(\n    vimState: VimState,\n    start: NumericString,\n    offset: number,\n    startPos: Position,\n    endPos: Position\n  ): Promise<Position> {\n    const oldLength = endPos.character + 1 - startPos.character;\n    start.value += offset;\n    const newNum = start.toString();\n\n    const range = new vscode.Range(startPos, endPos.getRight());\n\n    vimState.recordedState.transformer.replace(range, newNum);\n    if (oldLength !== newNum.length) {\n      // Adjust end position according to difference in width of number-string\n      endPos = new Position(endPos.line, startPos.character + newNum.length - 1);\n    }\n\n    return endPos;\n  }\n\n  /**\n   * @returns a list of Ranges in which to search for numbers\n   */\n  private getSearchRanges(vimState: VimState): Cursor[] {\n    const ranges: Cursor[] = [];\n    const [start, stop] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n    switch (vimState.currentMode) {\n      case Mode.Normal: {\n        ranges.push(\n          new Cursor(vimState.cursorStopPosition, vimState.cursorStopPosition.getLineEnd())\n        );\n        break;\n      }\n\n      case Mode.Visual: {\n        ranges.push(new Cursor(start, start.getLineEnd()));\n        for (let line = start.line + 1; line < stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Cursor(lineStart, lineStart.getLineEnd()));\n        }\n        ranges.push(new Cursor(stop.getLineBegin(), stop));\n        break;\n      }\n\n      case Mode.VisualLine: {\n        for (let line = start.line; line <= stop.line; line++) {\n          const lineStart = new Position(line, 0);\n          ranges.push(new Cursor(lineStart, lineStart.getLineEnd()));\n        }\n        break;\n      }\n\n      case Mode.VisualBlock: {\n        const topLeft = visualBlockGetTopLeftPosition(start, stop);\n        const bottomRight = visualBlockGetBottomRightPosition(start, stop);\n        for (let line = topLeft.line; line <= bottomRight.line; line++) {\n          ranges.push(\n            new Cursor(\n              new Position(line, topLeft.character),\n              new Position(line, bottomRight.character)\n            )\n          );\n        }\n        break;\n      }\n\n      default:\n        throw new Error(\n          `Unexpected mode ${vimState.currentMode} in IncrementDecrementNumberAction.getPositions()`\n        );\n    }\n    return ranges;\n  }\n}\n\n@RegisterAction\nclass IncrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-a>'];\n  offset = +1;\n  staircase = false;\n}\n\n@RegisterAction\nclass DecrementNumberAction extends IncrementDecrementNumberAction {\n  keys = ['<C-x>'];\n  offset = -1;\n  staircase = false;\n}\n\n@RegisterAction\nclass IncrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-a>'];\n  offset = +1;\n  staircase = true;\n}\n\n@RegisterAction\nclass DecrementNumberStaircaseAction extends IncrementDecrementNumberAction {\n  keys = ['g', '<C-x>'];\n  offset = -1;\n  staircase = true;\n}\n\n@RegisterAction\nexport class CommandUnicodeName extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'a'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = vimState.document.getText(new vscode.Range(position, position.getRight()));\n    const charCode = char.charCodeAt(0);\n    // TODO: Handle charCode > 127 by also including <M-x>\n    StatusBar.setText(\n      vimState,\n      `<${char}>  ${charCode},  Hex ${charCode.toString(16)},  Octal ${charCode.toString(8)}`\n    );\n  }\n}\n\n@RegisterAction\nclass ActionTriggerHover extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'h'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.showHover');\n  }\n}\n\n/**\n * Multi-Cursor Command Overrides\n *\n * We currently have to override the VSCode key commands that get us into multi-cursor mode.\n *\n * Normally, we'd just listen for another cursor to be added in order to go into multi-cursor\n * mode rather than rewriting each keybinding one-by-one. We can't currently do that because\n * Visual Block Mode also creates additional cursors, but will get confused if you're in\n * multi-cursor mode.\n */\n\n@RegisterAction\nexport class ActionOverrideCmdD extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [['<D-d>'], ['g', 'b']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('editor.action.addSelectionToNextFindMatch');\n    vimState.cursors = getCursorsAfterSync(vimState.editor);\n\n    // If this is the first cursor, select 1 character less\n    // so that only the word is selected, no extra character\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n\n    await vimState.setCurrentMode(Mode.Visual);\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdDInsert extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<D-d>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Since editor.action.addSelectionToNextFindMatch uses the selection to\n    // determine where to add a word, we need to do a hack and manually set the\n    // selections to the word boundaries before we make the api call.\n    vimState.editor.selections = vimState.editor.selections.map((x, idx) => {\n      const curPos = x.active;\n      if (idx === 0) {\n        return new vscode.Selection(\n          curPos.prevWordStart(vimState.document),\n          curPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight()\n        );\n      } else {\n        // Since we're adding the selections ourselves, we need to make sure\n        // that our selection is actually over what our original word is\n        const matchWordPos = vimState.editor.selections[0].active;\n        const matchWordLength =\n          matchWordPos.getLeft().nextWordEnd(vimState.document, { inclusive: true }).getRight()\n            .character - matchWordPos.prevWordStart(vimState.document).character;\n        const wordBegin = curPos.getLeft(matchWordLength);\n        return new vscode.Selection(wordBegin, curPos);\n      }\n    });\n    vimState.recordedState.transformer.vscodeCommand('editor.action.addSelectionToNextFindMatch');\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltDown extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+down>'], // OSX\n    ['<C-alt+down>'], // Windows\n  ];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.vscodeCommand('editor.action.insertCursorBelow');\n  }\n}\n\n@RegisterAction\nclass ActionOverrideCmdAltUp extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['<D-alt+up>'], // OSX\n    ['<C-alt+up>'], // Windows\n  ];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n  override runsOnceForEachCountPrefix = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.vscodeCommand('editor.action.insertCursorAbove');\n  }\n}\n\n@RegisterAction\nclass ActionShowFileInfo extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['<C-g>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    reportFileInfo(position, vimState);\n  }\n}\n\n@RegisterAction\nclass WriteQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Z']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new WriteQuitCommand({ bang: false, opt: [] }).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass Quit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['Z', 'Q']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new QuitCommand({ bang: true }).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass ActionGoToAlternateFile extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [['<C-6>'], ['<C-^>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const altFile = await Register.get('#');\n    if (altFile?.text instanceof RecordedState) {\n      throw new Error(`# register unexpectedly contained a RecordedState`);\n    } else if (altFile === undefined || altFile.text === '') {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoAlternateFile));\n    } else {\n      let files: vscode.Uri[];\n      if (await doesFileExist(vscode.Uri.file(altFile.text))) {\n        files = [vscode.Uri.file(altFile.text)];\n      } else {\n        files = await vscode.workspace.findFiles(altFile.text);\n      }\n\n      // TODO: if the path matches a file from multiple workspace roots, we may not choose the right one\n      if (files.length > 0) {\n        const document = await vscode.workspace.openTextDocument(files[0]);\n        await vscode.window.showTextDocument(document);\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass ShowFileOutline extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = ['g', 'O'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('outline.focus');\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { RegisterAction, BaseCommand } from '../base';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { CommandLine, ExCommandLine, SearchCommandLine } from '../../cmd_line/commandLine';\nimport { Register, RegisterMode } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { TextEditor } from '../../textEditor';\nimport { StatusBar } from '../../statusBar';\nimport { getPathDetails, readDirectory } from '../../util/path';\nimport { Clipboard } from '../../util/clipboard';\nimport { VimError, ErrorCode } from '../../error';\nimport { builtinExCommands } from '../../vimscript/exCommandParser';\nimport { SearchDirection } from '../../vimscript/pattern';\n\nabstract class CommandLineAction extends BaseCommand {\n  modes = [Mode.CommandlineInProgress, Mode.SearchInProgressMode];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  protected abstract run(vimState: VimState, commandLine: CommandLine): Promise<void>;\n\n  public override async exec(position: vscode.Position, vimState: VimState): Promise<void> {\n    if (\n      !(\n        vimState.modeData.mode === Mode.CommandlineInProgress ||\n        vimState.modeData.mode === Mode.SearchInProgressMode\n      )\n    ) {\n      throw new Error(`Unexpected mode ${vimState.modeData.mode} in CommandLineAction`);\n    }\n\n    await this.run(vimState, vimState.modeData.commandLine);\n  }\n}\n\n@RegisterAction\nclass CommandLineTab extends CommandLineAction {\n  override modes = [Mode.CommandlineInProgress];\n  keys = [['<tab>'], ['<S-tab>']];\n\n  private cycleCompletion(isTabForward: boolean, commandLine: ExCommandLine) {\n    const autoCompleteItems = commandLine.autoCompleteItems;\n    if (autoCompleteItems.length === 0) {\n      return;\n    }\n\n    commandLine.autoCompleteIndex = isTabForward\n      ? (commandLine.autoCompleteIndex + 1) % autoCompleteItems.length\n      : (commandLine.autoCompleteIndex - 1 + autoCompleteItems.length) % autoCompleteItems.length;\n\n    const lastPos = commandLine.preCompleteCharacterPos;\n    const lastCmd = commandLine.preCompleteCommand;\n    const evalCmd = lastCmd.slice(0, lastPos);\n    const restCmd = lastCmd.slice(lastPos);\n\n    commandLine.text = evalCmd + autoCompleteItems[commandLine.autoCompleteIndex] + restCmd;\n    commandLine.cursorIndex = commandLine.text.length - restCmd.length;\n  }\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    if (!(commandLine instanceof ExCommandLine)) {\n      throw new Error('Expected ExCommandLine in CommandLineTab::run()');\n    }\n\n    const key = this.keysPressed[0];\n    const isTabForward = key === '<tab>';\n\n    // If we hit <Tab> twice in a row, definitely cycle\n    if (\n      commandLine.autoCompleteItems.length !== 0 &&\n      vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2] instanceof\n        CommandLineTab\n    ) {\n      this.cycleCompletion(isTabForward, commandLine);\n      return;\n    }\n\n    let newCompletionItems: string[] = [];\n\n    // Sub string since vim does completion before the cursor\n    let evalCmd = commandLine.text.slice(0, commandLine.cursorIndex);\n    const restCmd = commandLine.text.slice(commandLine.cursorIndex);\n\n    // \\s* is the match the extra space before any character like ':  edit'\n    const cmdRegex = /^\\s*\\w+$/;\n    const fileRegex = /^\\s*\\w+\\s+/g;\n    if (cmdRegex.test(evalCmd)) {\n      // Command completion\n      newCompletionItems = builtinExCommands\n        .map((pair) => pair[0][0] + pair[0][1])\n        .filter((cmd) => cmd.startsWith(evalCmd))\n        // Remove the already typed portion in the array\n        .map((cmd) => cmd.slice(cmd.search(evalCmd) + evalCmd.length))\n        .sort();\n    } else if (fileRegex.exec(evalCmd)) {\n      // File completion by searching if there is a space after the first word/command\n      // ideally it should be a process of white-listing to selected commands like :e and :vsp\n      const filePathInCmd = evalCmd.substring(fileRegex.lastIndex);\n      const currentUri = vimState.document.uri;\n      const isRemote = !!vscode.env.remoteName;\n\n      const {\n        fullDirPath,\n        baseName,\n        partialPath,\n        path: p,\n      } = getPathDetails(filePathInCmd, currentUri, isRemote);\n      // Update the evalCmd in case of windows, where we change / to \\\n      evalCmd = evalCmd.slice(0, fileRegex.lastIndex) + partialPath;\n\n      // test if the baseName is . or ..\n      const shouldAddDotItems = /^\\.\\.?$/g.test(baseName);\n      const dirItems = await readDirectory(\n        fullDirPath,\n        p.sep,\n        currentUri,\n        isRemote,\n        shouldAddDotItems\n      );\n      const startWithBaseNameRegex = new RegExp(\n        `^${baseName}`,\n        process.platform === 'win32' ? 'i' : ''\n      );\n      newCompletionItems = dirItems\n        .map((name): [RegExpExecArray | null, string] => [startWithBaseNameRegex.exec(name), name])\n        .filter(([isMatch]) => isMatch !== null)\n        .map(([match, name]) => name.slice(match![0].length))\n        .sort();\n    }\n\n    const newIndex = isTabForward ? 0 : newCompletionItems.length - 1;\n    commandLine.autoCompleteIndex = newIndex;\n    // If here only one items we fill cmd direct, so the next tab will not cycle the one item array\n    commandLine.autoCompleteItems = newCompletionItems.length <= 1 ? [] : newCompletionItems;\n    commandLine.preCompleteCharacterPos = commandLine.cursorIndex;\n    commandLine.preCompleteCommand = evalCmd + restCmd;\n\n    const completion = newCompletionItems.length === 0 ? '' : newCompletionItems[newIndex];\n    commandLine.text = evalCmd + completion + restCmd;\n    commandLine.cursorIndex = commandLine.text.length - restCmd.length;\n  }\n}\n\n@RegisterAction\nclass ExCommandLineEnter extends CommandLineAction {\n  override modes = [Mode.CommandlineInProgress];\n  keys = [['\\n'], ['<C-m>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.run(vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass SearchCommandLineEnter extends CommandLineAction {\n  override modes = [Mode.SearchInProgressMode];\n  keys = [['\\n'], ['<C-m>']];\n\n  override runsOnceForEveryCursor() {\n    return true;\n  }\n  override isJump = true;\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.run(vimState);\n    if (this.multicursorIndex === vimState.cursors.length - 1) {\n      // TODO: gah, this is stupid\n      await vimState.setCurrentMode(commandLine.previousMode);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandLineEscape extends CommandLineAction {\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.escape(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandLineBackspace extends CommandLineAction {\n  keys = [['<BS>'], ['<S-BS>'], ['<C-h>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.backspace(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandLineDelete extends CommandLineAction {\n  keys = ['<Del>'];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.delete(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandlineHome extends CommandLineAction {\n  keys = [['<Home>'], ['<C-b>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.home();\n  }\n}\n\n@RegisterAction\nclass CommandLineEnd extends CommandLineAction {\n  keys = [['<End>'], ['<C-e>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.end();\n  }\n}\n\n@RegisterAction\nclass CommandLineDeleteWord extends CommandLineAction {\n  keys = [['<C-w>'], ['<C-BS>']];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.deleteWord();\n  }\n}\n\n@RegisterAction\nclass CommandLineDeleteToBeginning extends CommandLineAction {\n  keys = ['<C-u>'];\n\n  protected override async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.deleteToBeginning();\n  }\n}\n\n@RegisterAction\nclass CommandLineWordLeft extends CommandLineAction {\n  keys = ['<C-left>'];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.wordLeft();\n  }\n}\n\n@RegisterAction\nclass CommandLineWordRight extends CommandLineAction {\n  keys = ['<C-right>'];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.wordRight();\n  }\n}\n\n@RegisterAction\nclass CommandLineHistoryBack extends CommandLineAction {\n  keys = [['<up>'], ['<C-p>']];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.historyBack();\n  }\n}\n\n@RegisterAction\nclass CommandLineHistoryForward extends CommandLineAction {\n  keys = [['<down>'], ['<C-n>']];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    await commandLine.historyForward();\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContentInCommandLine extends CommandLineAction {\n  keys = ['<C-r>', '<character>'];\n  override isCompleteAction = false;\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    if (!Register.isValidRegister(this.keysPressed[1])) {\n      return;\n    }\n\n    vimState.recordedState.registerName = this.keysPressed[1];\n    const register = await Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, vimState.recordedState.registerName)\n      );\n      return;\n    }\n\n    let text: string;\n    if (register.text instanceof Array) {\n      text = register.text.join('\\n');\n    } else if (register.text instanceof RecordedState) {\n      let keyStrokes: string[] = [];\n\n      for (const action of register.text.actionsRun) {\n        keyStrokes = keyStrokes.concat(action.keysPressed);\n      }\n\n      text = keyStrokes.join('\\n');\n    } else {\n      text = register.text;\n    }\n\n    if (register.registerMode === RegisterMode.LineWise) {\n      text += '\\n';\n    }\n\n    commandLine.text += text;\n    commandLine.cursorIndex += text.length;\n  }\n}\n\n@RegisterAction\nclass CommandInsertWord extends CommandLineAction {\n  keys = ['<C-r>', '<C-w>'];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    const word = TextEditor.getWord(vimState.document, vimState.cursorStopPosition.getLeftIfEOL());\n\n    if (word !== undefined) {\n      commandLine.text += word;\n      commandLine.cursorIndex += word.length;\n    }\n  }\n}\n\n@RegisterAction\nclass CommandLineLeftRight extends CommandLineAction {\n  keys = [['<left>'], ['<right>']];\n\n  private getTrimmedStatusBarText() {\n    // first regex removes the : / and | from the string\n    // second regex removes a single space from the end of the string\n    const trimmedStatusBarText = StatusBar.getText()\n      .replace(/^(?:\\/|\\:)(.*)(?:\\|)(.*)/, '$1$2')\n      .replace(/(.*) $/, '$1');\n    return trimmedStatusBarText;\n  }\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    const key = this.keysPressed[0];\n    const statusBarText = this.getTrimmedStatusBarText();\n    if (key === '<right>') {\n      commandLine.cursorIndex = Math.min(commandLine.cursorIndex + 1, statusBarText.length);\n    } else if (key === '<left>') {\n      commandLine.cursorIndex = Math.max(commandLine.cursorIndex - 1, 0);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandLinePaste extends CommandLineAction {\n  keys = [['<C-v>'], ['<D-v>']];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    const textFromClipboard = await Clipboard.Paste();\n\n    commandLine.text = commandLine.text\n      .substring(0, commandLine.cursorIndex)\n      .concat(textFromClipboard)\n      .concat(commandLine.text.slice(commandLine.cursorIndex));\n    commandLine.cursorIndex += textFromClipboard.length;\n  }\n}\n\n@RegisterAction\nclass CommandCtrlLInSearchMode extends CommandLineAction {\n  override modes = [Mode.SearchInProgressMode];\n  keys = ['<C-l>'];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    if (commandLine instanceof SearchCommandLine) {\n      const currentMatch = commandLine.getCurrentMatchRange(vimState);\n      if (currentMatch) {\n        const line = vimState.document.lineAt(currentMatch.range.end).text;\n        if (currentMatch.range.end.character < line.length) {\n          commandLine.getSearchState().searchString += line[currentMatch.range.end.character];\n          commandLine.cursorIndex++;\n        }\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass CommandAdvanceCurrentMatch extends CommandLineAction {\n  override modes = [Mode.SearchInProgressMode];\n  keys = [['<C-g>'], ['<C-t>']];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    const key = this.keysPressed[0];\n    const direction =\n      key === '<C-g>'\n        ? SearchDirection.Forward\n        : key === '<C-t>'\n        ? SearchDirection.Backward\n        : undefined;\n    if (commandLine instanceof SearchCommandLine && direction !== undefined) {\n      commandLine.advanceCurrentMatch(vimState, direction);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandLineType extends CommandLineAction {\n  keys = [['<character>']];\n\n  protected async run(vimState: VimState, commandLine: CommandLine): Promise<void> {\n    commandLine.typeCharacter(this.keysPressed[0]);\n  }\n}\n","// prettier-ignore\nexport const DefaultDigraphs = {\n  \"SH\": [\"^A\", 1],\n  \"SX\": [\"^B\", 2],\n  \"EX\": [\"^C\", 3],\n  \"ET\": [\"^D\", 4],\n  \"EQ\": [\"^E\", 5],\n  \"AK\": [\"^F\", 6],\n  \"BL\": [\"^G\", 7],\n  \"BS\": [\"^H\", 8],\n  \"HT\": [\"^I\", 9],\n  \"LF\": [\"^@\", 10],\n  \"NU\": [\"^@\", 10],\n  \"VT\": [\"^K\", 11],\n  \"FF\": [\"^L\", 12],\n  \"CR\": [\"^M\", 13],\n  \"SO\": [\"^N\", 14],\n  \"SI\": [\"^O\", 15],\n  \"DL\": [\"^P\", 16],\n  \"D1\": [\"^Q\", 17],\n  \"D2\": [\"^R\", 18],\n  \"D3\": [\"^S\", 19],\n  \"D4\": [\"^T\", 20],\n  \"NK\": [\"^U\", 21],\n  \"SY\": [\"^V\", 22],\n  \"EB\": [\"^W\", 23],\n  \"CN\": [\"^X\", 24],\n  \"EM\": [\"^Y\", 25],\n  \"SB\": [\"^Z\", 26],\n  \"EC\": [\"^[\", 27],\n  \"FS\": [\"^\\\\\", 28],\n  \"GS\": [\"^]\", 29],\n  \"RS\": [\"^^\", 30],\n  \"US\": [\"^_\", 31],\n  \"SP\": [\" \", 32],\n  \"Nb\": [\"#\", 35],\n  \"DO\": [\"$\", 36],\n  \"At\": [\"@\", 64],\n  \"<(\": [\"[\", 91],\n  \"//\": [\"\\\\\", 92],\n  \")>\": [\"]\", 93],\n  \"'>\": [\"^\", 94],\n  \"'!\": [\"`\", 96],\n  \"(!\": [\"{\", 123],\n  \"!!\": [\"|\", 124],\n  \"!)\": [\"}\", 125],\n  \"'?\": [\"~\", 126],\n  \"DT\": [\"^?\", 127],\n  \"PA\": [\"<80>\", 128],\n  \"HO\": [\"<81>\", 129],\n  \"BH\": [\"<82>\", 130],\n  \"NH\": [\"<83>\", 131],\n  \"IN\": [\"<84>\", 132],\n  \"NL\": [\"<85>\", 133],\n  \"SA\": [\"<86>\", 134],\n  \"ES\": [\"<87>\", 135],\n  \"HS\": [\"<88>\", 136],\n  \"HJ\": [\"<89>\", 137],\n  \"VS\": [\"<8a>\", 138],\n  \"PD\": [\"<8b>\", 139],\n  \"PU\": [\"<8c>\", 140],\n  \"RI\": [\"<8d>\", 141],\n  \"S2\": [\"<8e>\", 142],\n  \"S3\": [\"<8f>\", 143],\n  \"DC\": [\"<90>\", 144],\n  \"P1\": [\"<91>\", 145],\n  \"P2\": [\"<92>\", 146],\n  \"TS\": [\"<93>\", 147],\n  \"CC\": [\"<94>\", 148],\n  \"MW\": [\"<95>\", 149],\n  \"SG\": [\"<96>\", 150],\n  \"EG\": [\"<97>\", 151],\n  \"SS\": [\"<98>\", 152],\n  \"GC\": [\"<99>\", 153],\n  \"SC\": [\"<9a>\", 154],\n  \"CI\": [\"<9b>\", 155],\n  \"ST\": [\"<9c>\", 156],\n  \"OC\": [\"<9d>\", 157],\n  \"PM\": [\"<9e>\", 158],\n  \"AC\": [\"<9f>\", 159],\n  \"NS\": [\"\", 160],\n  \"~!\": [\"\", 161],\n  \"!I\": [\"\", 161],\n  \"Ct\": [\"\", 162],\n  \"c|\": [\"\", 162],\n  \"Pd\": [\"\", 163],\n  \"$$\": [\"\", 163],\n  \"Cu\": [\"\", 164],\n  \"ox\": [\"\", 164],\n  \"Ye\": [\"\", 165],\n  \"Y-\": [\"\", 165],\n  \"BB\": [\"\", 166],\n  \"||\": [\"\", 166],\n  \"SE\": [\"\", 167],\n  \"':\": [\"\", 168],\n  \"Co\": [\"\", 169],\n  \"cO\": [\"\", 169],\n  \"-a\": [\"\", 170],\n  \"<<\": [\"\", 171],\n  \"NO\": [\"\", 172],\n  \"-,\": [\"\", 172],\n  \"--\": [\"\", 173],\n  \"Rg\": [\"\", 174],\n  \"'m\": [\"\", 175],\n  \"-=\": [\"\", 175],\n  \"DG\": [\"\", 176],\n  \"~o\": [\"\", 176],\n  \"+-\": [\"\", 177],\n  \"2S\": [\"\", 178],\n  \"22\": [\"\", 178],\n  \"3S\": [\"\", 179],\n  \"33\": [\"\", 179],\n  \"''\": [\"\", 180],\n  \"My\": [\"\", 181],\n  \"PI\": [\"\", 182],\n  \"pp\": [\"\", 182],\n  \".M\": [\"\", 183],\n  \"~.\": [\"\", 183],\n  \"',\": [\"\", 184],\n  \"1S\": [\"\", 185],\n  \"11\": [\"\", 185],\n  \"-o\": [\"\", 186],\n  \">>\": [\"\", 187],\n  \"14\": [\"\", 188],\n  \"12\": [\"\", 189],\n  \"34\": [\"\", 190],\n  \"?I\": [\"\", 191],\n  \"~?\": [\"\", 191],\n  \"A!\": [\"\", 192],\n  \"A`\": [\"\", 192],\n  \"A'\": [\"\", 193],\n  \"A>\": [\"\", 194],\n  \"A^\": [\"\", 194],\n  \"A?\": [\"\", 195],\n  \"A~\": [\"\", 195],\n  \"A:\": [\"\", 196],\n  \"A\\\"\": [\"\", 196],\n  \"AA\": [\"\", 197],\n  \"A@\": [\"\", 197],\n  \"AE\": [\"\", 198],\n  \"C,\": [\"\", 199],\n  \"E!\": [\"\", 200],\n  \"E`\": [\"\", 200],\n  \"E'\": [\"\", 201],\n  \"E>\": [\"\", 202],\n  \"E^\": [\"\", 202],\n  \"E:\": [\"\", 203],\n  \"E\\\"\": [\"\", 203],\n  \"I!\": [\"\", 204],\n  \"I`\": [\"\", 204],\n  \"I'\": [\"\", 205],\n  \"I>\": [\"\", 206],\n  \"I^\": [\"\", 206],\n  \"I:\": [\"\", 207],\n  \"I\\\"\": [\"\", 207],\n  \"D-\": [\"\", 208],\n  \"N?\": [\"\", 209],\n  \"N~\": [\"\", 209],\n  \"O!\": [\"\", 210],\n  \"O`\": [\"\", 210],\n  \"O'\": [\"\", 211],\n  \"O>\": [\"\", 212],\n  \"O^\": [\"\", 212],\n  \"O?\": [\"\", 213],\n  \"O~\": [\"\", 213],\n  \"O:\": [\"\", 214],\n  \"*X\": [\"\", 215],\n  \"/\\\\\": [\"\", 215],\n  \"O/\": [\"\", 216],\n  \"U!\": [\"\", 217],\n  \"U`\": [\"\", 217],\n  \"U'\": [\"\", 218],\n  \"U>\": [\"\", 219],\n  \"U^\": [\"\", 219],\n  \"U:\": [\"\", 220],\n  \"Y'\": [\"\", 221],\n  \"TH\": [\"\", 222],\n  \"Ip\": [\"\", 222],\n  \"ss\": [\"\", 223],\n  \"a!\": [\"\", 224],\n  \"a`\": [\"\", 224],\n  \"a'\": [\"\", 225],\n  \"a>\": [\"\", 226],\n  \"a^\": [\"\", 226],\n  \"a?\": [\"\", 227],\n  \"a~\": [\"\", 227],\n  \"a:\": [\"\", 228],\n  \"a\\\"\": [\"\", 228],\n  \"aa\": [\"\", 229],\n  \"a@\": [\"\", 229],\n  \"ae\": [\"\", 230],\n  \"c,\": [\"\", 231],\n  \"e!\": [\"\", 232],\n  \"e`\": [\"\", 232],\n  \"e'\": [\"\", 233],\n  \"e>\": [\"\", 234],\n  \"e^\": [\"\", 234],\n  \"e:\": [\"\", 235],\n  \"e\\\"\": [\"\", 235],\n  \"i!\": [\"\", 236],\n  \"i`\": [\"\", 236],\n  \"i'\": [\"\", 237],\n  \"i>\": [\"\", 238],\n  \"i^\": [\"\", 238],\n  \"i:\": [\"\", 239],\n  \"d-\": [\"\", 240],\n  \"n?\": [\"\", 241],\n  \"n~\": [\"\", 241],\n  \"o!\": [\"\", 242],\n  \"o`\": [\"\", 242],\n  \"o'\": [\"\", 243],\n  \"o>\": [\"\", 244],\n  \"o^\": [\"\", 244],\n  \"o?\": [\"\", 245],\n  \"o~\": [\"\", 245],\n  \"o:\": [\"\", 246],\n  \"-:\": [\"\", 247],\n  \"o/\": [\"\", 248],\n  \"u!\": [\"\", 249],\n  \"u`\": [\"\", 249],\n  \"u'\": [\"\", 250],\n  \"u>\": [\"\", 251],\n  \"u^\": [\"\", 251],\n  \"u:\": [\"\", 252],\n  \"y'\": [\"\", 253],\n  \"th\": [\"\", 254],\n  \"y:\": [\"\", 255],\n  \"y\\\"\": [\"\", 255],\n  \"A-\": [\"\", 256],\n  \"a-\": [\"\", 257],\n  \"A(\": [\"\", 258],\n  \"a(\": [\"\", 259],\n  \"A;\": [\"\", 260],\n  \"a;\": [\"\", 261],\n  \"C'\": [\"\", 262],\n  \"c'\": [\"\", 263],\n  \"C>\": [\"\", 264],\n  \"c>\": [\"\", 265],\n  \"C.\": [\"\", 266],\n  \"c.\": [\"\", 267],\n  \"C<\": [\"\", 268],\n  \"c<\": [\"\", 269],\n  \"D<\": [\"\", 270],\n  \"d<\": [\"\", 271],\n  \"D/\": [\"\", 272],\n  \"d/\": [\"\", 273],\n  \"E-\": [\"\", 274],\n  \"e-\": [\"\", 275],\n  \"E(\": [\"\", 276],\n  \"e(\": [\"\", 277],\n  \"E.\": [\"\", 278],\n  \"e.\": [\"\", 279],\n  \"E;\": [\"\", 280],\n  \"e;\": [\"\", 281],\n  \"E<\": [\"\", 282],\n  \"e<\": [\"\", 283],\n  \"G>\": [\"\", 284],\n  \"g>\": [\"\", 285],\n  \"G(\": [\"\", 286],\n  \"g(\": [\"\", 287],\n  \"G.\": [\"\", 288],\n  \"g.\": [\"\", 289],\n  \"G,\": [\"\", 290],\n  \"g,\": [\"\", 291],\n  \"H>\": [\"\", 292],\n  \"h>\": [\"\", 293],\n  \"H/\": [\"\", 294],\n  \"h/\": [\"\", 295],\n  \"I?\": [\"\", 296],\n  \"i?\": [\"\", 297],\n  \"I-\": [\"\", 298],\n  \"i-\": [\"\", 299],\n  \"I(\": [\"\", 300],\n  \"i(\": [\"\", 301],\n  \"I;\": [\"\", 302],\n  \"i;\": [\"\", 303],\n  \"I.\": [\"\", 304],\n  \"i.\": [\"\", 305],\n  \"IJ\": [\"\", 306],\n  \"ij\": [\"\", 307],\n  \"J>\": [\"\", 308],\n  \"j>\": [\"\", 309],\n  \"K,\": [\"\", 310],\n  \"k,\": [\"\", 311],\n  \"kk\": [\"\", 312],\n  \"L'\": [\"\", 313],\n  \"l'\": [\"\", 314],\n  \"L,\": [\"\", 315],\n  \"l,\": [\"\", 316],\n  \"L<\": [\"\", 317],\n  \"l<\": [\"\", 318],\n  \"L.\": [\"\", 319],\n  \"l.\": [\"\", 320],\n  \"L/\": [\"\", 321],\n  \"l/\": [\"\", 322],\n  \"N'\": [\"\", 323],\n  \"n'\": [\"\", 324],\n  \"N,\": [\"\", 325],\n  \"n,\": [\"\", 326],\n  \"N<\": [\"\", 327],\n  \"n<\": [\"\", 328],\n  \"'n\": [\"\", 329],\n  \"NG\": [\"\", 330],\n  \"ng\": [\"\", 331],\n  \"O-\": [\"\", 332],\n  \"o-\": [\"\", 333],\n  \"O(\": [\"\", 334],\n  \"o(\": [\"\", 335],\n  \"O\\\"\": [\"\", 336],\n  \"o\\\"\": [\"\", 337],\n  \"OE\": [\"\", 338],\n  \"oe\": [\"\", 339],\n  \"R'\": [\"\", 340],\n  \"r'\": [\"\", 341],\n  \"R,\": [\"\", 342],\n  \"r,\": [\"\", 343],\n  \"R<\": [\"\", 344],\n  \"r<\": [\"\", 345],\n  \"S'\": [\"\", 346],\n  \"s'\": [\"\", 347],\n  \"S>\": [\"\", 348],\n  \"s>\": [\"\", 349],\n  \"S,\": [\"\", 350],\n  \"s,\": [\"\", 351],\n  \"S<\": [\"\", 352],\n  \"s<\": [\"\", 353],\n  \"T,\": [\"\", 354],\n  \"t,\": [\"\", 355],\n  \"T<\": [\"\", 356],\n  \"t<\": [\"\", 357],\n  \"T/\": [\"\", 358],\n  \"t/\": [\"\", 359],\n  \"U?\": [\"\", 360],\n  \"u?\": [\"\", 361],\n  \"U-\": [\"\", 362],\n  \"u-\": [\"\", 363],\n  \"U(\": [\"\", 364],\n  \"u(\": [\"\", 365],\n  \"U0\": [\"\", 366],\n  \"u0\": [\"\", 367],\n  \"U\\\"\": [\"\", 368],\n  \"u\\\"\": [\"\", 369],\n  \"U;\": [\"\", 370],\n  \"u;\": [\"\", 371],\n  \"W>\": [\"\", 372],\n  \"w>\": [\"\", 373],\n  \"Y>\": [\"\", 374],\n  \"y>\": [\"\", 375],\n  \"Y:\": [\"\", 376],\n  \"Z'\": [\"\", 377],\n  \"z'\": [\"\", 378],\n  \"Z.\": [\"\", 379],\n  \"z.\": [\"\", 380],\n  \"Z<\": [\"\", 381],\n  \"z<\": [\"\", 382],\n  \"fs\": [\"\", 383],\n  \"O9\": [\"\", 416],\n  \"o9\": [\"\", 417],\n  \"OI\": [\"\", 418],\n  \"oi\": [\"\", 419],\n  \"yr\": [\"\", 422],\n  \"U9\": [\"\", 431],\n  \"u9\": [\"\", 432],\n  \"Z/\": [\"\", 437],\n  \"z/\": [\"\", 438],\n  \"ED\": [\"\", 439],\n  \"A<\": [\"\", 461],\n  \"a<\": [\"\", 462],\n  \"I<\": [\"\", 463],\n  \"i<\": [\"\", 464],\n  \"O<\": [\"\", 465],\n  \"o<\": [\"\", 466],\n  \"U<\": [\"\", 467],\n  \"u<\": [\"\", 468],\n  \"A1\": [\"\", 478],\n  \"a1\": [\"\", 479],\n  \"A7\": [\"\", 480],\n  \"a7\": [\"\", 481],\n  \"A3\": [\"\", 482],\n  \"a3\": [\"\", 483],\n  \"G/\": [\"\", 484],\n  \"g/\": [\"\", 485],\n  \"G<\": [\"\", 486],\n  \"g<\": [\"\", 487],\n  \"K<\": [\"\", 488],\n  \"k<\": [\"\", 489],\n  \"O;\": [\"\", 490],\n  \"o;\": [\"\", 491],\n  \"O1\": [\"\", 492],\n  \"o1\": [\"\", 493],\n  \"EZ\": [\"\", 494],\n  \"ez\": [\"\", 495],\n  \"j<\": [\"\", 496],\n  \"G'\": [\"\", 500],\n  \"g'\": [\"\", 501],\n  \";S\": [\"\", 703],\n  \"'<\": [\"\", 711],\n  \"'(\": [\"\", 728],\n  \"'.\": [\"\", 729],\n  \"'0\": [\"\", 730],\n  \"';\": [\"\", 731],\n  \"'\\\"\": [\"\", 733],\n  \"A%\": [\"\", 902],\n  \"E%\": [\"\", 904],\n  \"Y%\": [\"\", 905],\n  \"I%\": [\"\", 906],\n  \"O%\": [\"\", 908],\n  \"U%\": [\"\", 910],\n  \"W%\": [\"\", 911],\n  \"i3\": [\"\", 912],\n  \"A*\": [\"\", 913],\n  \"B*\": [\"\", 914],\n  \"G*\": [\"\", 915],\n  \"D*\": [\"\", 916],\n  \"E*\": [\"\", 917],\n  \"Z*\": [\"\", 918],\n  \"Y*\": [\"\", 919],\n  \"H*\": [\"\", 920],\n  \"I*\": [\"\", 921],\n  \"K*\": [\"\", 922],\n  \"L*\": [\"\", 923],\n  \"M*\": [\"\", 924],\n  \"N*\": [\"\", 925],\n  \"C*\": [\"\", 926],\n  \"O*\": [\"\", 927],\n  \"P*\": [\"\", 928],\n  \"R*\": [\"\", 929],\n  \"S*\": [\"\", 931],\n  \"T*\": [\"\", 932],\n  \"U*\": [\"\", 933],\n  \"F*\": [\"\", 934],\n  \"X*\": [\"\", 935],\n  \"Q*\": [\"\", 936],\n  \"W*\": [\"\", 937],\n  \"J*\": [\"\", 938],\n  \"V*\": [\"\", 939],\n  \"a%\": [\"\", 940],\n  \"e%\": [\"\", 941],\n  \"y%\": [\"\", 942],\n  \"i%\": [\"\", 943],\n  \"u3\": [\"\", 944],\n  \"a*\": [\"\", 945],\n  \"b*\": [\"\", 946],\n  \"g*\": [\"\", 947],\n  \"d*\": [\"\", 948],\n  \"e*\": [\"\", 949],\n  \"z*\": [\"\", 950],\n  \"y*\": [\"\", 951],\n  \"h*\": [\"\", 952],\n  \"i*\": [\"\", 953],\n  \"k*\": [\"\", 954],\n  \"l*\": [\"\", 955],\n  \"m*\": [\"\", 956],\n  \"n*\": [\"\", 957],\n  \"c*\": [\"\", 958],\n  \"o*\": [\"\", 959],\n  \"p*\": [\"\", 960],\n  \"r*\": [\"\", 961],\n  \"*s\": [\"\", 962],\n  \"s*\": [\"\", 963],\n  \"t*\": [\"\", 964],\n  \"u*\": [\"\", 965],\n  \"f*\": [\"\", 966],\n  \"x*\": [\"\", 967],\n  \"q*\": [\"\", 968],\n  \"w*\": [\"\", 969],\n  \"j*\": [\"\", 970],\n  \"v*\": [\"\", 971],\n  \"o%\": [\"\", 972],\n  \"u%\": [\"\", 973],\n  \"w%\": [\"\", 974],\n  \"'G\": [\"\", 984],\n  \",G\": [\"\", 985],\n  \"T3\": [\"\", 986],\n  \"t3\": [\"\", 987],\n  \"M3\": [\"\", 988],\n  \"m3\": [\"\", 989],\n  \"K3\": [\"\", 990],\n  \"k3\": [\"\", 991],\n  \"P3\": [\"\", 992],\n  \"p3\": [\"\", 993],\n  \"'%\": [\"\", 1012],\n  \"j3\": [\"\", 1013],\n  \"IO\": [\"\", 1025],\n  \"D%\": [\"\", 1026],\n  \"G%\": [\"\", 1027],\n  \"IE\": [\"\", 1028],\n  \"DS\": [\"\", 1029],\n  \"II\": [\"\", 1030],\n  \"YI\": [\"\", 1031],\n  \"J%\": [\"\", 1032],\n  \"LJ\": [\"\", 1033],\n  \"NJ\": [\"\", 1034],\n  \"Ts\": [\"\", 1035],\n  \"KJ\": [\"\", 1036],\n  \"V%\": [\"\", 1038],\n  \"DZ\": [\"\", 1039],\n  \"A=\": [\"\", 1040],\n  \"B=\": [\"\", 1041],\n  \"V=\": [\"\", 1042],\n  \"G=\": [\"\", 1043],\n  \"D=\": [\"\", 1044],\n  \"E=\": [\"\", 1045],\n  \"Z%\": [\"\", 1046],\n  \"Z=\": [\"\", 1047],\n  \"I=\": [\"\", 1048],\n  \"J=\": [\"\", 1049],\n  \"K=\": [\"\", 1050],\n  \"L=\": [\"\", 1051],\n  \"M=\": [\"\", 1052],\n  \"N=\": [\"\", 1053],\n  \"O=\": [\"\", 1054],\n  \"P=\": [\"\", 1055],\n  \"R=\": [\"\", 1056],\n  \"S=\": [\"\", 1057],\n  \"T=\": [\"\", 1058],\n  \"U=\": [\"\", 1059],\n  \"F=\": [\"\", 1060],\n  \"H=\": [\"\", 1061],\n  \"C=\": [\"\", 1062],\n  \"C%\": [\"\", 1063],\n  \"S%\": [\"\", 1064],\n  \"Sc\": [\"\", 1065],\n  \"=\\\"\": [\"\", 1066],\n  \"Y=\": [\"\", 1067],\n  \"%\\\"\": [\"\", 1068],\n  \"JE\": [\"\", 1069],\n  \"JU\": [\"\", 1070],\n  \"JA\": [\"\", 1071],\n  \"a=\": [\"\", 1072],\n  \"b=\": [\"\", 1073],\n  \"v=\": [\"\", 1074],\n  \"g=\": [\"\", 1075],\n  \"d=\": [\"\", 1076],\n  \"e=\": [\"\", 1077],\n  \"z%\": [\"\", 1078],\n  \"z=\": [\"\", 1079],\n  \"i=\": [\"\", 1080],\n  \"j=\": [\"\", 1081],\n  \"k=\": [\"\", 1082],\n  \"l=\": [\"\", 1083],\n  \"m=\": [\"\", 1084],\n  \"n=\": [\"\", 1085],\n  \"o=\": [\"\", 1086],\n  \"p=\": [\"\", 1087],\n  \"r=\": [\"\", 1088],\n  \"s=\": [\"\", 1089],\n  \"t=\": [\"\", 1090],\n  \"u=\": [\"\", 1091],\n  \"f=\": [\"\", 1092],\n  \"h=\": [\"\", 1093],\n  \"c=\": [\"\", 1094],\n  \"c%\": [\"\", 1095],\n  \"s%\": [\"\", 1096],\n  \"sc\": [\"\", 1097],\n  \"='\": [\"\", 1098],\n  \"y=\": [\"\", 1099],\n  \"%'\": [\"\", 1100],\n  \"je\": [\"\", 1101],\n  \"ju\": [\"\", 1102],\n  \"ja\": [\"\", 1103],\n  \"io\": [\"\", 1105],\n  \"d%\": [\"\", 1106],\n  \"g%\": [\"\", 1107],\n  \"ie\": [\"\", 1108],\n  \"ds\": [\"\", 1109],\n  \"ii\": [\"\", 1110],\n  \"yi\": [\"\", 1111],\n  \"j%\": [\"\", 1112],\n  \"lj\": [\"\", 1113],\n  \"nj\": [\"\", 1114],\n  \"ts\": [\"\", 1115],\n  \"kj\": [\"\", 1116],\n  \"v%\": [\"\", 1118],\n  \"dz\": [\"\", 1119],\n  \"Y3\": [\"\", 1122],\n  \"y3\": [\"\", 1123],\n  \"O3\": [\"\", 1130],\n  \"o3\": [\"\", 1131],\n  \"F3\": [\"\", 1138],\n  \"f3\": [\"\", 1139],\n  \"V3\": [\"\", 1140],\n  \"v3\": [\"\", 1141],\n  \"C3\": [\"\", 1152],\n  \"c3\": [\"\", 1153],\n  \"G3\": [\"\", 1168],\n  \"g3\": [\"\", 1169],\n  \"A+\": [\"\", 1488],\n  \"B+\": [\"\", 1489],\n  \"G+\": [\"\", 1490],\n  \"D+\": [\"\", 1491],\n  \"H+\": [\"\", 1492],\n  \"W+\": [\"\", 1493],\n  \"Z+\": [\"\", 1494],\n  \"X+\": [\"\", 1495],\n  \"Tj\": [\"\", 1496],\n  \"J+\": [\"\", 1497],\n  \"K%\": [\"\", 1498],\n  \"K+\": [\"\", 1499],\n  \"L+\": [\"\", 1500],\n  \"M%\": [\"\", 1501],\n  \"M+\": [\"\", 1502],\n  \"N%\": [\"\", 1503],\n  \"N+\": [\"\", 1504],\n  \"S+\": [\"\", 1505],\n  \"E+\": [\"\", 1506],\n  \"P%\": [\"\", 1507],\n  \"P+\": [\"\", 1508],\n  \"Zj\": [\"\", 1509],\n  \"ZJ\": [\"\", 1510],\n  \"Q+\": [\"\", 1511],\n  \"R+\": [\"\", 1512],\n  \"Sh\": [\"\", 1513],\n  \"T+\": [\"\", 1514],\n  \",+\": [\"\", 1548],\n  \";+\": [\"\", 1563],\n  \"?+\": [\"\", 1567],\n  \"H'\": [\"\", 1569],\n  \"aM\": [\"\", 1570],\n  \"aH\": [\"\", 1571],\n  \"wH\": [\"\", 1572],\n  \"ah\": [\"\", 1573],\n  \"yH\": [\"\", 1574],\n  \"a+\": [\"\", 1575],\n  \"b+\": [\"\", 1576],\n  \"tm\": [\"\", 1577],\n  \"t+\": [\"\", 1578],\n  \"tk\": [\"\", 1579],\n  \"g+\": [\"\", 1580],\n  \"hk\": [\"\", 1581],\n  \"x+\": [\"\", 1582],\n  \"d+\": [\"\", 1583],\n  \"dk\": [\"\", 1584],\n  \"r+\": [\"\", 1585],\n  \"z+\": [\"\", 1586],\n  \"s+\": [\"\", 1587],\n  \"sn\": [\"\", 1588],\n  \"c+\": [\"\", 1589],\n  \"dd\": [\"\", 1590],\n  \"tj\": [\"\", 1591],\n  \"zH\": [\"\", 1592],\n  \"e+\": [\"\", 1593],\n  \"i+\": [\"\", 1594],\n  \"++\": [\"\", 1600],\n  \"f+\": [\"\", 1601],\n  \"q+\": [\"\", 1602],\n  \"k+\": [\"\", 1603],\n  \"l+\": [\"\", 1604],\n  \"m+\": [\"\", 1605],\n  \"n+\": [\"\", 1606],\n  \"h+\": [\"\", 1607],\n  \"w+\": [\"\", 1608],\n  \"j+\": [\"\", 1609],\n  \"y+\": [\"\", 1610],\n  \":+\": [\"\", 1611],\n  \"\\\"+\": [\"\", 1612],\n  \"=+\": [\"\", 1613],\n  \"/+\": [\"\", 1614],\n  \"'+\": [\"\", 1615],\n  \"1+\": [\"\", 1616],\n  \"3+\": [\"\", 1617],\n  \"0+\": [\"\", 1618],\n  \"aS\": [\"\", 1648],\n  \"p+\": [\"\", 1662],\n  \"v+\": [\"\", 1700],\n  \"gf\": [\"\", 1711],\n  \"0a\": [\"\", 1776],\n  \"1a\": [\"\", 1777],\n  \"2a\": [\"\", 1778],\n  \"3a\": [\"\", 1779],\n  \"4a\": [\"\", 1780],\n  \"5a\": [\"\", 1781],\n  \"6a\": [\"\", 1782],\n  \"7a\": [\"\", 1783],\n  \"8a\": [\"\", 1784],\n  \"9a\": [\"\", 1785],\n  \"B.\": [\"\", 7682],\n  \"b.\": [\"\", 7683],\n  \"B_\": [\"\", 7686],\n  \"b_\": [\"\", 7687],\n  \"D.\": [\"\", 7690],\n  \"d.\": [\"\", 7691],\n  \"D_\": [\"\", 7694],\n  \"d_\": [\"\", 7695],\n  \"D,\": [\"\", 7696],\n  \"d,\": [\"\", 7697],\n  \"F.\": [\"\", 7710],\n  \"f.\": [\"\", 7711],\n  \"G-\": [\"\", 7712],\n  \"g-\": [\"\", 7713],\n  \"H.\": [\"\", 7714],\n  \"h.\": [\"\", 7715],\n  \"H:\": [\"\", 7718],\n  \"h:\": [\"\", 7719],\n  \"H,\": [\"\", 7720],\n  \"h,\": [\"\", 7721],\n  \"K'\": [\"\", 7728],\n  \"k'\": [\"\", 7729],\n  \"K_\": [\"\", 7732],\n  \"k_\": [\"\", 7733],\n  \"L_\": [\"\", 7738],\n  \"l_\": [\"\", 7739],\n  \"M'\": [\"\", 7742],\n  \"m'\": [\"\", 7743],\n  \"M.\": [\"\", 7744],\n  \"m.\": [\"\", 7745],\n  \"N.\": [\"\", 7748],\n  \"n.\": [\"\", 7749],\n  \"N_\": [\"\", 7752],\n  \"n_\": [\"\", 7753],\n  \"P'\": [\"\", 7764],\n  \"p'\": [\"\", 7765],\n  \"P.\": [\"\", 7766],\n  \"p.\": [\"\", 7767],\n  \"R.\": [\"\", 7768],\n  \"r.\": [\"\", 7769],\n  \"R_\": [\"\", 7774],\n  \"r_\": [\"\", 7775],\n  \"S.\": [\"\", 7776],\n  \"s.\": [\"\", 7777],\n  \"T.\": [\"\", 7786],\n  \"t.\": [\"\", 7787],\n  \"T_\": [\"\", 7790],\n  \"t_\": [\"\", 7791],\n  \"V?\": [\"\", 7804],\n  \"v?\": [\"\", 7805],\n  \"W!\": [\"\", 7808],\n  \"w!\": [\"\", 7809],\n  \"W'\": [\"\", 7810],\n  \"w'\": [\"\", 7811],\n  \"W:\": [\"\", 7812],\n  \"w:\": [\"\", 7813],\n  \"W.\": [\"\", 7814],\n  \"w.\": [\"\", 7815],\n  \"X.\": [\"\", 7818],\n  \"x.\": [\"\", 7819],\n  \"X:\": [\"\", 7820],\n  \"x:\": [\"\", 7821],\n  \"Y.\": [\"\", 7822],\n  \"y.\": [\"\", 7823],\n  \"Z>\": [\"\", 7824],\n  \"z>\": [\"\", 7825],\n  \"Z_\": [\"\", 7828],\n  \"z_\": [\"\", 7829],\n  \"h_\": [\"\", 7830],\n  \"t:\": [\"\", 7831],\n  \"w0\": [\"\", 7832],\n  \"y0\": [\"\", 7833],\n  \"A2\": [\"\", 7842],\n  \"a2\": [\"\", 7843],\n  \"E2\": [\"\", 7866],\n  \"e2\": [\"\", 7867],\n  \"E?\": [\"\", 7868],\n  \"e?\": [\"\", 7869],\n  \"I2\": [\"\", 7880],\n  \"i2\": [\"\", 7881],\n  \"O2\": [\"\", 7886],\n  \"o2\": [\"\", 7887],\n  \"U2\": [\"\", 7910],\n  \"u2\": [\"\", 7911],\n  \"Y!\": [\"\", 7922],\n  \"y!\": [\"\", 7923],\n  \"Y2\": [\"\", 7926],\n  \"y2\": [\"\", 7927],\n  \"Y?\": [\"\", 7928],\n  \"y?\": [\"\", 7929],\n  \";'\": [\"\", 7936],\n  \",'\": [\"\", 7937],\n  \";!\": [\"\", 7938],\n  \",!\": [\"\", 7939],\n  \"?;\": [\"\", 7940],\n  \"?,\": [\"\", 7941],\n  \"!:\": [\"\", 7942],\n  \"?:\": [\"\", 7943],\n  \"1N\": [\"\", 8194],\n  \"1M\": [\"\", 8195],\n  \"3M\": [\"\", 8196],\n  \"4M\": [\"\", 8197],\n  \"6M\": [\"\", 8198],\n  \"1T\": [\"\", 8201],\n  \"1H\": [\"\", 8202],\n  \"-1\": [\"\", 8208],\n  \"-N\": [\"\", 8211],\n  \"-M\": [\"\", 8212],\n  \"-3\": [\"\", 8213],\n  \"!2\": [\"\", 8214],\n  \"=2\": [\"\", 8215],\n  \"'6\": [\"\", 8216],\n  \"'9\": [\"\", 8217],\n  \".9\": [\"\", 8218],\n  \"9'\": [\"\", 8219],\n  \"\\\"6\": [\"\", 8220],\n  \"\\\"9\": [\"\", 8221],\n  \":9\": [\"\", 8222],\n  \"9\\\"\": [\"\", 8223],\n  \"/-\": [\"\", 8224],\n  \"/=\": [\"\", 8225],\n  \"..\": [\"\", 8229],\n  \",.\": [\"\", 8230],\n  \"%0\": [\"\", 8240],\n  \"1'\": [\"\", 8242],\n  \"2'\": [\"\", 8243],\n  \"3'\": [\"\", 8244],\n  \"1\\\"\": [\"\", 8245],\n  \"2\\\"\": [\"\", 8246],\n  \"3\\\"\": [\"\", 8247],\n  \"Ca\": [\"\", 8248],\n  \"<1\": [\"\", 8249],\n  \">1\": [\"\", 8250],\n  \":X\": [\"\", 8251],\n  \"'-\": [\"\", 8254],\n  \"/f\": [\"\", 8260],\n  \"0S\": [\"\", 8304],\n  \"4S\": [\"\", 8308],\n  \"5S\": [\"\", 8309],\n  \"6S\": [\"\", 8310],\n  \"7S\": [\"\", 8311],\n  \"8S\": [\"\", 8312],\n  \"9S\": [\"\", 8313],\n  \"+S\": [\"\", 8314],\n  \"-S\": [\"\", 8315],\n  \"=S\": [\"\", 8316],\n  \"(S\": [\"\", 8317],\n  \")S\": [\"\", 8318],\n  \"nS\": [\"\", 8319],\n  \"0s\": [\"\", 8320],\n  \"1s\": [\"\", 8321],\n  \"2s\": [\"\", 8322],\n  \"3s\": [\"\", 8323],\n  \"4s\": [\"\", 8324],\n  \"5s\": [\"\", 8325],\n  \"6s\": [\"\", 8326],\n  \"7s\": [\"\", 8327],\n  \"8s\": [\"\", 8328],\n  \"9s\": [\"\", 8329],\n  \"+s\": [\"\", 8330],\n  \"-s\": [\"\", 8331],\n  \"=s\": [\"\", 8332],\n  \"(s\": [\"\", 8333],\n  \")s\": [\"\", 8334],\n  \"Li\": [\"\", 8356],\n  \"Pt\": [\"\", 8359],\n  \"W=\": [\"\", 8361],\n  \"=e\": [\"\", 8364],\n  \"Eu\": [\"\", 8364],\n  \"=R\": [\"\", 8381],\n  \"=P\": [\"\", 8381],\n  \"oC\": [\"\", 8451],\n  \"co\": [\"\", 8453],\n  \"oF\": [\"\", 8457],\n  \"N0\": [\"\", 8470],\n  \"PO\": [\"\", 8471],\n  \"Rx\": [\"\", 8478],\n  \"SM\": [\"\", 8480],\n  \"TM\": [\"\", 8482],\n  \"Om\": [\"\", 8486],\n  \"AO\": [\"\", 8491],\n  \"13\": [\"\", 8531],\n  \"23\": [\"\", 8532],\n  \"15\": [\"\", 8533],\n  \"25\": [\"\", 8534],\n  \"35\": [\"\", 8535],\n  \"45\": [\"\", 8536],\n  \"16\": [\"\", 8537],\n  \"56\": [\"\", 8538],\n  \"18\": [\"\", 8539],\n  \"38\": [\"\", 8540],\n  \"58\": [\"\", 8541],\n  \"78\": [\"\", 8542],\n  \"1R\": [\"\", 8544],\n  \"2R\": [\"\", 8545],\n  \"3R\": [\"\", 8546],\n  \"4R\": [\"\", 8547],\n  \"5R\": [\"\", 8548],\n  \"6R\": [\"\", 8549],\n  \"7R\": [\"\", 8550],\n  \"8R\": [\"\", 8551],\n  \"9R\": [\"\", 8552],\n  \"aR\": [\"\", 8553],\n  \"bR\": [\"\", 8554],\n  \"cR\": [\"\", 8555],\n  \"1r\": [\"\", 8560],\n  \"2r\": [\"\", 8561],\n  \"3r\": [\"\", 8562],\n  \"4r\": [\"\", 8563],\n  \"5r\": [\"\", 8564],\n  \"6r\": [\"\", 8565],\n  \"7r\": [\"\", 8566],\n  \"8r\": [\"\", 8567],\n  \"9r\": [\"\", 8568],\n  \"ar\": [\"\", 8569],\n  \"br\": [\"\", 8570],\n  \"cr\": [\"\", 8571],\n  \"<-\": [\"\", 8592],\n  \"-!\": [\"\", 8593],\n  \"->\": [\"\", 8594],\n  \"-v\": [\"\", 8595],\n  \"<>\": [\"\", 8596],\n  \"UD\": [\"\", 8597],\n  \"<=\": [\"\", 8656],\n  \"=>\": [\"\", 8658],\n  \"==\": [\"\", 8660],\n  \"FA\": [\"\", 8704],\n  \"dP\": [\"\", 8706],\n  \"TE\": [\"\", 8707],\n  \"/0\": [\"\", 8709],\n  \"DE\": [\"\", 8710],\n  \"NB\": [\"\", 8711],\n  \"(-\": [\"\", 8712],\n  \"-)\": [\"\", 8715],\n  \"*P\": [\"\", 8719],\n  \"+Z\": [\"\", 8721],\n  \"-2\": [\"\", 8722],\n  \"-+\": [\"\", 8723],\n  \"*-\": [\"\", 8727],\n  \"Ob\": [\"\", 8728],\n  \"Sb\": [\"\", 8729],\n  \"RT\": [\"\", 8730],\n  \"0(\": [\"\", 8733],\n  \"00\": [\"\", 8734],\n  \"-L\": [\"\", 8735],\n  \"-V\": [\"\", 8736],\n  \"PP\": [\"\", 8741],\n  \"AN\": [\"\", 8743],\n  \"OR\": [\"\", 8744],\n  \"(U\": [\"\", 8745],\n  \")U\": [\"\", 8746],\n  \"In\": [\"\", 8747],\n  \"DI\": [\"\", 8748],\n  \"Io\": [\"\", 8750],\n  \".:\": [\"\", 8756],\n  \":.\": [\"\", 8757],\n  \":R\": [\"\", 8758],\n  \"::\": [\"\", 8759],\n  \"?1\": [\"\", 8764],\n  \"CG\": [\"\", 8766],\n  \"?-\": [\"\", 8771],\n  \"?=\": [\"\", 8773],\n  \"?2\": [\"\", 8776],\n  \"=?\": [\"\", 8780],\n  \"HI\": [\"\", 8787],\n  \"!=\": [\"\", 8800],\n  \"=3\": [\"\", 8801],\n  \"=<\": [\"\", 8804],\n  \">=\": [\"\", 8805],\n  \"<*\": [\"\", 8810],\n  \"*>\": [\"\", 8811],\n  \"!<\": [\"\", 8814],\n  \"!>\": [\"\", 8815],\n  \"(C\": [\"\", 8834],\n  \")C\": [\"\", 8835],\n  \"(_\": [\"\", 8838],\n  \")_\": [\"\", 8839],\n  \"0.\": [\"\", 8857],\n  \"02\": [\"\", 8858],\n  \"-T\": [\"\", 8869],\n  \".P\": [\"\", 8901],\n  \":3\": [\"\", 8942],\n  \".3\": [\"\", 8943],\n  \"Eh\": [\"\", 8962],\n  \"<7\": [\"\", 8968],\n  \">7\": [\"\", 8969],\n  \"7<\": [\"\", 8970],\n  \"7>\": [\"\", 8971],\n  \"NI\": [\"\", 8976],\n  \"(A\": [\"\", 8978],\n  \"TR\": [\"\", 8981],\n  \"Iu\": [\"\", 8992],\n  \"Il\": [\"\", 8993],\n  \"</\": [\"\", 9001],\n  \"/>\": [\"\", 9002],\n  \"Vs\": [\"\", 9251],\n  \"1h\": [\"\", 9280],\n  \"3h\": [\"\", 9281],\n  \"2h\": [\"\", 9282],\n  \"4h\": [\"\", 9283],\n  \"1j\": [\"\", 9286],\n  \"2j\": [\"\", 9287],\n  \"3j\": [\"\", 9288],\n  \"4j\": [\"\", 9289],\n  \"1.\": [\"\", 9352],\n  \"2.\": [\"\", 9353],\n  \"3.\": [\"\", 9354],\n  \"4.\": [\"\", 9355],\n  \"5.\": [\"\", 9356],\n  \"6.\": [\"\", 9357],\n  \"7.\": [\"\", 9358],\n  \"8.\": [\"\", 9359],\n  \"9.\": [\"\", 9360],\n  \"hh\": [\"\", 9472],\n  \"HH\": [\"\", 9473],\n  \"vv\": [\"\", 9474],\n  \"VV\": [\"\", 9475],\n  \"3-\": [\"\", 9476],\n  \"3_\": [\"\", 9477],\n  \"3!\": [\"\", 9478],\n  \"3/\": [\"\", 9479],\n  \"4-\": [\"\", 9480],\n  \"4_\": [\"\", 9481],\n  \"4!\": [\"\", 9482],\n  \"4/\": [\"\", 9483],\n  \"dr\": [\"\", 9484],\n  \"dR\": [\"\", 9485],\n  \"Dr\": [\"\", 9486],\n  \"DR\": [\"\", 9487],\n  \"dl\": [\"\", 9488],\n  \"dL\": [\"\", 9489],\n  \"Dl\": [\"\", 9490],\n  \"LD\": [\"\", 9491],\n  \"ur\": [\"\", 9492],\n  \"uR\": [\"\", 9493],\n  \"Ur\": [\"\", 9494],\n  \"UR\": [\"\", 9495],\n  \"ul\": [\"\", 9496],\n  \"uL\": [\"\", 9497],\n  \"Ul\": [\"\", 9498],\n  \"UL\": [\"\", 9499],\n  \"vr\": [\"\", 9500],\n  \"vR\": [\"\", 9501],\n  \"Vr\": [\"\", 9504],\n  \"VR\": [\"\", 9507],\n  \"vl\": [\"\", 9508],\n  \"vL\": [\"\", 9509],\n  \"Vl\": [\"\", 9512],\n  \"VL\": [\"\", 9515],\n  \"dh\": [\"\", 9516],\n  \"dH\": [\"\", 9519],\n  \"Dh\": [\"\", 9520],\n  \"DH\": [\"\", 9523],\n  \"uh\": [\"\", 9524],\n  \"uH\": [\"\", 9527],\n  \"Uh\": [\"\", 9528],\n  \"UH\": [\"\", 9531],\n  \"vh\": [\"\", 9532],\n  \"vH\": [\"\", 9535],\n  \"Vh\": [\"\", 9538],\n  \"VH\": [\"\", 9547],\n  \"FD\": [\"\", 9585],\n  \"BD\": [\"\", 9586],\n  \"TB\": [\"\", 9600],\n  \"LB\": [\"\", 9604],\n  \"FB\": [\"\", 9608],\n  \"lB\": [\"\", 9612],\n  \"RB\": [\"\", 9616],\n  \".S\": [\"\", 9617],\n  \":S\": [\"\", 9618],\n  \"?S\": [\"\", 9619],\n  \"fS\": [\"\", 9632],\n  \"OS\": [\"\", 9633],\n  \"RO\": [\"\", 9634],\n  \"Rr\": [\"\", 9635],\n  \"RF\": [\"\", 9636],\n  \"RY\": [\"\", 9637],\n  \"RH\": [\"\", 9638],\n  \"RZ\": [\"\", 9639],\n  \"RK\": [\"\", 9640],\n  \"RX\": [\"\", 9641],\n  \"sB\": [\"\", 9642],\n  \"SR\": [\"\", 9644],\n  \"Or\": [\"\", 9645],\n  \"UT\": [\"\", 9650],\n  \"uT\": [\"\", 9651],\n  \"PR\": [\"\", 9654],\n  \"Tr\": [\"\", 9655],\n  \"Dt\": [\"\", 9660],\n  \"dT\": [\"\", 9661],\n  \"PL\": [\"\", 9664],\n  \"Tl\": [\"\", 9665],\n  \"Db\": [\"\", 9670],\n  \"Dw\": [\"\", 9671],\n  \"LZ\": [\"\", 9674],\n  \"0m\": [\"\", 9675],\n  \"0o\": [\"\", 9678],\n  \"0M\": [\"\", 9679],\n  \"0L\": [\"\", 9680],\n  \"0R\": [\"\", 9681],\n  \"Sn\": [\"\", 9688],\n  \"Ic\": [\"\", 9689],\n  \"Fd\": [\"\", 9698],\n  \"Bd\": [\"\", 9699],\n  \"*2\": [\"\", 9733],\n  \"*1\": [\"\", 9734],\n  \"<H\": [\"\", 9756],\n  \">H\": [\"\", 9758],\n  \"0u\": [\"\", 9786],\n  \"0U\": [\"\", 9787],\n  \"SU\": [\"\", 9788],\n  \"Fm\": [\"\", 9792],\n  \"Ml\": [\"\", 9794],\n  \"cS\": [\"\", 9824],\n  \"cH\": [\"\", 9825],\n  \"cD\": [\"\", 9826],\n  \"cC\": [\"\", 9827],\n  \"Md\": [\"\", 9833],\n  \"M8\": [\"\", 9834],\n  \"M2\": [\"\", 9835],\n  \"Mb\": [\"\", 9837],\n  \"Mx\": [\"\", 9838],\n  \"MX\": [\"\", 9839],\n  \"OK\": [\"\", 10003],\n  \"XX\": [\"\", 10007],\n  \"-X\": [\"\", 10016],\n  \"IS\": [\"\", 12288],\n  \",_\": [\"\", 12289],\n  \"._\": [\"\", 12290],\n  \"+\\\"\": [\"\", 12291],\n  \"+_\": [\"\", 12292],\n  \"*_\": [\"\", 12293],\n  \";_\": [\"\", 12294],\n  \"0_\": [\"\", 12295],\n  \"<+\": [\"\", 12298],\n  \">+\": [\"\", 12299],\n  \"<'\": [\"\", 12300],\n  \">'\": [\"\", 12301],\n  \"<\\\"\": [\"\", 12302],\n  \">\\\"\": [\"\", 12303],\n  \"(\\\"\": [\"\", 12304],\n  \")\\\"\": [\"\", 12305],\n  \"=T\": [\"\", 12306],\n  \"=_\": [\"\", 12307],\n  \"('\": [\"\", 12308],\n  \")'\": [\"\", 12309],\n  \"(I\": [\"\", 12310],\n  \")I\": [\"\", 12311],\n  \"-?\": [\"\", 12316],\n  \"A5\": [\"\", 12353],\n  \"a5\": [\"\", 12354],\n  \"I5\": [\"\", 12355],\n  \"i5\": [\"\", 12356],\n  \"U5\": [\"\", 12357],\n  \"u5\": [\"\", 12358],\n  \"E5\": [\"\", 12359],\n  \"e5\": [\"\", 12360],\n  \"O5\": [\"\", 12361],\n  \"o5\": [\"\", 12362],\n  \"ka\": [\"\", 12363],\n  \"ga\": [\"\", 12364],\n  \"ki\": [\"\", 12365],\n  \"gi\": [\"\", 12366],\n  \"ku\": [\"\", 12367],\n  \"gu\": [\"\", 12368],\n  \"ke\": [\"\", 12369],\n  \"ge\": [\"\", 12370],\n  \"ko\": [\"\", 12371],\n  \"go\": [\"\", 12372],\n  \"sa\": [\"\", 12373],\n  \"za\": [\"\", 12374],\n  \"si\": [\"\", 12375],\n  \"zi\": [\"\", 12376],\n  \"su\": [\"\", 12377],\n  \"zu\": [\"\", 12378],\n  \"se\": [\"\", 12379],\n  \"ze\": [\"\", 12380],\n  \"so\": [\"\", 12381],\n  \"zo\": [\"\", 12382],\n  \"ta\": [\"\", 12383],\n  \"da\": [\"\", 12384],\n  \"ti\": [\"\", 12385],\n  \"di\": [\"\", 12386],\n  \"tU\": [\"\", 12387],\n  \"tu\": [\"\", 12388],\n  \"du\": [\"\", 12389],\n  \"te\": [\"\", 12390],\n  \"de\": [\"\", 12391],\n  \"to\": [\"\", 12392],\n  \"do\": [\"\", 12393],\n  \"na\": [\"\", 12394],\n  \"ni\": [\"\", 12395],\n  \"nu\": [\"\", 12396],\n  \"ne\": [\"\", 12397],\n  \"no\": [\"\", 12398],\n  \"ha\": [\"\", 12399],\n  \"ba\": [\"\", 12400],\n  \"pa\": [\"\", 12401],\n  \"hi\": [\"\", 12402],\n  \"bi\": [\"\", 12403],\n  \"pi\": [\"\", 12404],\n  \"hu\": [\"\", 12405],\n  \"bu\": [\"\", 12406],\n  \"pu\": [\"\", 12407],\n  \"he\": [\"\", 12408],\n  \"be\": [\"\", 12409],\n  \"pe\": [\"\", 12410],\n  \"ho\": [\"\", 12411],\n  \"bo\": [\"\", 12412],\n  \"po\": [\"\", 12413],\n  \"ma\": [\"\", 12414],\n  \"mi\": [\"\", 12415],\n  \"mu\": [\"\", 12416],\n  \"me\": [\"\", 12417],\n  \"mo\": [\"\", 12418],\n  \"yA\": [\"\", 12419],\n  \"ya\": [\"\", 12420],\n  \"yU\": [\"\", 12421],\n  \"yu\": [\"\", 12422],\n  \"yO\": [\"\", 12423],\n  \"yo\": [\"\", 12424],\n  \"ra\": [\"\", 12425],\n  \"ri\": [\"\", 12426],\n  \"ru\": [\"\", 12427],\n  \"re\": [\"\", 12428],\n  \"ro\": [\"\", 12429],\n  \"wA\": [\"\", 12430],\n  \"wa\": [\"\", 12431],\n  \"wi\": [\"\", 12432],\n  \"we\": [\"\", 12433],\n  \"wo\": [\"\", 12434],\n  \"n5\": [\"\", 12435],\n  \"vu\": [\"\", 12436],\n  \"\\\"5\": [\"\", 12443],\n  \"05\": [\"\", 12444],\n  \"*5\": [\"\", 12445],\n  \"+5\": [\"\", 12446],\n  \"a6\": [\"\", 12449],\n  \"A6\": [\"\", 12450],\n  \"i6\": [\"\", 12451],\n  \"I6\": [\"\", 12452],\n  \"u6\": [\"\", 12453],\n  \"U6\": [\"\", 12454],\n  \"e6\": [\"\", 12455],\n  \"E6\": [\"\", 12456],\n  \"o6\": [\"\", 12457],\n  \"O6\": [\"\", 12458],\n  \"Ka\": [\"\", 12459],\n  \"Ga\": [\"\", 12460],\n  \"Ki\": [\"\", 12461],\n  \"Gi\": [\"\", 12462],\n  \"Ku\": [\"\", 12463],\n  \"Gu\": [\"\", 12464],\n  \"Ke\": [\"\", 12465],\n  \"Ge\": [\"\", 12466],\n  \"Ko\": [\"\", 12467],\n  \"Go\": [\"\", 12468],\n  \"Sa\": [\"\", 12469],\n  \"Za\": [\"\", 12470],\n  \"Si\": [\"\", 12471],\n  \"Zi\": [\"\", 12472],\n  \"Su\": [\"\", 12473],\n  \"Zu\": [\"\", 12474],\n  \"Se\": [\"\", 12475],\n  \"Ze\": [\"\", 12476],\n  \"So\": [\"\", 12477],\n  \"Zo\": [\"\", 12478],\n  \"Ta\": [\"\", 12479],\n  \"Da\": [\"\", 12480],\n  \"Ti\": [\"\", 12481],\n  \"Di\": [\"\", 12482],\n  \"TU\": [\"\", 12483],\n  \"Tu\": [\"\", 12484],\n  \"Du\": [\"\", 12485],\n  \"Te\": [\"\", 12486],\n  \"De\": [\"\", 12487],\n  \"To\": [\"\", 12488],\n  \"Do\": [\"\", 12489],\n  \"Na\": [\"\", 12490],\n  \"Ni\": [\"\", 12491],\n  \"Nu\": [\"\", 12492],\n  \"Ne\": [\"\", 12493],\n  \"No\": [\"\", 12494],\n  \"Ha\": [\"\", 12495],\n  \"Ba\": [\"\", 12496],\n  \"Pa\": [\"\", 12497],\n  \"Hi\": [\"\", 12498],\n  \"Bi\": [\"\", 12499],\n  \"Pi\": [\"\", 12500],\n  \"Hu\": [\"\", 12501],\n  \"Bu\": [\"\", 12502],\n  \"Pu\": [\"\", 12503],\n  \"He\": [\"\", 12504],\n  \"Be\": [\"\", 12505],\n  \"Pe\": [\"\", 12506],\n  \"Ho\": [\"\", 12507],\n  \"Bo\": [\"\", 12508],\n  \"Po\": [\"\", 12509],\n  \"Ma\": [\"\", 12510],\n  \"Mi\": [\"\", 12511],\n  \"Mu\": [\"\", 12512],\n  \"Me\": [\"\", 12513],\n  \"Mo\": [\"\", 12514],\n  \"YA\": [\"\", 12515],\n  \"Ya\": [\"\", 12516],\n  \"YU\": [\"\", 12517],\n  \"Yu\": [\"\", 12518],\n  \"YO\": [\"\", 12519],\n  \"Yo\": [\"\", 12520],\n  \"Ra\": [\"\", 12521],\n  \"Ri\": [\"\", 12522],\n  \"Ru\": [\"\", 12523],\n  \"Re\": [\"\", 12524],\n  \"Ro\": [\"\", 12525],\n  \"WA\": [\"\", 12526],\n  \"Wa\": [\"\", 12527],\n  \"Wi\": [\"\", 12528],\n  \"We\": [\"\", 12529],\n  \"Wo\": [\"\", 12530],\n  \"N6\": [\"\", 12531],\n  \"Vu\": [\"\", 12532],\n  \"KA\": [\"\", 12533],\n  \"KE\": [\"\", 12534],\n  \"Va\": [\"\", 12535],\n  \"Vi\": [\"\", 12536],\n  \"Ve\": [\"\", 12537],\n  \"Vo\": [\"\", 12538],\n  \".6\": [\"\", 12539],\n  \"-6\": [\"\", 12540],\n  \"*6\": [\"\", 12541],\n  \"+6\": [\"\", 12542],\n  \"b4\": [\"\", 12549],\n  \"p4\": [\"\", 12550],\n  \"m4\": [\"\", 12551],\n  \"f4\": [\"\", 12552],\n  \"d4\": [\"\", 12553],\n  \"t4\": [\"\", 12554],\n  \"n4\": [\"\", 12555],\n  \"l4\": [\"\", 12556],\n  \"g4\": [\"\", 12557],\n  \"k4\": [\"\", 12558],\n  \"h4\": [\"\", 12559],\n  \"j4\": [\"\", 12560],\n  \"q4\": [\"\", 12561],\n  \"x4\": [\"\", 12562],\n  \"zh\": [\"\", 12563],\n  \"ch\": [\"\", 12564],\n  \"sh\": [\"\", 12565],\n  \"r4\": [\"\", 12566],\n  \"z4\": [\"\", 12567],\n  \"c4\": [\"\", 12568],\n  \"s4\": [\"\", 12569],\n  \"a4\": [\"\", 12570],\n  \"o4\": [\"\", 12571],\n  \"e4\": [\"\", 12572],\n  \"ai\": [\"\", 12574],\n  \"ei\": [\"\", 12575],\n  \"au\": [\"\", 12576],\n  \"ou\": [\"\", 12577],\n  \"an\": [\"\", 12578],\n  \"en\": [\"\", 12579],\n  \"aN\": [\"\", 12580],\n  \"eN\": [\"\", 12581],\n  \"er\": [\"\", 12582],\n  \"i4\": [\"\", 12583],\n  \"u4\": [\"\", 12584],\n  \"iu\": [\"\", 12585],\n  \"v4\": [\"\", 12586],\n  \"nG\": [\"\", 12587],\n  \"gn\": [\"\", 12588],\n  \"1c\": [\"\", 12832],\n  \"2c\": [\"\", 12833],\n  \"3c\": [\"\", 12834],\n  \"4c\": [\"\", 12835],\n  \"5c\": [\"\", 12836],\n  \"6c\": [\"\", 12837],\n  \"7c\": [\"\", 12838],\n  \"8c\": [\"\", 12839],\n  \"9c\": [\"\", 12840],\n  \"ff\": [\"\", 64256],\n  \"fi\": [\"\", 64257],\n  \"fl\": [\"\", 64258],\n  \"ft\": [\"\", 64261],\n  \"st\": [\"\", 64262],\n  \"W`\": [\"\", 7808],\n  \"w`\": [\"\", 7809],\n  \"Y`\": [\"\", 7922],\n  \"y`\": [\"\", 7923],\n};\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\nimport { Cursor } from '../../common/motion/cursor';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { BaseCommand, RegisterAction } from '../base';\nimport { BaseOperator } from '../operator';\n\ntype FoldDirection = 'up' | 'down' | undefined;\nabstract class CommandFold extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  abstract commandName: string;\n  direction: FoldDirection | undefined;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const args =\n      this.direction !== undefined\n        ? { levels: timesToRepeat, direction: this.direction }\n        : undefined;\n    vimState.recordedState.transformer.vscodeCommand(this.commandName, args);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass CommandToggleFold extends CommandFold {\n  keys = ['z', 'a'];\n  commandName = 'editor.toggleFold';\n}\n\n@RegisterAction\nclass CommandCloseFold extends CommandFold {\n  keys = ['z', 'c'];\n  commandName = 'editor.fold';\n  override direction: FoldDirection = 'up';\n}\n\n@RegisterAction\nclass CommandCloseAllFolds extends CommandFold {\n  keys = ['z', 'M'];\n  commandName = 'editor.foldAll';\n}\n\n@RegisterAction\nclass CommandOpenFold extends CommandFold {\n  keys = ['z', 'o'];\n  commandName = 'editor.unfold';\n  override direction: FoldDirection = 'down';\n}\n\n@RegisterAction\nclass CommandOpenAllFolds extends CommandFold {\n  keys = ['z', 'R'];\n  commandName = 'editor.unfoldAll';\n}\n\n@RegisterAction\nclass CommandCloseAllFoldsRecursively extends CommandFold {\n  override modes = [Mode.Normal];\n  keys = ['z', 'C'];\n  commandName = 'editor.foldRecursively';\n}\n\n@RegisterAction\nclass CommandOpenAllFoldsRecursively extends CommandFold {\n  override modes = [Mode.Normal];\n  keys = ['z', 'O'];\n  commandName = 'editor.unfoldRecursively';\n}\n\n@RegisterAction\nclass AddFold extends BaseOperator {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['z', 'f'];\n\n  readonly commandName = 'editor.createFoldingRangeFromSelection';\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    const previousSelections = vimState.lastVisualSelection;  // keep in case of Normal mode\n    vimState.editor.selection = new vscode.Selection(start, end);\n    await vscode.commands.executeCommand(this.commandName);\n    vimState.lastVisualSelection = previousSelections;\n    vimState.cursors = [new Cursor(start, start)];\n    await vimState.setCurrentMode(Mode.Normal);  // Vim behavior\n  }\n}\n\n@RegisterAction\nclass RemoveFold extends BaseCommand {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['z', 'd'];\n  readonly commandName = 'editor.removeManualFoldingRanges';\n\n  override async exec(position: Position, vimState: VimState): Promise<void> {\n\n    await vscode.commands.executeCommand(this.commandName);\n\n    const newCursorPosition = vimState.currentMode === Mode.Visual\n      ? vimState.editor.selection.start\n      : position;\n    vimState.cursors = [new Cursor(newCursorPosition, newCursorPosition)];\n    await vimState.setCurrentMode(Mode.Normal);  // Vim behavior\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { lineCompletionProvider } from '../../completion/lineCompletionProvider';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { PositionDiff } from './../../common/motion/position';\nimport { configuration } from './../../configuration/configuration';\nimport { Mode } from './../../mode/mode';\nimport { Register, RegisterMode } from './../../register/register';\nimport { TextEditor } from './../../textEditor';\nimport { RegisterAction, BaseCommand } from './../base';\nimport { ArrowsInInsertMode } from './../motion';\nimport {\n  CommandInsertAfterCursor,\n  CommandInsertAtCursor,\n  CommandInsertAtFirstCharacter,\n  CommandInsertAtLineEnd,\n  DocumentContentChangeAction,\n  CommandReplaceAtCursorFromNormalMode,\n  CommandInsertAtLineBegin,\n  CommandInsertAtLastChange,\n  CommandInsertNewLineAbove,\n  CommandInsertNewLineBefore,\n} from './actions';\nimport { DefaultDigraphs } from './digraphs';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\nimport { isHighSurrogate, isLowSurrogate } from '../../util/util';\n\n@RegisterAction\nexport class CommandEscInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vscode.commands.executeCommand('closeParameterHints');\n\n    vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getLeft()));\n    if (vimState.returnToInsertAfterCommand && position.character !== 0) {\n      vimState.cursors = vimState.cursors.map((x) => x.withNewStop(x.stop.getRight()));\n    }\n\n    // only remove leading spaces inserted by vscode.\n    // vscode only inserts them when user enter a new line,\n    // ie, o/O in Normal mode or \\n in Insert mode.\n    const lastActionBeforeEsc =\n      vimState.recordedState.actionsRun[vimState.recordedState.actionsRun.length - 2];\n    if (\n      vimState.document.languageId !== 'plaintext' &&\n      (lastActionBeforeEsc instanceof CommandInsertNewLineBefore ||\n        lastActionBeforeEsc instanceof CommandInsertNewLineAbove ||\n        (lastActionBeforeEsc instanceof DocumentContentChangeAction &&\n          lastActionBeforeEsc.keysPressed[lastActionBeforeEsc.keysPressed.length - 1] === '\\n'))\n    ) {\n      for (const cursor of vimState.cursors) {\n        if (/^\\s+$/.test(vimState.document.lineAt(cursor.stop).text)) {\n          vimState.recordedState.transformer.delete(\n            new vscode.Range(cursor.stop.getLineBegin(), cursor.stop.getLineEnd())\n          );\n        }\n      }\n    }\n    await vimState.setCurrentMode(Mode.Normal);\n\n    // If we wanted to repeat this insert (only for i and a), now is the time to do it. Insert\n    // count amount of these strings before returning back to normal mode\n    const shouldRepeatInsert =\n      vimState.recordedState.count > 1 &&\n      vimState.recordedState.actionsRun.find(\n        (a) =>\n          a instanceof CommandInsertAtCursor ||\n          a instanceof CommandInsertAfterCursor ||\n          a instanceof CommandInsertAtLineBegin ||\n          a instanceof CommandInsertAtLineEnd ||\n          a instanceof CommandInsertAtFirstCharacter ||\n          a instanceof CommandInsertAtLastChange\n      ) !== undefined;\n\n    // If this is the type to repeat insert, do this now\n    if (shouldRepeatInsert) {\n      const changeAction = vimState.recordedState.actionsRun\n        .slice()\n        .reverse()\n        .find((a) => a instanceof DocumentContentChangeAction);\n      if (changeAction instanceof DocumentContentChangeAction) {\n        // Add count amount of inserts in the case of 4i=<esc>\n        // TODO: A few actions such as <C-t> should be repeated, but are not\n        for (let i = 0; i < vimState.recordedState.count - 1; i++) {\n          // If this is the last transform, move cursor back one character\n          const positionDiff =\n            i === vimState.recordedState.count - 2\n              ? PositionDiff.offset({ character: -1 })\n              : PositionDiff.identity();\n\n          // Add a transform containing the change\n          vimState.recordedState.transformer.addTransformation(\n            changeAction.getTransformation(positionDiff)\n          );\n        }\n      }\n    }\n\n    if (vimState.historyTracker.currentContentChanges.length > 0) {\n      vimState.historyTracker.lastContentChanges = vimState.historyTracker.currentContentChanges;\n      vimState.historyTracker.currentContentChanges = [];\n    }\n\n    if (vimState.isFakeMultiCursor) {\n      vimState.cursors = [vimState.cursors[0]];\n      vimState.isFakeMultiCursor = false;\n    }\n  }\n}\n\n@RegisterAction\nexport class CommandInsertPreviousText extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-a>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get('.');\n    if (\n      register === undefined ||\n      !(register.text instanceof RecordedState) ||\n      !register.text.actionsRun\n    ) {\n      throw VimError.fromCode(ErrorCode.NoInsertedTextYet);\n    }\n\n    const recordedState = register.text.clone();\n\n    // The first action is entering Insert Mode, which is not necessary in this case\n    recordedState.actionsRun.shift();\n\n    // The last action is leaving Insert Mode, which is not necessary in this case\n    recordedState.actionsRun.pop();\n\n    if (recordedState.actionsRun?.[0] instanceof ArrowsInInsertMode) {\n      // Note, arrow keys are the only Insert action command that can't be repeated here as far as @rebornix knows.\n      recordedState.actionsRun.shift();\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replayRecordedState',\n      recordedState,\n    });\n  }\n}\n\n@RegisterAction\nclass CommandInsertPreviousTextAndQuit extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-shift+2>']; // <C-@>\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandInsertPreviousText().exec(position, vimState);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\nabstract class IndentCommand extends BaseCommand {\n  modes = [Mode.Insert];\n  abstract readonly delta: number;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const line = vimState.document.lineAt(position);\n    const tabSize = Number(vimState.editor.options.tabSize);\n    const indentationWidth = TextEditor.getIndentationLevel(line.text, tabSize);\n    const newIndentationWidth = (Math.floor(indentationWidth / tabSize) + this.delta) * tabSize;\n\n    vimState.recordedState.transformer.replace(\n      new vscode.Range(\n        position.getLineBegin(),\n        position.with({ character: line.firstNonWhitespaceCharacterIndex })\n      ),\n      TextEditor.setIndentationLevel(\n        line.text,\n        newIndentationWidth,\n        vimState.editor.options.insertSpaces as boolean\n      ).match(/^(\\s*)/)![1]\n    );\n  }\n}\n\n@RegisterAction\nclass IncreaseIndent extends IndentCommand {\n  keys = ['<C-t>'];\n  override readonly delta = 1;\n}\n@RegisterAction\nclass DecreaseIndent extends IndentCommand {\n  keys = ['<C-d>'];\n  override readonly delta = -1;\n}\n\n@RegisterAction\nexport class CommandBackspaceInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<BS>'], ['<C-h>']];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.vscodeCommand('deleteLeft');\n  }\n}\n\n@RegisterAction\nclass CommandDeleteInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Del>'];\n\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.vscodeCommand('deleteRight');\n  }\n}\n\n@RegisterAction\nexport class CommandInsertInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<character>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const char = this.keysPressed[this.keysPressed.length - 1];\n\n    let text = char;\n\n    if (char.length === 1) {\n      const prevHighSurrogate =\n        vimState.modeData.mode === Mode.Insert ? vimState.modeData.highSurrogate : undefined;\n\n      if (isHighSurrogate(char.charCodeAt(0))) {\n        vimState.setModeData({\n          mode: Mode.Insert,\n          highSurrogate: char,\n        });\n\n        if (prevHighSurrogate === undefined) return;\n        text = prevHighSurrogate;\n      } else {\n        if (isLowSurrogate(char.charCodeAt(0)) && prevHighSurrogate !== undefined) {\n          text = prevHighSurrogate + char;\n        }\n\n        vimState.setModeData({\n          mode: Mode.Insert,\n          highSurrogate: undefined,\n        });\n      }\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text,\n      isMultiCursor: vimState.isMultiCursor,\n    });\n  }\n\n  public override toString(): string {\n    return this.keysPressed[this.keysPressed.length - 1];\n  }\n}\n\n@RegisterAction\nclass CommandInsertDigraph extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-k>', '<any>', '<any>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const digraph = this.keysPressed.slice(1, 3).join('');\n    const reverseDigraph = digraph.split('').reverse().join('');\n    let charCodes = (DefaultDigraphs[digraph] ||\n      DefaultDigraphs[reverseDigraph] ||\n      configuration.digraphs[digraph] ||\n      configuration.digraphs[reverseDigraph])[1];\n    if (!(charCodes instanceof Array)) {\n      charCodes = [charCodes];\n    }\n    const char = String.fromCharCode(...charCodes);\n    vimState.recordedState.transformer.insert(position, char);\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.doesActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, 3).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    return (\n      chars in configuration.digraphs ||\n      reverseChars in configuration.digraphs ||\n      chars in DefaultDigraphs ||\n      reverseChars in DefaultDigraphs\n    );\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!super.couldActionApply(vimState, keysPressed)) {\n      return false;\n    }\n    const chars = keysPressed.slice(1, keysPressed.length).join('');\n    const reverseChars = chars.split('').reverse().join('');\n    if (chars.length > 0) {\n      const predicate = (digraph: string) => {\n        const digraphChars = digraph.substring(0, chars.length);\n        return chars === digraphChars || reverseChars === digraphChars;\n      };\n      const match =\n        Object.keys(configuration.digraphs).find(predicate) ||\n        Object.keys(DefaultDigraphs).find(predicate);\n      return match !== undefined;\n    }\n    return true;\n  }\n}\n\n@RegisterAction\nclass CommandInsertRegisterContent extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-r>', '<character>'];\n  override isCompleteAction = false;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (!Register.isValidRegister(this.keysPressed[1])) {\n      return;\n    }\n\n    const register = await Register.get(this.keysPressed[1], this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, this.keysPressed[1])\n      );\n      return;\n    }\n\n    if (register.text instanceof RecordedState) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'macro',\n        register: vimState.recordedState.registerName,\n        replay: 'keystrokes',\n      });\n\n      return;\n    }\n\n    let text = register.text;\n    if (register.registerMode === RegisterMode.LineWise && !vimState.isMultiCursor) {\n      text += '\\n';\n    }\n\n    vimState.recordedState.transformer.insert(position, text);\n  }\n}\n\n@RegisterAction\nclass CommandOneNormalCommandInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-o>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.returnToInsertAfterCommand = true;\n    vimState.actionCount = 0;\n    await new CommandEscInsertMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CommandCtrlW extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-w>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.isAtDocumentBegin()) {\n      return;\n    }\n\n    let wordBegin: Position;\n    if (position.isInLeadingWhitespace(vimState.document)) {\n      wordBegin = position.getLineBegin();\n    } else if (position.isLineBeginning()) {\n      wordBegin = position.getUp().getLineEnd();\n    } else {\n      wordBegin = position.prevWordStart(vimState.document);\n    }\n\n    vimState.recordedState.transformer.delete(new vscode.Range(wordBegin, position));\n\n    vimState.cursorStopPosition = wordBegin;\n  }\n}\n\n@RegisterAction\nexport class InsertCharAbove extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-y>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line === 0) {\n      return;\n    }\n\n    const charPos = position.getUp();\n    if (charPos.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n\n    vimState.recordedState.transformer.insert(position, char);\n  }\n}\n\n@RegisterAction\nexport class InsertCharBelow extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-e>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (position.line >= vimState.document.lineCount - 1) {\n      return;\n    }\n\n    const charPos = position.getDown();\n    if (charPos.isLineEnd()) {\n      return;\n    }\n\n    const char = vimState.document.getText(new vscode.Range(charPos, charPos.getRight()));\n\n    vimState.recordedState.transformer.insert(position, char);\n  }\n}\n\n@RegisterAction\nclass CommandCtrlUInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-u>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    let start: Position;\n    if (position.character === 0) {\n      start = position.getLeftThroughLineBreaks(true);\n    } else if (position.isInLeadingWhitespace(vimState.document)) {\n      start = position.getLineBegin();\n    } else {\n      start = position.getLineBeginRespectingIndent(vimState.document);\n    }\n\n    vimState.recordedState.transformer.delete(new vscode.Range(start, position));\n\n    vimState.cursorStopPosition = start;\n    vimState.cursorStartPosition = start;\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteDown extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-n>'], ['<C-j>']];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('selectNextSuggestion');\n  }\n}\n\n@RegisterAction\nclass CommandNavigateAutocompleteUp extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-p>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('selectPrevSuggestion');\n  }\n}\n\n@RegisterAction\nclass CommandCtrlVInInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-v>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const clipboard = await Register.get('*', this.multicursorIndex);\n    const text = clipboard?.text instanceof RecordedState ? undefined : clipboard?.text;\n\n    if (text) {\n      vimState.recordedState.transformer.insert(vimState.cursorStopPosition, text);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandShowLineAutocomplete extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-x>', '<C-l>'];\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await lineCompletionProvider.showLineCompletionsQuickPick(position, vimState);\n  }\n}\n\n@RegisterAction\nclass NewLineInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = [['<C-j>'], ['<C-m>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.recordedState.transformer.insert(\n      position,\n      '\\n',\n      PositionDiff.offset({ character: -1 })\n    );\n  }\n}\n\n@RegisterAction\nclass CommandReplaceAtCursorFromInsertMode extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<Insert>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await new CommandReplaceAtCursorFromNormalMode().exec(position, vimState);\n  }\n}\n\n@RegisterAction\nclass CreateUndoPoint extends BaseCommand {\n  modes = [Mode.Insert];\n  keys = ['<C-g>', 'u'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position, TextDocument } from 'vscode';\nimport { laterOf, PositionDiff, sorted } from '../../common/motion/position';\nimport { configuration } from '../../configuration/configuration';\nimport { isVisualMode, Mode } from '../../mode/mode';\nimport { Register, RegisterMode, IRegisterContent } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport { reportLinesChanged } from '../../util/statusBarTextUtils';\nimport { BaseCommand, RegisterAction } from '../base';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Cursor } from '../../common/motion/cursor';\nimport { Transformation } from '../../transformations/transformations';\n\nfunction firstNonBlankChar(text: string): number {\n  return text.match(/\\S/)?.index ?? 0;\n}\n\nabstract class BasePutCommand extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override createsUndoPoint = true;\n\n  protected overwritesRegisterWithSelection = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const register = await Register.get(vimState.recordedState.registerName, this.multicursorIndex);\n    if (register === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.NothingInRegister, vimState.recordedState.registerName)\n      );\n      return;\n    }\n\n    const count = vimState.recordedState.count || 1;\n\n    const mode =\n      vimState.currentMode === Mode.CommandlineInProgress ? Mode.Normal : vimState.currentMode;\n    const registerMode = this.getRegisterMode(register);\n\n    const replaceRange = this.getReplaceRange(mode, vimState.cursors[0], registerMode);\n\n    let text = this.getRegisterText(mode, register, count);\n    if (this.shouldAdjustIndent(mode, registerMode)) {\n      let lineToMatch: number | undefined;\n      if (mode === Mode.VisualLine) {\n        const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n        if (end.line < vimState.document.lineCount - 1) {\n          lineToMatch = end.line + 1;\n        } else if (start.line > 0) {\n          lineToMatch = start.line - 1;\n        }\n      } else {\n        lineToMatch = position.line;\n      }\n      text = this.adjustIndent(\n        lineToMatch !== undefined ? vimState.document.lineAt(lineToMatch).text : '',\n        text\n      );\n    }\n\n    const newCursorPosition = this.getCursorPosition(\n      vimState.document,\n      mode,\n      replaceRange,\n      registerMode,\n      count,\n      text\n    );\n\n    vimState.recordedState.transformer.moveCursor(\n      PositionDiff.exactPosition(newCursorPosition),\n      this.multicursorIndex ?? 0\n    );\n\n    if (registerMode === RegisterMode.LineWise) {\n      text = this.adjustLinewiseRegisterText(mode, text);\n    }\n\n    for (const transformation of this.getTransformations(\n      vimState.document,\n      mode,\n      replaceRange,\n      registerMode,\n      text\n    )) {\n      vimState.recordedState.transformer.addTransformation(transformation);\n    }\n\n    // We do not run this in multi-cursor mode as it will overwrite the register for upcoming put iterations\n    if (isVisualMode(mode) && !vimState.isMultiCursor) {\n      // After using \"p\" or \"P\" in Visual mode the text that was put will be selected (from Vim's \":help gv\").\n      vimState.lastVisualSelection = {\n        mode,\n        start: replaceRange.start,\n        end: replaceRange.start.advancePositionByText(text),\n      };\n\n      if (this.overwritesRegisterWithSelection) {\n        vimState.recordedState.registerName = configuration.useSystemClipboard ? '*' : '\"';\n        Register.put(\n          vimState,\n          vimState.document.getText(replaceRange),\n          this.multicursorIndex,\n          true\n        );\n      }\n    }\n\n    // Report lines changed\n    let numNewlinesAfterPut = text.split('\\n').length;\n    if (registerMode === RegisterMode.LineWise) {\n      numNewlinesAfterPut--;\n    }\n    reportLinesChanged(numNewlinesAfterPut, vimState);\n\n    const isLastCursor =\n      !vimState.isMultiCursor || vimState.cursors.length - 1 === this.multicursorIndex;\n    // Place the cursor back into normal mode after all puts are completed\n    if (isLastCursor) {\n      await vimState.setCurrentMode(Mode.Normal);\n    }\n  }\n\n  private getRegisterText(mode: Mode, register: IRegisterContent, count: number): string {\n    if (register.text instanceof RecordedState) {\n      return register.text.actionsRun\n        .map((action) => action.keysPressed.join(''))\n        .join('')\n        .repeat(count);\n    }\n\n    if (register.registerMode === RegisterMode.CharacterWise) {\n      return mode === Mode.VisualLine\n        ? Array(count).fill(register.text).join('\\n')\n        : register.text.repeat(count);\n    } else if (register.registerMode === RegisterMode.LineWise || mode === Mode.VisualLine) {\n      return Array(count).fill(register.text).join('\\n');\n    } else if (register.registerMode === RegisterMode.BlockWise) {\n      const lines = register.text.split('\\n');\n      const longestLength = Math.max(...lines.map((line) => line.length));\n      return lines\n        .map((line) => {\n          const space = longestLength - line.length;\n          const lineWithSpace = line + ' '.repeat(space);\n          return lineWithSpace.repeat(count - 1) + line;\n        })\n        .join('\\n');\n    } else {\n      throw new Error(`Unexpected RegisterMode ${register.registerMode}`);\n    }\n  }\n\n  private adjustIndent(lineToMatch: string, text: string): string {\n    const lines = text.split('\\n');\n\n    // Adjust indent to current line\n    const tabSize = configuration.tabstop; // TODO: Use `editor.options.tabSize`, I think\n    const indentationWidth = TextEditor.getIndentationLevel(lineToMatch, tabSize);\n    const firstLineIdentationWidth = TextEditor.getIndentationLevel(lines[0], tabSize);\n\n    return lines\n      .map((line) => {\n        const currentIdentationWidth = TextEditor.getIndentationLevel(line, tabSize);\n        const newIndentationWidth =\n          currentIdentationWidth - firstLineIdentationWidth + indentationWidth;\n\n        // TODO: Use `editor.options.insertSpaces`, I think\n        return TextEditor.setIndentationLevel(line, newIndentationWidth, configuration.expandtab);\n      })\n      .join('\\n');\n  }\n\n  private getTransformations(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    text: string\n  ): Transformation[] {\n    // Pasting block-wise content is very different, except in VisualLine mode, where it works exactly like line-wise\n    if (registerMode === RegisterMode.BlockWise && mode !== Mode.VisualLine) {\n      const transformations: Transformation[] = [];\n      const lines = text.split('\\n');\n      const lineCount = Math.max(lines.length, replaceRange.end.line - replaceRange.start.line + 1);\n      const longestLength = Math.max(...lines.map((line) => line.length));\n\n      // Only relevant for Visual mode\n      // If we replace 2 newlines, subsequent transformations need to take that into account (otherwise we get overlaps)\n      let deletedNewlines = 0;\n\n      for (let idx = 0; idx < lineCount; idx++) {\n        const lineText = lines[idx] ?? '';\n\n        let range: vscode.Range;\n        if (mode === Mode.VisualBlock) {\n          if (replaceRange.start.line + idx > replaceRange.end.line) {\n            const pos = replaceRange.start.with({ line: replaceRange.start.line + idx });\n            range = new vscode.Range(pos, pos);\n          } else {\n            range = new vscode.Range(\n              replaceRange.start.with({ line: replaceRange.start.line + idx }),\n              replaceRange.end.with({ line: replaceRange.start.line + idx })\n            );\n          }\n        } else {\n          if (idx > 0) {\n            const pos = replaceRange.start.with({\n              line: replaceRange.start.line + idx + deletedNewlines,\n            });\n            range = new vscode.Range(pos, pos);\n          } else {\n            range = new vscode.Range(replaceRange.start, replaceRange.end);\n            deletedNewlines = document.getText(range).split('\\n').length - 1;\n          }\n        }\n\n        const lineNumber = replaceRange.start.line + idx;\n        if (lineNumber > document.lineCount - 1) {\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: '\\n' + ' '.repeat(replaceRange.start.character) + lineText,\n          });\n        } else {\n          const lineLength = document.lineAt(lineNumber).text.length;\n          const leftPadding = Math.max(replaceRange.start.character - lineLength, 0);\n          let rightPadding = 0;\n          if (\n            mode !== Mode.VisualBlock &&\n            ((lineNumber <= replaceRange.end.line && replaceRange.end.character < lineLength) ||\n              (lineNumber > replaceRange.end.line && replaceRange.start.character < lineLength))\n          ) {\n            rightPadding = longestLength - lineText.length;\n          }\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: ' '.repeat(leftPadding) + lineText + ' '.repeat(rightPadding),\n          });\n        }\n      }\n      return transformations;\n    }\n\n    if (mode === Mode.Normal || mode === Mode.Visual || mode === Mode.VisualLine) {\n      return [\n        {\n          type: 'replaceText',\n          range: replaceRange,\n          text,\n        },\n      ];\n    } else if (mode === Mode.VisualBlock) {\n      const transformations: Transformation[] = [];\n      if (registerMode === RegisterMode.CharacterWise) {\n        for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n          const range = new vscode.Range(\n            new Position(line, replaceRange.start.character),\n            new Position(line, replaceRange.end.character)\n          );\n          const lineText = !text.includes('\\n') || line === replaceRange.start.line ? text : '';\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: lineText,\n          });\n        }\n      } else if (registerMode === RegisterMode.LineWise) {\n        // Weird case: first delete the block...\n        for (let line = replaceRange.start.line; line <= replaceRange.end.line; line++) {\n          const range = new vscode.Range(\n            new Position(line, replaceRange.start.character),\n            new Position(line, replaceRange.end.character)\n          );\n          transformations.push({\n            type: 'replaceText',\n            range,\n            text: '',\n          });\n        }\n\n        // ...then paste the lines before/after the block\n        const insertPos = this.putBefore()\n          ? new Position(replaceRange.start.line, 0)\n          : new Position(replaceRange.end.line, 0).getLineEnd();\n        transformations.push({\n          type: 'replaceText',\n          range: new vscode.Range(insertPos, insertPos),\n          text,\n        });\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n      return transformations;\n    } else {\n      throw new Error(`Unexpected Mode ${mode}`);\n    }\n  }\n\n  protected abstract putBefore(): boolean;\n\n  protected abstract getRegisterMode(register: IRegisterContent): RegisterMode;\n\n  protected abstract getReplaceRange(\n    mode: Mode,\n    cursor: Cursor,\n    registerMode: RegisterMode\n  ): vscode.Range;\n\n  protected abstract adjustLinewiseRegisterText(mode: Mode, text: string): string;\n\n  protected abstract shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean;\n\n  protected abstract getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position;\n}\n\n@RegisterAction\nclass PutCommand extends BasePutCommand {\n  keys: string[] | string[][] = ['p'];\n\n  protected putBefore(): boolean {\n    return false;\n  }\n\n  protected getRegisterMode(register: IRegisterContent): RegisterMode {\n    return register.registerMode;\n  }\n\n  protected getReplaceRange(mode: Mode, cursor: Cursor, registerMode: RegisterMode): vscode.Range {\n    if (mode === Mode.Normal) {\n      let pos: Position;\n      if (registerMode === RegisterMode.CharacterWise || registerMode === RegisterMode.BlockWise) {\n        pos = cursor.stop.getRight();\n      } else if (registerMode === RegisterMode.LineWise) {\n        pos = cursor.stop.getLineEnd();\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n      return new vscode.Range(pos, pos);\n    } else if (mode === Mode.Visual) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start, end.getRight());\n    } else if (mode === Mode.VisualLine) {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start.getLineBegin(), end.getLineEnd());\n    } else {\n      const [start, end] = sorted(cursor.start, cursor.stop);\n      return new vscode.Range(start, end.getRight());\n    }\n  }\n\n  protected adjustLinewiseRegisterText(mode: Mode, text: string): string {\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      return '\\n' + text;\n    } else if (mode === Mode.Visual) {\n      return '\\n' + text + '\\n';\n    } else {\n      return text;\n    }\n  }\n\n  protected shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean {\n    return false;\n  }\n\n  protected getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position {\n    const rangeStart = replaceRange.start;\n    if (mode === Mode.Normal || mode === Mode.Visual) {\n      if (registerMode === RegisterMode.CharacterWise) {\n        return text.includes('\\n') ? rangeStart : rangeStart.advancePositionByText(text).getLeft();\n      } else if (registerMode === RegisterMode.LineWise) {\n        return new Position(rangeStart.line + 1, firstNonBlankChar(text));\n      } else if (registerMode === RegisterMode.BlockWise) {\n        return rangeStart;\n      } else {\n        throw new Error(`Unexpected RegisterMode ${registerMode}`);\n      }\n    } else if (mode === Mode.VisualLine) {\n      return rangeStart.with({ character: firstNonBlankChar(text) });\n    } else if (mode === Mode.VisualBlock) {\n      if (registerMode === RegisterMode.LineWise) {\n        return new Position(replaceRange.end.line + 1, firstNonBlankChar(text));\n      } else if (registerMode === RegisterMode.BlockWise) {\n        return rangeStart;\n      } else {\n        return rangeStart.with({ character: rangeStart.character + text.length - 1 });\n      }\n    } else {\n      throw new Error(`Unexpected Mode ${mode}`);\n    }\n  }\n}\n\n@RegisterAction\nclass PutBeforeCommand extends PutCommand {\n  override keys: string[] | string[][] = ['P'];\n\n  // Since Vim 9.0, Visual `P` does not overwrite the unnamed register with selection's contents\n  override overwritesRegisterWithSelection = false;\n\n  protected override putBefore(): boolean {\n    return true;\n  }\n\n  protected override adjustLinewiseRegisterText(mode: Mode, text: string): string {\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      return text + '\\n';\n    }\n\n    return super.adjustLinewiseRegisterText(mode, text);\n  }\n\n  protected override getReplaceRange(\n    mode: Mode,\n    cursor: Cursor,\n    registerMode: RegisterMode\n  ): vscode.Range {\n    if (mode === Mode.Normal) {\n      if (registerMode === RegisterMode.CharacterWise || registerMode === RegisterMode.BlockWise) {\n        const pos = cursor.stop;\n        return new vscode.Range(pos, pos);\n      } else if (registerMode === RegisterMode.LineWise) {\n        const pos = cursor.stop.getLineBegin();\n        return new vscode.Range(pos, pos);\n      }\n    }\n\n    return super.getReplaceRange(mode, cursor, registerMode);\n  }\n\n  protected override getCursorPosition(\n    document: TextDocument,\n    mode: Mode,\n    replaceRange: vscode.Range,\n    registerMode: RegisterMode,\n    count: number,\n    text: string\n  ): Position {\n    const rangeStart = replaceRange.start;\n    if (mode === Mode.Normal || mode === Mode.VisualBlock) {\n      if (registerMode === RegisterMode.LineWise) {\n        return rangeStart.with({ character: firstNonBlankChar(text) });\n      }\n    }\n\n    return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n  }\n}\n\nfunction PlaceCursorAfterText<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class CursorAfterText extends Base {\n    protected override getCursorPosition(\n      document: TextDocument,\n      mode: Mode,\n      replaceRange: vscode.Range,\n      registerMode: RegisterMode,\n      count: number,\n      text: string\n    ): Position {\n      const rangeStart = replaceRange.start;\n      if (mode === Mode.Normal || mode === Mode.Visual) {\n        if (registerMode === RegisterMode.CharacterWise) {\n          if (text.includes('\\n')) {\n            // Weird case: if there's a newline, the cursor goes to the same place, regardless of [count]\n            // HACK: We're undoing the repeat() here - definitely a bit janky\n            text = text.slice(0, text.length / count);\n          }\n          return rangeStart.advancePositionByText(text);\n        } else if (registerMode === RegisterMode.LineWise) {\n          let line = rangeStart.line + text.split('\\n').length;\n          if (\n            mode === Mode.Visual ||\n            (!this.putBefore() && rangeStart.line < document.lineCount - 1)\n          ) {\n            line++;\n          }\n          return new Position(line, 0);\n        } else if (registerMode === RegisterMode.BlockWise) {\n          const lines = text.split('\\n');\n          const lastLine = rangeStart.line + lines.length - 1;\n          const longestLineLength = Math.max(...lines.map((line) => line.length));\n          return new Position(lastLine, rangeStart.character + longestLineLength);\n        }\n      } else if (mode === Mode.VisualLine) {\n        return new Position(rangeStart.line + text.split('\\n').length, 0);\n      } else if (mode === Mode.VisualBlock) {\n        const lines = text.split('\\n');\n        if (registerMode === RegisterMode.LineWise) {\n          if (this.putBefore()) {\n            return new Position(rangeStart.line + lines.length, 0);\n          } else {\n            return new Position(replaceRange.end.line + lines.length + 1, 0);\n          }\n        } else if (registerMode === RegisterMode.BlockWise) {\n          return new Position(\n            replaceRange.start.line + lines.length - 1,\n            replaceRange.start.character + lines[lines.length - 1].length\n          );\n        } else {\n          return rangeStart.with({ character: rangeStart.character + text.length });\n        }\n      }\n\n      return super.getCursorPosition(document, mode, replaceRange, registerMode, count, text);\n    }\n  };\n}\n\n@RegisterAction\n@PlaceCursorAfterText\nclass GPutCommand extends PutCommand {\n  override keys = ['g', 'p'];\n}\n\n@RegisterAction\n@PlaceCursorAfterText\nclass GPutBeforeCommand extends PutBeforeCommand {\n  override keys = ['g', 'P'];\n  override overwritesRegisterWithSelection = true;\n}\n\nfunction AdjustIndent<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class AdjustedIndent extends Base {\n    protected override shouldAdjustIndent(mode: Mode, registerMode: RegisterMode): boolean {\n      return (\n        (mode === Mode.Normal || mode === Mode.VisualLine) && registerMode === RegisterMode.LineWise\n      );\n    }\n  };\n}\n\n@RegisterAction\n@AdjustIndent\nclass PutWithIndentCommand extends PutCommand {\n  override keys = [']', 'p'];\n}\n\n@RegisterAction\n@AdjustIndent\nclass PutBeforeWithIndentCommand extends PutBeforeCommand {\n  override keys = [\n    ['[', 'P'],\n    [']', 'P'],\n    ['[', 'p'],\n  ];\n}\n\nfunction ExCommand<TBase extends new (...args: any[]) => PutCommand>(Base: TBase) {\n  return class Ex extends Base {\n    private insertLine?: number;\n\n    public setInsertionLine(insertLine: number) {\n      this.insertLine = insertLine;\n    }\n\n    protected override getRegisterMode(register: IRegisterContent): RegisterMode {\n      return RegisterMode.LineWise;\n    }\n\n    protected override getReplaceRange(\n      mode: Mode,\n      cursor: Cursor,\n      registerMode: RegisterMode\n    ): vscode.Range {\n      const line = this.insertLine ?? laterOf(cursor.start, cursor.stop).line;\n      const pos = this.putBefore() ? new Position(line, 0) : new Position(line, 0).getLineEnd();\n      return new vscode.Range(pos, pos);\n    }\n\n    protected override getCursorPosition(\n      document: TextDocument,\n      mode: Mode,\n      replaceRange: vscode.Range,\n      registerMode: RegisterMode,\n      count: number,\n      text: string\n    ): Position {\n      const lines = text.split('\\n');\n      return new Position(\n        replaceRange.start.line + lines.length - (this.putBefore() ? 1 : 0),\n        firstNonBlankChar(lines[lines.length - 1])\n      );\n    }\n  };\n}\n\nexport const PutFromCmdLine = ExCommand(PutCommand);\nexport const PutBeforeFromCmdLine = ExCommand(PutBeforeCommand);\n","import { Position, Range } from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { RegisterAction, BaseCommand } from '../base';\n\n@RegisterAction\nclass ExitReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<Esc>'], ['<C-c>'], ['<C-[>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.modeData.mode !== Mode.Replace) {\n      throw new Error(`Unexpected mode ${vimState.modeData.mode} in ExitReplaceMode`);\n    }\n\n    const timesToRepeat = vimState.modeData.replaceState.timesToRepeat;\n\n    const cursorIdx = this.multicursorIndex ?? 0;\n    const changes = vimState.modeData.replaceState.getChanges(cursorIdx);\n\n    // `3Rabc` results in 'abc' replacing the next characters 2 more times\n    if (changes && timesToRepeat > 1) {\n      const newText = changes\n        .map((change) => change.after)\n        .join('')\n        .repeat(timesToRepeat - 1);\n      vimState.recordedState.transformer.replace(\n        new Range(position, position.getRight(newText.length)),\n        newText\n      );\n    } else {\n      vimState.cursorStopPosition = vimState.cursorStopPosition.getLeft();\n    }\n\n    if (this.multicursorIndex === vimState.cursors.length - 1) {\n      await vimState.setCurrentMode(Mode.Normal);\n    }\n  }\n}\n\n@RegisterAction\nclass ReplaceModeToInsertMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<Insert>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass BackspaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = [['<BS>'], ['<S-BS>'], ['<C-BS>'], ['<C-h>']];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.modeData.mode !== Mode.Replace) {\n      throw new Error(`Unexpected mode ${vimState.modeData.mode} in BackspaceInReplaceMode`);\n    }\n\n    const cursorIdx = this.multicursorIndex ?? 0;\n    const changes = vimState.modeData.replaceState.getChanges(cursorIdx);\n\n    if (changes.length === 0) {\n      // If you backspace before the beginning of where you started to replace, just move the cursor back.\n      const newPosition = position.getLeftThroughLineBreaks();\n\n      vimState.modeData.replaceState.resetChanges(cursorIdx);\n\n      vimState.cursorStopPosition = newPosition;\n      vimState.cursorStartPosition = newPosition;\n    } else {\n      const { before } = changes.pop()!;\n      if (before === '') {\n        // We've gone beyond the originally existing text; just backspace.\n        // TODO: should this use a 'deleteLeft' transformation?\n        vimState.recordedState.transformer.addTransformation({\n          type: 'deleteRange',\n          range: new Range(position.getLeftThroughLineBreaks(), position),\n        });\n      } else {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'replaceText',\n          text: before,\n          range: new Range(position.getLeft(), position),\n          diff: PositionDiff.offset({ character: -1 }),\n        });\n      }\n    }\n  }\n}\n\n@RegisterAction\nclass ReplaceInReplaceMode extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<character>'];\n  override createsUndoPoint = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (vimState.modeData.mode !== Mode.Replace) {\n      throw new Error(`Unexpected mode ${vimState.modeData.mode} in ReplaceInReplaceMode`);\n    }\n\n    const char = this.keysPressed[0];\n    const isNewLineOrTab = char === '\\n' || char === '<tab>';\n\n    const replaceRange = new Range(position, position.getRight());\n\n    let before = vimState.document.getText(replaceRange);\n    if (!position.isLineEnd() && !isNewLineOrTab) {\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        text: char,\n        range: replaceRange,\n        diff: PositionDiff.offset({ character: 1 }),\n      });\n    } else if (char === '<tab>') {\n      vimState.recordedState.transformer.delete(replaceRange);\n      vimState.recordedState.transformer.vscodeCommand('tab');\n    } else {\n      vimState.recordedState.transformer.insert(position, char);\n      before = '';\n    }\n\n    vimState.modeData.replaceState.getChanges(this.multicursorIndex ?? 0).push({\n      before,\n      after: char,\n    });\n  }\n}\n\n@RegisterAction\nclass CreateUndoPoint extends BaseCommand {\n  modes = [Mode.Replace];\n  keys = ['<C-g>', 'u'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n  }\n}\n","import * as vscode from 'vscode';\nimport { clamp } from 'lodash';\nimport { Position } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\nimport { Mode, isVisualMode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { EditorScrollDirection, EditorScrollByUnit, TextEditor } from '../../textEditor';\nimport { BaseCommand, RegisterAction } from '../base';\n\nabstract class CommandEditorScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override runsOnceForEachCountPrefix = false;\n  abstract to: EditorScrollDirection;\n  abstract by: EditorScrollByUnit;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const timesToRepeat = vimState.recordedState.count || 1;\n    const scrolloff = configuration\n      .getConfiguration('editor')\n      .get<number>('cursorSurroundingLines', 0);\n\n    const visibleRange = vimState.editor.visibleRanges[0];\n    if (visibleRange === undefined) {\n      return;\n    }\n\n    const linesAboveCursor =\n      visibleRange.end.line - vimState.cursorStopPosition.line - timesToRepeat;\n    const linesBelowCursor =\n      vimState.cursorStopPosition.line - visibleRange.start.line - timesToRepeat;\n    if (this.to === 'up' && scrolloff > linesAboveCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getUp(scrolloff - linesAboveCursor)\n        .withColumn(vimState.desiredColumn);\n    } else if (this.to === 'down' && scrolloff > linesBelowCursor) {\n      vimState.cursorStopPosition = vimState.cursorStopPosition\n        .getDown(scrolloff - linesBelowCursor)\n        .withColumn(vimState.desiredColumn);\n    }\n\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: this.to,\n        by: this.by,\n        value: timesToRepeat,\n        select: isVisualMode(vimState.currentMode),\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandCtrlE extends CommandEditorScroll {\n  keys = ['<C-e>'];\n  override preservesDesiredColumn = true;\n  to: EditorScrollDirection = 'down';\n  by: EditorScrollByUnit = 'line';\n}\n\n@RegisterAction\nclass CommandCtrlY extends CommandEditorScroll {\n  keys = ['<C-y>'];\n  override preservesDesiredColumn = true;\n  to: EditorScrollDirection = 'up';\n  by: EditorScrollByUnit = 'line';\n}\n\n/**\n * Commands like `<C-d>` and `<C-f>` act *sort* of like `<count><C-e>`, but they move\n * your cursor down and put it on the first non-whitespace character of the line.\n */\nabstract class CommandScrollAndMoveCursor extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override runsOnceForEachCountPrefix = false;\n  abstract to: EditorScrollDirection;\n\n  /**\n   * @returns the number of lines this command should move the cursor\n   */\n  protected abstract getNumLines(visibleRanges: readonly vscode.Range[]): number;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const { visibleRanges } = vimState.editor;\n    if (visibleRanges.length === 0) {\n      return;\n    }\n    const smoothScrolling = configuration\n      .getConfiguration('editor')\n      .get<boolean>('smoothScrolling', false);\n    const moveLines = (vimState.actionCount || 1) * this.getNumLines(visibleRanges);\n\n    let scrollLines = moveLines;\n    if (this.to === 'down') {\n      // This makes <C-d> less wonky when `editor.scrollBeyondLastLine` is enabled\n      scrollLines = Math.min(\n        moveLines,\n        vimState.document.lineCount - 1 - visibleRanges[visibleRanges.length - 1].end.line\n      );\n    }\n\n    if (scrollLines > 0) {\n      const args = {\n        to: this.to,\n        by: 'line',\n        value: scrollLines,\n        revealCursor: smoothScrolling,\n        select: isVisualMode(vimState.currentMode),\n      };\n      if (smoothScrolling) {\n        await vscode.commands.executeCommand('editorScroll', args);\n      } else {\n        vimState.postponedCodeViewChanges.push({\n          command: 'editorScroll',\n          args,\n        });\n      }\n    }\n\n    const newPositionLine = clamp(\n      position.line + (this.to === 'down' ? moveLines : -moveLines),\n      0,\n      vimState.document.lineCount - 1\n    );\n    vimState.cursorStopPosition = new Position(\n      newPositionLine,\n      vimState.desiredColumn\n    ).obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-b>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return visibleRanges[0].end.line - visibleRanges[0].start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveFullPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-f>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return visibleRanges[0].end.line - visibleRanges[0].start.line;\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageDown extends CommandScrollAndMoveCursor {\n  keys = ['<C-d>'];\n  to: EditorScrollDirection = 'down';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return configuration.getScrollLines(visibleRanges);\n  }\n}\n\n@RegisterAction\nclass CommandMoveHalfPageUp extends CommandScrollAndMoveCursor {\n  keys = ['<C-u>'];\n  to: EditorScrollDirection = 'up';\n\n  protected getNumLines(visibleRanges: vscode.Range[]) {\n    return configuration.getScrollLines(visibleRanges);\n  }\n}\n\n@RegisterAction\nclass CommandCenterScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'z'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n  }\n}\n\n@RegisterAction\nclass CommandCenterScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '.'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.editor.revealRange(\n      new vscode.Range(vimState.cursorStopPosition, vimState.cursorStopPosition),\n      vscode.TextEditorRevealType.InCenter\n    );\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandTopScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 't'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandTopScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '\\n'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'top',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n\n@RegisterAction\nclass CommandBottomScroll extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'b'];\n\n  override preservesDesiredColumn = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n  }\n}\n\n@RegisterAction\nclass CommandBottomScrollFirstChar extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', '-'];\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // In these modes you want to center on the cursor position\n    // This particular one moves cursor to first non blank char though\n    vimState.postponedCodeViewChanges.push({\n      command: 'revealLine',\n      args: {\n        lineNumber: position.line,\n        at: 'bottom',\n      },\n    });\n\n    // Move cursor to first char of line\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStopPosition.line\n    );\n  }\n}\n","import * as _ from 'lodash';\nimport { escapeRegExp } from 'lodash';\nimport { Position, Selection } from 'vscode';\nimport { SearchCommandLine } from '../../cmd_line/commandLine';\nimport { sorted } from '../../common/motion/position';\nimport { configuration } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { isVisualMode, Mode } from '../../mode/mode';\nimport { Register } from '../../register/register';\nimport { globalState } from '../../state/globalState';\nimport { SearchState } from '../../state/searchState';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { TextEditor } from '../../textEditor';\nimport { TextObject } from '../../textobject/textobject';\nimport { reportSearch } from '../../util/statusBarTextUtils';\nimport { SearchDirection } from '../../vimscript/pattern';\nimport { RegisterAction, BaseCommand } from '../base';\nimport { failedMovement, IMovement } from '../baseMotion';\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]#\n */\nasync function searchCurrentWord(\n  position: Position,\n  vimState: VimState,\n  direction: SearchDirection,\n  isExact: boolean\n): Promise<void> {\n  let currentWord = TextEditor.getWord(vimState.document, position);\n\n  if (currentWord) {\n    if (/\\W/.test(currentWord[0]) || /\\W/.test(currentWord[currentWord.length - 1])) {\n      // TODO: this kind of sucks. JS regex does not consider the boundary between a special\n      // character and whitespace to be a \"word boundary\", so we can't easily do an exact search.\n      isExact = false;\n    }\n\n    if (isExact) {\n      currentWord = _.escapeRegExp(currentWord);\n    }\n    // If the search is going left then use `getWordLeft()` on position to start\n    // at the beginning of the word. This ensures that any matches happen\n    // outside of the currently selected word.\n    const searchStartCursorPosition =\n      direction === SearchDirection.Backward\n        ? vimState.cursorStopPosition.prevWordStart(vimState.document, { inclusive: true })\n        : vimState.cursorStopPosition;\n\n    await createSearchStateAndMoveToMatch({\n      needle: currentWord,\n      vimState,\n      direction,\n      isExact,\n      searchStartCursorPosition,\n    });\n  } else {\n    StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NoStringUnderCursor));\n  }\n}\n\n/**\n * Search for the word under the cursor; used by [g]* and [g]# in visual mode when `visualstar` is enabled\n */\nasync function searchCurrentSelection(vimState: VimState, direction: SearchDirection) {\n  const currentSelection = vimState.document.getText(vimState.editor.selection);\n\n  // Go back to Normal mode, otherwise the selection grows to the next match.\n  await vimState.setCurrentMode(Mode.Normal);\n\n  const [start, end] = sorted(vimState.cursorStartPosition, vimState.cursorStopPosition);\n\n  // Ensure that any matches happen outside of the currently selected word.\n  const searchStartCursorPosition =\n    direction === SearchDirection.Backward ? start.getLeft() : end.getRight();\n\n  await createSearchStateAndMoveToMatch({\n    needle: currentSelection,\n    vimState,\n    direction,\n    isExact: false,\n    searchStartCursorPosition,\n  });\n}\n\n/**\n * Used by [g]* and [g]#\n */\nasync function createSearchStateAndMoveToMatch(args: {\n  needle: string;\n  vimState: VimState;\n  direction: SearchDirection;\n  isExact: boolean;\n  searchStartCursorPosition: Position;\n}): Promise<void> {\n  const { needle, vimState, isExact } = args;\n\n  if (needle.length === 0) {\n    return;\n  }\n\n  const escapedNeedle = escapeRegExp(needle).replace('/', '\\\\/');\n  const searchString = isExact ? `\\\\<${escapedNeedle}\\\\>` : escapedNeedle;\n\n  // Start a search for the given term.\n  globalState.searchState = new SearchState(\n    args.direction,\n    vimState.cursorStopPosition,\n    searchString,\n    { ignoreSmartcase: true }\n  );\n  Register.setReadonlyRegister('/', globalState.searchState.searchString);\n  SearchCommandLine.addSearchStateToHistory(globalState.searchState);\n\n  // Turn one of the highlighting flags back on (turned off with :nohl)\n  globalState.hl = true;\n\n  const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n    vimState,\n    args.searchStartCursorPosition\n  );\n  if (nextMatch) {\n    vimState.cursorStopPosition = nextMatch.pos;\n\n    reportSearch(\n      nextMatch.index,\n      globalState.searchState.getMatchRanges(vimState).length,\n      vimState\n    );\n  } else {\n    StatusBar.displayError(\n      vimState,\n      VimError.fromCode(\n        args.direction === SearchDirection.Forward\n          ? ErrorCode.SearchHitBottom\n          : ErrorCode.SearchHitTop,\n        globalState.searchState.searchString\n      )\n    );\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactForward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['*'];\n  override actionType = 'motion' as const;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode) && configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Forward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Forward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordForward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '*'];\n  override actionType = 'motion' as const;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Forward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordExactBackward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['#'];\n  override actionType = 'motion' as const;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode) && configuration.visualstar) {\n      await searchCurrentSelection(vimState, SearchDirection.Backward);\n    } else {\n      await searchCurrentWord(position, vimState, SearchDirection.Backward, true);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandSearchCurrentWordBackward extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', '#'];\n  override actionType = 'motion' as const;\n  override runsOnceForEachCountPrefix = true;\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await searchCurrentWord(position, vimState, SearchDirection.Backward, false);\n  }\n}\n\n@RegisterAction\nclass CommandSearchForwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['/'];\n  override actionType = 'motion' as const;\n  override isJump = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.SearchInProgressMode);\n  }\n}\n\n@RegisterAction\nclass CommandSearchBackwards extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['?'];\n  override actionType = 'motion' as const;\n  override isJump = true;\n  override runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // TODO: Better VimState API than this...\n    await vimState.setModeData({\n      mode: Mode.SearchInProgressMode,\n      commandLine: new SearchCommandLine(vimState, '', SearchDirection.Backward),\n      firstVisibleLineBeforeSearch: vimState.editor.visibleRanges[0].start.line,\n    });\n  }\n}\n\nabstract class SearchObject extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected abstract readonly direction: SearchDirection;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const searchState = globalState.searchState;\n    if (!searchState || searchState.searchString === '') {\n      return failedMovement(vimState);\n    }\n\n    const newSearchState = new SearchState(\n      this.direction,\n      vimState.cursorStopPosition,\n      searchState.searchString,\n      {}\n    );\n\n    // At first, try to search for current word, and stop searching if matched.\n    // Try to search for the next word if not matched or\n    // if the cursor is at the end of a match string in visual-mode.\n    let result = newSearchState.findContainingMatchRange(vimState, vimState.cursorStopPosition);\n    if (\n      result &&\n      vimState.currentMode === Mode.Visual &&\n      vimState.cursorStopPosition.isEqual(result.range.end.getLeftThroughLineBreaks())\n    ) {\n      result = undefined;\n    }\n\n    if (result === undefined) {\n      // Try to search for the next word\n      result = newSearchState.getNextSearchMatchRange(vimState, vimState.cursorStopPosition);\n      if (result === undefined) {\n        return failedMovement(vimState);\n      }\n    }\n\n    reportSearch(result.index, searchState.getMatchRanges(vimState).length, vimState);\n\n    const [start, stop] = [\n      vimState.currentMode === Mode.Normal ? result.range.start : vimState.cursorStopPosition,\n      result.range.end.getLeftThroughLineBreaks(),\n    ];\n\n    // Move the cursor, this is a bit hacky...\n    vimState.cursorStartPosition = start;\n    vimState.cursorStopPosition = stop;\n    vimState.editor.selection = new Selection(start, stop);\n\n    await vimState.setCurrentMode(Mode.Visual);\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    return this.execAction(position, vimState);\n  }\n}\n\n@RegisterAction\nclass SearchObjectForward extends SearchObject {\n  keys = ['g', 'n'];\n  direction = SearchDirection.Forward;\n}\n\n@RegisterAction\nclass SearchObjectBackward extends SearchObject {\n  keys = ['g', 'N'];\n  direction = SearchDirection.Backward;\n}\n","import { Position } from 'vscode';\nimport { OnlyCommand } from '../../cmd_line/commands/only';\nimport { QuitCommand } from '../../cmd_line/commands/quit';\nimport { Mode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { RegisterAction, BaseCommand } from '../base';\n\n@RegisterAction\nclass CommandQuit extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'q'],\n    ['<C-w>', '<C-q>'],\n    ['<C-w>', 'c'],\n    ['<C-w>', '<C-c>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new QuitCommand({}).execute(vimState);\n  }\n}\n\n@RegisterAction\nclass CommandOnly extends BaseCommand {\n  modes = [Mode.Normal];\n  keys = [\n    ['<C-w>', 'o'],\n    ['<C-w>', '<C-o>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    new OnlyCommand().execute(vimState);\n  }\n}\n\n@RegisterAction\nclass MoveToRightPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'l'],\n    ['<C-w>', '<right>'],\n    ['<C-w>', '<C-l>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateRight',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLowerPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'j'],\n    ['<C-w>', '<down>'],\n    ['<C-w>', '<C-j>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateDown',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToUpperPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'k'],\n    ['<C-w>', '<up>'],\n    ['<C-w>', '<C-k>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateUp',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass MoveToLeftPane extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'h'],\n    ['<C-w>', '<left>'],\n    ['<C-w>', '<C-h>'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateLeft',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass CycleThroughPanes extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', '<C-w>'],\n    ['<C-w>', 'w'],\n  ];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.navigateEditorGroups',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass VerticalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 'v'],\n    ['<C-w>', '<C-v>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditor',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass OrthogonalSplit extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = [\n    ['<C-w>', 's'],\n    ['<C-w>', '<C-s>'],\n  ];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.splitEditorOrthogonal',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass EvenPaneWidths extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '='];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.evenEditorWidths',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass IncreasePaneWidth extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.increaseViewWidth',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass DecreasePaneWidth extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '<'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.decreaseViewWidth',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass IncreasePaneHeight extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '+'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.increaseViewHeight',\n      args: {},\n    });\n  }\n}\n\n@RegisterAction\nclass DecreasePaneHeight extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['<C-w>', '-'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    vimState.postponedCodeViewChanges.push({\n      command: 'workbench.action.decreaseViewHeight',\n      args: {},\n    });\n  }\n}\n","import './base';\nimport './operator';\nimport './motion';\nimport '../textobject/textobject';\n\n// commands\nimport './commands/insert';\nimport './commands/replace';\nimport './commands/actions';\nimport './commands/commandLine';\nimport './commands/search';\nimport './commands/put';\nimport './commands/digraphs';\nimport './commands/window';\nimport './commands/fold';\nimport './commands/scroll';\n","import { RegisterAction } from '../../base';\nimport { VimState } from '../../../state/vimState';\nimport { BaseMovement, failedMovement, IMovement } from '../../baseMotion';\nimport { Position, TextDocument } from 'vscode';\n\ntype Type = 'function' | 'class';\ntype Edge = 'start' | 'end';\ntype Direction = 'next' | 'prev';\n\ninterface LineInfo {\n  line: number;\n  indentation: number;\n  text: string;\n}\n\ninterface StructureElement {\n  type: Type;\n  start: Position;\n  end: Position;\n}\n\n// Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\nlet supportsLookbehind = true;\ntry {\n  // tslint:disable-next-line\n  new RegExp('(?<=x)');\n} catch {\n  supportsLookbehind = false;\n}\n\n/*\n * Utility class used to parse the lines in the document and\n * determine class and function boundaries\n *\n * The class keeps track of two positions: the ORIGINAL and the CURRENT\n * using their relative locations to make decisions.\n */\nexport class PythonDocument {\n  _document: TextDocument;\n  structure: StructureElement[];\n\n  static readonly reOnlyWhitespace = /\\S/;\n  static readonly reLastNonWhiteSpaceCharacter = supportsLookbehind\n    ? new RegExp('(?<=\\\\S)\\\\s*$')\n    : /(\\S)\\s*$/;\n  static readonly reDefOrClass = /^\\s*(def|class) /;\n\n  constructor(document: TextDocument) {\n    this._document = document;\n    const parsed = PythonDocument._parseLines(document);\n    this.structure = PythonDocument._parseStructure(parsed);\n  }\n\n  /*\n   * Generator of the lines of text in the document\n   */\n  static *lines(document: TextDocument): Generator<string> {\n    for (let index = 0; index < document.lineCount; index++) {\n      yield document.lineAt(index).text;\n    }\n  }\n\n  /*\n   * Calculate the indentation of a line of text.\n   * Lines consisting entirely of whitespace of \"starting\" with a comment are defined\n   * to have an indentation of \"undefined\".\n   */\n  static _indentation(line: string): number | undefined {\n    const index: number = line.search(PythonDocument.reOnlyWhitespace);\n\n    // Return undefined if line is empty, just whitespace, or starts with a comment\n    if (index === -1 || line[index] === '#') {\n      return undefined;\n    }\n\n    return index;\n  }\n\n  /*\n   * Parse a line of text to extract LineInfo\n   * Return undefined if the line is empty or starts with a comment\n   */\n  static _parseLine(index: number, text: string): LineInfo | undefined {\n    const indentation = this._indentation(text);\n\n    // Since indentation === 0 is a valid result we need to check for undefined explicitly\n    return indentation !== undefined ? { line: index, indentation, text } : undefined;\n  }\n\n  static _parseLines(document: TextDocument): LineInfo[] {\n    const lines = [...this.lines(document)]; // convert generator to Array\n    const infos = lines.map((text, index) => this._parseLine(index, text));\n\n    return infos.filter((x) => x) as LineInfo[]; // filter out empty/comment lines (undefined info)\n  }\n\n  static _parseStructure(lines: LineInfo[]): StructureElement[] {\n    const last = lines.length;\n    const structure: StructureElement[] = [];\n\n    for (let index = 0; index < last; index++) {\n      const info = lines[index];\n      const text = info.text;\n      const match = text.match(PythonDocument.reDefOrClass);\n\n      if (match) {\n        const type = match[1] === 'def' ? 'function' : 'class';\n\n        // Find the end of the current function/class\n        let idx = index + 1;\n\n        for (; idx < last; idx++) {\n          if (lines[idx].indentation <= info.indentation) {\n            break;\n          }\n        }\n\n        // Since we stop when we find the first line with a less indentation\n        // we pull back one line to get to the end of the function/class\n        idx--;\n\n        const endLine = lines[idx];\n\n        structure.push({\n          type,\n          start: new Position(info.line, info.indentation),\n          // Calculate position of last non-white character)\n          end: new Position(\n            endLine.line,\n            endLine.text.search(PythonDocument.reLastNonWhiteSpaceCharacter) - 1\n          ),\n        });\n      }\n    }\n\n    return structure;\n  }\n\n  /*\n   * Find the position of the specified:\n   *    type: function or class\n   *    direction: next or prev\n   *    edge: start or end\n   *\n   * With this information one can determine all of the required motions\n   */\n  find(type: Type, direction: Direction, edge: Edge, position: Position): Position | undefined {\n    // Choose the ordering method name based on direction\n    const isDirection = direction === 'next' ? 'isAfter' : 'isBefore';\n\n    // Filter function for all elements whose \"edge\" is in the correct \"direction\"\n    // relative to the cursor's position\n    const dir = (element: StructureElement) => element[edge][isDirection](position);\n\n    // Filter out elements from structure based on type and direction\n    const elements = this.structure.filter((elem) => elem.type === type).filter(dir);\n\n    if (edge === 'end') {\n      // When moving to an 'end' the elements should be started by the end position\n      elements.sort((a, b) => a.end.line - b.end.line);\n    }\n\n    // Return the first match if any exist\n    if (elements.length) {\n      // If direction === 'next' return the first element\n      // otherwise return the last element\n      const index = direction === 'next' ? 0 : elements.length - 1;\n      const element = elements[index];\n      const pos = element[edge];\n\n      // execAction MUST return a fully realized Position object created using new\n      return pos;\n    }\n\n    return undefined;\n  }\n\n  // Use PythonDocument instance to move to specified class boundary\n  static moveClassBoundary(\n    document: TextDocument,\n    position: Position,\n    vimState: VimState,\n    forward: boolean,\n    start: boolean\n  ): Position | IMovement {\n    const direction = forward ? 'next' : 'prev';\n    const edge = start ? 'start' : 'end';\n\n    return (\n      new PythonDocument(document).find('class', direction, edge, position) ??\n      failedMovement(vimState)\n    );\n  }\n}\n\n// Uses the specified findFunction to execute the motion coupled to the shortcut (keys)\nabstract class BasePythonMovement extends BaseMovement {\n  abstract type: Type;\n  abstract direction: Direction;\n  abstract edge: Edge;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.document.languageId === 'python'\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const document = vimState.document;\n    return (\n      new PythonDocument(document).find(this.type, this.direction, this.edge, position) ??\n      failedMovement(vimState)\n    );\n  }\n}\n\n@RegisterAction\nclass MovePythonNextFunctionStart extends BasePythonMovement {\n  keys = [']', 'm'];\n  type: Type = 'function';\n  direction: Direction = 'next';\n  edge: Edge = 'start';\n}\n\n@RegisterAction\nclass MovePythonPrevFunctionStart extends BasePythonMovement {\n  keys = ['[', 'm'];\n  type: Type = 'function';\n  direction: Direction = 'prev';\n  edge: Edge = 'start';\n}\n\n@RegisterAction\nclass MovePythonNextFunctionEnd extends BasePythonMovement {\n  keys = [']', 'M'];\n  type: Type = 'function';\n  direction: Direction = 'next';\n  edge: Edge = 'end';\n}\n\n@RegisterAction\nclass MovePythonPrevFunctionEnd extends BasePythonMovement {\n  keys = ['[', 'M'];\n  type: Type = 'function';\n  direction: Direction = 'prev';\n  edge: Edge = 'end';\n}\n","import * as vscode from 'vscode';\n\nimport { ChangeOperator, DeleteOperator, YankOperator } from './operator';\nimport { CursorMoveByUnit, CursorMovePosition, TextEditor } from './../textEditor';\nimport { isVisualMode, Mode } from './../mode/mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { QuoteMatcher } from './../common/matching/quoteMatcher';\nimport { RegisterAction } from './base';\nimport { RegisterMode } from './../register/register';\nimport { TagMatcher } from './../common/matching/tagMatcher';\nimport { VimState } from './../state/vimState';\nimport { configuration } from './../configuration/configuration';\nimport { shouldWrapKey } from './wrapping';\nimport { VimError, ErrorCode } from '../error';\nimport { BaseMovement, SelectionType, IMovement, isIMovement, failedMovement } from './baseMotion';\nimport { globalState } from '../state/globalState';\nimport { reportSearch } from '../util/statusBarTextUtils';\nimport { SneakForward, SneakBackward } from './plugins/sneak';\nimport { Notation } from '../configuration/notation';\nimport { StatusBar } from '../statusBar';\nimport { clamp, isHighSurrogate, isLowSurrogate } from '../util/util';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from '../textobject/paragraph';\nimport { PythonDocument } from './languages/python/motion';\nimport { Position } from 'vscode';\nimport { sorted } from '../common/motion/position';\nimport { WordType } from '../textobject/word';\nimport { CommandInsertAtCursor } from './commands/actions';\nimport { SearchDirection } from '../vimscript/pattern';\nimport { SmartQuoteMatcher, WhichQuotes } from './plugins/targets/smartQuotesMatcher';\nimport { useSmartQuotes } from './plugins/targets/targetsConfig';\nimport { ModeDataFor } from '../mode/modeData';\n\n/**\n * A movement is something like 'h', 'k', 'w', 'b', 'gg', etc.\n */\n\nexport abstract class ExpandingSelection extends BaseMovement {\n  protected override selectionType = SelectionType.Expanding;\n\n  protected override adjustPosition(position: Position, result: IMovement, lastIteration: boolean) {\n    if (!lastIteration) {\n      position = result.stop;\n    }\n    return position;\n  }\n}\n\nabstract class MoveByScreenLine extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  abstract movementType: CursorMovePosition;\n  by?: CursorMoveByUnit;\n  value: number = 1;\n\n  public override async execAction(position: Position, vimState: VimState) {\n    return this.execActionWithCount(position, vimState, 1);\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n\n    if (multicursorIndex === 0) {\n      if (vimState.currentMode === Mode.Visual) {\n        // If we change the `vimState.editor.selections` directly with the forEach\n        // for some reason vscode doesn't update them. But doing it this way does\n        // update vscode's selections.\n        vimState.editor.selections = vimState.editor.selections.map((s, i) => {\n          if (s.active.isAfter(s.anchor)) {\n            // The selection is on the right side of the cursor, while our representation\n            // considers the cursor to be the left edge, so we need to move the selection\n            // to the right place before executing the 'cursorMove' command.\n            const active = s.active.getLeftThroughLineBreaks();\n            return new vscode.Selection(s.anchor, active);\n          } else {\n            return s;\n          }\n        });\n      }\n\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: vimState.currentMode !== Mode.Normal,\n        by: this.by,\n        value: this.value * count,\n      });\n    }\n\n    /**\n     * HACK:\n     * The `cursorMove` command is handling the selection for us.\n     * So we are not following our design principal (do no real movement inside an action) here\n     */\n    if (!vimState.editor.selections[multicursorIndex]) {\n      // VS Code selections no longer have the same amount of cursors as we do. This means that\n      // two or more selections combined into one. In this case we return these cursors as they\n      // were with the removed flag so that they can be removed.\n      // TODO: does this work in VisualBlock (where cursors are not 1 to 1 with selections)?\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        removed: true,\n      };\n    }\n\n    if (vimState.currentMode === Mode.Normal) {\n      return vimState.editor.selections[multicursorIndex].active;\n    } else {\n      let start = vimState.editor.selections[multicursorIndex].anchor;\n      const stop = vimState.editor.selections[multicursorIndex].active;\n\n      // If we are moving up we need to keep getting the left of anchor/start because vscode is\n      // to the right of the character in order to include it but our positions are always on the\n      // left side of the character.\n      // Also when we switch from being before anchor to being after anchor we need to move\n      // the anchor/start to the left as well in order to include the character.\n      if (\n        (start.isAfter(stop) &&\n          vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) ||\n        (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition) &&\n          start.isBeforeOrEqual(stop))\n      ) {\n        start = start.getLeft();\n      }\n\n      return { start, stop };\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    const multicursorIndex = this.multicursorIndex ?? 0;\n    if (multicursorIndex === 0) {\n      // When we have multicursors and run a 'cursorMove' command, vscode applies that command\n      // to all cursors at the same time. So we should only run it once.\n      await vscode.commands.executeCommand('cursorMove', {\n        to: this.movementType,\n        select: true,\n        by: this.by,\n        value: this.value,\n      });\n    }\n\n    if (!vimState.editor.selections[multicursorIndex]) {\n      // Vscode selections no longer have the same amount of cursors as we do. This means that\n      // two or more selections combined into one. In this case we return these cursors as they\n      // were with the removed flag so that they can be removed.\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n        removed: true,\n      };\n    }\n\n    return {\n      start: vimState.editor.selections[multicursorIndex].start,\n      stop: vimState.editor.selections[multicursorIndex].end,\n    };\n  }\n}\n\nclass MoveUpByScreenLine extends MoveByScreenLine {\n  keys = [];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\nclass MoveDownByScreenLine extends MoveByScreenLine {\n  keys = [];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\nabstract class MoveByScreenLineMaintainDesiredColumn extends MoveByScreenLine {\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const prevDesiredColumn = vimState.desiredColumn;\n    const prevLine = vimState.editor.selection.active.line;\n\n    if (vimState.currentMode !== Mode.Normal) {\n      /**\n       * As VIM and VSCode handle the end of selection index a little\n       * differently we need to sometimes move the cursor at the end\n       * of the selection back by a character.\n       */\n      const start = vimState.editor.selection.start;\n      if (\n        (this.movementType === 'down' && position.line > start.line) ||\n        (this.movementType === 'up' && position.line < prevLine)\n      ) {\n        await vscode.commands.executeCommand('cursorMove', {\n          to: 'left',\n          select: true,\n          by: 'character',\n          value: 1,\n        });\n      }\n    }\n\n    await vscode.commands.executeCommand('cursorMove', {\n      to: this.movementType,\n      select: vimState.currentMode !== Mode.Normal,\n      by: this.by,\n      value: this.value,\n    });\n\n    if (vimState.currentMode === Mode.Normal) {\n      let returnedPos = vimState.editor.selection.active;\n      if (prevLine !== returnedPos.line) {\n        returnedPos = returnedPos.withColumn(prevDesiredColumn);\n      }\n      return returnedPos;\n    } else {\n      /**\n       * cursorMove command is handling the selection for us.\n       * So we are not following our design principal (do no real movement inside an action) here.\n       */\n      let start = vimState.editor.selection.start;\n      let stop = vimState.editor.selection.end;\n      const curPos = vimState.editor.selection.active;\n\n      // We want to swap the cursor start stop positions based on which direction we are moving, up or down\n      if (start.isEqual(curPos) && !start.isEqual(stop)) {\n        [start, stop] = [stop, start];\n        if (prevLine !== start.line) {\n          start = start.getLeft();\n        }\n      }\n\n      if (position.line !== stop.line) {\n        stop = stop.withColumn(prevDesiredColumn);\n      }\n\n      return { start, stop };\n    }\n  }\n}\n\nclass MoveDownFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  keys = [];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (position.line >= vimState.document.lineCount - 1) {\n      return position;\n    }\n    let t: Position | IMovement = position;\n    let prevLine: number = position.line;\n    let prevChar: number = position.character;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveDownByScreenLine = new MoveDownByScreenLine();\n    do {\n      t = await moveDownByScreenLine.execAction(t, vimState);\n      t = t instanceof Position ? t : t.stop;\n      const lineChanged = prevLine !== t.line;\n      // wrappedLine movement goes to eol character only when at the last line\n      // thus a column change on wrappedLine movement represents a visual last line\n      const colChanged = prevChar !== t.character;\n      if (lineChanged || !colChanged) {\n        break;\n      }\n      prevChar = t.character;\n      prevLine = t.line;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nclass MoveDown extends BaseMovement {\n  keys = [['j'], ['<down>'], ['<C-j>'], ['<C-n>']];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (\n      vimState.currentMode === Mode.Insert &&\n      this.keysPressed[0] === '<down>' &&\n      vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n      position.line === vimState.document.lineCount - 1 &&\n      vimState.editor.selection.isEmpty\n    ) {\n      // navigate history in interactive window\n      await vscode.commands.executeCommand('interactive.history.next');\n      return vimState.editor.selection.active;\n    }\n\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveDownFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveUp extends BaseMovement {\n  keys = [['k'], ['<up>'], ['<C-p>']];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (\n      vimState.currentMode === Mode.Insert &&\n      this.keysPressed[0] === '<up>' &&\n      vimState.editor.document.uri.scheme === 'vscode-interactive-input' &&\n      position.line === 0 &&\n      vimState.editor.selection.isEmpty\n    ) {\n      // navigate history in interactive window\n      await vscode.commands.executeCommand('interactive.history.previous');\n      return vimState.editor.selection.active;\n    }\n\n    if (configuration.foldfix && vimState.currentMode !== Mode.VisualBlock) {\n      return new MoveUpFoldFix().execAction(position, vimState);\n    }\n\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveUpFoldFix extends MoveByScreenLineMaintainDesiredColumn {\n  keys = [];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (position.line === 0) {\n      return position;\n    }\n    let t: Position | IMovement;\n    const prevDesiredColumn = vimState.desiredColumn;\n    const moveUpByScreenLine = new MoveUpByScreenLine();\n    do {\n      t = await moveUpByScreenLine.execAction(position, vimState);\n      t = t instanceof Position ? t : t.stop;\n    } while (t.line === position.line);\n    // fix column change at last line caused by wrappedLine movement\n    // causes cursor lag and flicker if a large repeat prefix is given to movement\n    if (t.character !== prevDesiredColumn) {\n      t = new Position(t.line, prevDesiredColumn);\n    }\n    return t;\n  }\n}\n\n@RegisterAction\nexport class ArrowsInInsertMode extends BaseMovement {\n  override modes = [Mode.Insert];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    // Moving with the arrow keys in Insert mode \"resets\" our insertion for the purpose of repeating with dot or `<C-a>`.\n    // No matter how we got into Insert mode, repeating will now be done as if we started with `i`.\n    // Note that this does not affect macros, which re-construct a list of actions based on keypresses.\n    // TODO: ACTUALLY, we should reset this only after something is typed (`Axyz<Left><Esc>.` does repeat the insertion)\n    // TODO: This also should mark an \"insertion end\" for the purpose of `<C-a>` (try `ixyz<Right><C-a>`)\n    vimState.recordedState.actionsRun = [new CommandInsertAtCursor()];\n\n    // Force an undo point to be created\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n\n    let newPosition: Position;\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = await new MoveUp(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<down>':\n        newPosition = await new MoveDown(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass ArrowsInReplaceMode extends BaseMovement {\n  override modes = [Mode.Replace];\n  keys = [['<up>'], ['<down>'], ['<left>'], ['<right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    // Force an undo point to be created\n    vimState.historyTracker.addChange(true);\n    vimState.historyTracker.finishCurrentStep();\n\n    let newPosition: Position = position;\n    switch (this.keysPressed[0]) {\n      case '<up>':\n        newPosition = await new MoveUp(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<down>':\n        newPosition = await new MoveDown(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<left>':\n        newPosition = await new MoveLeft(this.keysPressed).execAction(position, vimState);\n        break;\n      case '<right>':\n        newPosition = await new MoveRight(this.keysPressed).execAction(position, vimState);\n        break;\n      default:\n        throw new Error(`Unexpected 'arrow' key: ${this.keys[0]}`);\n    }\n    (vimState.modeData as ModeDataFor<Mode.Replace>).replaceState.resetChanges(\n      this.multicursorIndex ?? 0\n    );\n    return newPosition;\n  }\n}\n\n@RegisterAction\nclass CommandNextSearchMatch extends BaseMovement {\n  keys = ['n'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return failedMovement(vimState);\n    }\n\n    // we have to handle a special case here: searching for $ or \\n,\n    // which we approximate by positionIsEOL. In that case (but only when searching forward)\n    // we need to \"offset\" by getRight for searching the next match, otherwise we get stuck.\n    const searchForward = searchState.direction === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n    const nextMatch =\n      positionIsEOL && searchForward\n        ? searchState.getNextSearchMatchPosition(vimState, position.getRight())\n        : searchState.getNextSearchMatchPosition(vimState, position);\n\n    if (!nextMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.direction === SearchDirection.Forward\n            ? ErrorCode.SearchHitBottom\n            : ErrorCode.SearchHitTop,\n          searchState.searchString\n        )\n      );\n      return failedMovement(vimState);\n    }\n\n    reportSearch(nextMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n\n    return nextMatch.pos;\n  }\n}\n\n@RegisterAction\nclass CommandPreviousSearchMatch extends BaseMovement {\n  keys = ['N'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const searchState = globalState.searchState;\n\n    if (!searchState || searchState.searchString === '') {\n      return position;\n    }\n\n    // Turn one of the highlighting flags back on (turned off with :nohl)\n    globalState.hl = true;\n\n    if (searchState.getMatchRanges(vimState).length === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, searchState.searchString)\n      );\n      return failedMovement(vimState);\n    }\n\n    const searchForward = searchState.direction === SearchDirection.Forward;\n    const positionIsEOL = position.getRight().isEqual(position.getLineEnd());\n\n    // see implementation of n, above.\n    const prevMatch =\n      positionIsEOL && !searchForward\n        ? searchState.getNextSearchMatchPosition(\n            vimState,\n            position.getRight(),\n            SearchDirection.Backward\n          )\n        : searchState.getNextSearchMatchPosition(vimState, position, SearchDirection.Backward);\n\n    if (!prevMatch) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          searchState.direction === SearchDirection.Forward\n            ? ErrorCode.SearchHitTop\n            : ErrorCode.SearchHitBottom,\n          searchState.searchString\n        )\n      );\n      return failedMovement(vimState);\n    }\n\n    reportSearch(prevMatch.index, searchState.getMatchRanges(vimState).length, vimState);\n\n    return prevMatch.pos;\n  }\n}\n\n@RegisterAction\nclass MarkMovementBOL extends BaseMovement {\n  keys = [\"'\", '<character>'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    if (mark.isUppercaseMark && mark.document !== undefined) {\n      if (vimState.recordedState.operator && mark.document !== vimState.document) {\n        // Operators don't work across files\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      await ensureEditorIsActive(mark.document);\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, mark.position.line);\n  }\n}\n\n@RegisterAction\nclass MarkMovement extends BaseMovement {\n  keys = ['`', '<character>'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const markName = this.keysPressed[1];\n    const mark = vimState.historyTracker.getMark(markName);\n\n    if (mark === undefined) {\n      throw VimError.fromCode(ErrorCode.MarkNotSet);\n    }\n\n    if (mark.isUppercaseMark && mark.document !== undefined) {\n      if (vimState.recordedState.operator && mark.document !== vimState.document) {\n        // Operators don't work across files\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      await ensureEditorIsActive(mark.document);\n    }\n\n    return mark.position;\n  }\n}\n\n@RegisterAction\nclass NextMark extends BaseMovement {\n  keys = [']', '`'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const positions = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.isAfter(position))\n      .map((mark) => mark.position)\n      .sort((x, y) => x.compareTo(y));\n    return positions.length === 0 ? position : positions[0];\n  }\n}\n\n@RegisterAction\nclass PrevMark extends BaseMovement {\n  keys = ['[', '`'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const positions = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.isBefore(position))\n      .map((mark) => mark.position)\n      .sort((x, y) => y.compareTo(x));\n    return positions.length === 0 ? position : positions[0];\n  }\n}\n\n@RegisterAction\nclass NextMarkLinewise extends BaseMovement {\n  keys = [']', \"'\"];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const lines = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.line > position.line)\n      .map((mark) => mark.position.line);\n    const line = lines.length === 0 ? position.line : Math.min(...lines);\n    return new Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n  }\n}\n\n@RegisterAction\nclass PrevMarkLinewise extends BaseMovement {\n  keys = ['[', \"'\"];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const lines = vimState.historyTracker\n      .getLocalMarks()\n      .filter((mark) => mark.position.line < position.line)\n      .map((mark) => mark.position.line);\n    const line = lines.length === 0 ? position.line : Math.max(...lines);\n    return new Position(line, 0).getLineBeginRespectingIndent(vimState.document);\n  }\n}\n\nasync function ensureEditorIsActive(document: vscode.TextDocument) {\n  if (document !== vscode.window.activeTextEditor?.document) {\n    await vscode.window.showTextDocument(document);\n  }\n}\n\n@RegisterAction\nclass MoveLeft extends BaseMovement {\n  keys = [['h'], ['<left>'], ['<BS>'], ['<C-BS>'], ['<S-BS>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const getLeftWhile = (p: Position): Position => {\n      const line = vimState.document.lineAt(p.line).text;\n      const newPosition = p.getLeft();\n      if (newPosition.character === 0) {\n        return newPosition;\n      }\n      if (\n        isLowSurrogate(line.charCodeAt(newPosition.character)) &&\n        isHighSurrogate(line.charCodeAt(newPosition.character - 1))\n      ) {\n        return newPosition.getLeft();\n      } else {\n        return newPosition;\n      }\n    };\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getLeftThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : getLeftWhile(position);\n  }\n}\n\n@RegisterAction\nclass MoveRight extends BaseMovement {\n  keys = [['l'], ['<right>'], [' ']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const getRightWhile = (p: Position): Position => {\n      const line = vimState.document.lineAt(p.line).text;\n      const newPosition = p.getRight();\n      if (newPosition.character >= vimState.document.lineAt(newPosition.line).text.length) {\n        return newPosition;\n      }\n      if (\n        isLowSurrogate(line.charCodeAt(newPosition.character)) &&\n        isHighSurrogate(line.charCodeAt(p.character))\n      ) {\n        return newPosition.getRight();\n      } else {\n        return newPosition;\n      }\n    };\n    return shouldWrapKey(vimState.currentMode, this.keysPressed[0])\n      ? position.getRightThroughLineBreaks(\n          [Mode.Insert, Mode.Replace].includes(vimState.currentMode)\n        )\n      : getRightWhile(position);\n  }\n}\n\n@RegisterAction\nclass MoveDownNonBlank extends BaseMovement {\n  keys = [['+'], ['\\n'], ['<C-m>']];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getDown(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveUpNonBlank extends BaseMovement {\n  keys = ['-'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      position.getUp(Math.max(count, 1)).line\n    );\n  }\n}\n\n@RegisterAction\nclass MoveDownUnderscore extends BaseMovement {\n  keys = ['_'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    const pos = position.getDown(Math.max(count - 1, 0));\n    return vimState.recordedState.operator\n      ? pos\n      : TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, pos.line);\n  }\n}\n\n@RegisterAction\nclass MoveToColumn extends BaseMovement {\n  keys = ['|'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return new Position(position.line, Math.max(0, count - 1));\n  }\n}\n\n/**\n * Returns the Postion of the next instance of `char` on the line\n * @param char character to look for\n * @param count number of times to look\n * @param direction direction to look in\n */\nfunction findHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n): Position | undefined {\n  const line = vimState.document.lineAt(start);\n\n  let index = start.character;\n  while (count > 0 && index >= 0) {\n    if (direction === 'forward') {\n      index = line.text.indexOf(char, index + 1);\n    } else {\n      index = line.text.lastIndexOf(char, index - 1);\n    }\n    count--;\n  }\n\n  if (index >= 0) {\n    return new Position(start.line, index);\n  }\n\n  return undefined;\n}\n\n@RegisterAction\nclass MoveFindForward extends BaseMovement {\n  keys = ['f', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      const pos = await new SneakForward(\n        this.keysPressed.concat('\\n'),\n        this.isRepeat\n      ).execActionWithCount(position, vimState, count);\n      if (vimState.recordedState.operator && !isIMovement(pos)) {\n        return pos.getRight();\n      }\n\n      return pos;\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = findHelper(vimState, position, toFind, count, 'forward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveFindBackward extends BaseMovement {\n  keys = ['F', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    if (configuration.sneakReplacesF) {\n      return new SneakBackward(this.keysPressed.concat('\\n'), this.isRepeat).execActionWithCount(\n        position,\n        vimState,\n        count\n      );\n    }\n\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    const result = findHelper(vimState, position, toFind, count, 'backward');\n\n    vimState.lastSemicolonRepeatableMovement = new MoveFindBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveFindForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\nfunction tilHelper(\n  vimState: VimState,\n  start: Position,\n  char: string,\n  count: number,\n  direction: 'forward' | 'backward'\n) {\n  const result = findHelper(vimState, start, char, count, direction);\n  return direction === 'forward' ? result?.getLeft() : result?.getRight();\n}\n\n@RegisterAction\nclass MoveTilForward extends BaseMovement {\n  keys = ['t', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'forward');\n\n    // For t<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'forward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (vimState.recordedState.operator) {\n      result = result.getRight();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveTilBackward extends BaseMovement {\n  keys = ['T', '<character>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const toFind = Notation.ToControlCharacter(this.keysPressed[1]);\n    let result = tilHelper(vimState, position, toFind, count, 'backward');\n\n    // For T<character> vim executes ; as 2; and , as 2,\n    if (result && this.isRepeat && position.isEqual(result) && count === 1) {\n      result = tilHelper(vimState, position, toFind, 2, 'backward');\n    }\n\n    vimState.lastSemicolonRepeatableMovement = new MoveTilBackward(this.keysPressed, true);\n    vimState.lastCommaRepeatableMovement = new MoveTilForward(this.keysPressed, true);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveRepeat extends BaseMovement {\n  keys = [';'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const movement = vimState.lastSemicolonRepeatableMovement;\n    if (movement) {\n      return movement.execActionWithCount(position, vimState, count);\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveRepeatReversed extends BaseMovement {\n  keys = [','];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    const semiColonMovement = vimState.lastSemicolonRepeatableMovement;\n    const commaMovement = vimState.lastCommaRepeatableMovement;\n    if (commaMovement) {\n      const result = commaMovement.execActionWithCount(position, vimState, count);\n\n      // Make sure these don't change. Otherwise, comma's direction flips back\n      // and forth when done repeatedly. This is a bit hacky, so feel free to refactor.\n      vimState.lastSemicolonRepeatableMovement = semiColonMovement;\n      vimState.lastCommaRepeatableMovement = commaMovement;\n\n      return result;\n    }\n    return position;\n  }\n}\n\n@RegisterAction\nclass MoveLineEnd extends BaseMovement {\n  keys = [['$'], ['<End>'], ['<D-right>']];\n  override setsDesiredColumnToEOL = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    return position.getDown(Math.max(count - 1, 0)).getLineEnd();\n  }\n}\n\n@RegisterAction\nclass MoveLineBegin extends BaseMovement {\n  keys = [['0'], ['<Home>'], ['<D-left>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getLineBegin();\n  }\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.couldActionApply(vimState, keysPressed) && vimState.recordedState.count === 0;\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineBegin extends MoveByScreenLine {\n  keys = ['g', '0'];\n  movementType: CursorMovePosition = 'wrappedLineStart';\n}\n\n@RegisterAction\nclass MoveScreenNonBlank extends MoveByScreenLine {\n  keys = ['g', '^'];\n  movementType: CursorMovePosition = 'wrappedLineFirstNonWhitespaceCharacter';\n}\n\n@RegisterAction\nclass MoveScreenLineEnd extends MoveByScreenLine {\n  keys = ['g', '$'];\n  movementType: CursorMovePosition = 'wrappedLineEnd';\n}\n\n@RegisterAction\nclass MoveScreenLineEndNonBlank extends MoveByScreenLine {\n  keys = ['g', '_'];\n  movementType: CursorMovePosition = 'wrappedLineLastNonWhitespaceCharacter';\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    count ||= 1;\n    const pos = await super.execActionWithCount(position, vimState, count);\n\n    // If in visual, return a selection\n    if (pos instanceof Position) {\n      return pos.getDown(count - 1);\n    } else {\n      return { start: pos.start, stop: pos.stop.getDown(count - 1).getLeftThroughLineBreaks() };\n    }\n  }\n}\n\n@RegisterAction\nclass MoveScreenLineCenter extends MoveByScreenLine {\n  keys = ['g', 'm'];\n  movementType: CursorMovePosition = 'wrappedLineColumnCenter';\n}\n\n@RegisterAction\nclass MoveUpByDisplayLine extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveDownByDisplayLine extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'wrappedLine';\n  override value = 1;\n}\n\n// Because we can't support moving by screen line when in visualLine mode,\n// we change to moving by regular line in visualLine mode. We can't move by\n// screen line is that our ranges only support a start and stop attribute,\n// and moving by screen line just snaps us back to the original position.\n// Check PR #1600 for discussion.\n@RegisterAction\nclass MoveUpByScreenLineVisualLine extends MoveByScreenLine {\n  override modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  movementType: CursorMovePosition = 'up';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualLine extends MoveByScreenLine {\n  override modes = [Mode.VisualLine];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  movementType: CursorMovePosition = 'down';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n}\n\n@RegisterAction\nclass MoveUpByScreenLineVisualBlock extends BaseMovement {\n  override modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'k'],\n    ['g', '<up>'],\n  ];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line > 0) {\n      return position.with({ character: vimState.desiredColumn }).getUp();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getUp();\n  }\n}\n\n@RegisterAction\nclass MoveDownByScreenLineVisualBlock extends BaseMovement {\n  override modes = [Mode.VisualBlock];\n  keys = [\n    ['g', 'j'],\n    ['g', '<down>'],\n  ];\n  override preservesDesiredColumn = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (position.line < vimState.document.lineCount - 1) {\n      return position.with({ character: vimState.desiredColumn }).getDown();\n    } else {\n      return position;\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return position.getDown();\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRight extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'h'];\n  movementType: CursorMovePosition = 'right';\n  override by: CursorMoveByUnit = 'character';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeft extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'l'];\n  movementType: CursorMovePosition = 'left';\n  override by: CursorMoveByUnit = 'character';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToRightHalf extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'H'];\n  movementType: CursorMovePosition = 'right';\n  override by: CursorMoveByUnit = 'halfLine';\n  override value = 1;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveScreenToLeftHalf extends MoveByScreenLine {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  keys = ['z', 'L'];\n  movementType: CursorMovePosition = 'left';\n  override by: CursorMoveByUnit = 'halfLine';\n  override value = 1;\n  override isJump = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    // Don't run if there's an operator because the Sneak plugin uses <operator>z\n    return (\n      super.doesActionApply(vimState, keysPressed) && vimState.recordedState.operator === undefined\n    );\n  }\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortTop extends MoveByScreenLine {\n  keys = ['H'];\n  movementType: CursorMovePosition = 'viewPortTop';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveToLineFromViewPortBottom extends MoveByScreenLine {\n  keys = ['L'];\n  movementType: CursorMovePosition = 'viewPortBottom';\n  override by: CursorMoveByUnit = 'line';\n  override value = 1;\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveToMiddleLineInViewPort extends MoveByScreenLine {\n  keys = ['M'];\n  movementType: CursorMovePosition = 'viewPortCenter';\n  override by: CursorMoveByUnit = 'line';\n  override isJump = true;\n}\n\n@RegisterAction\nclass MoveNonBlank extends BaseMovement {\n  keys = ['^'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line);\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankFirst extends BaseMovement {\n  keys = [['g', 'g'], ['<C-Home>']];\n  override isJump = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    const line = clamp(count, 1, vimState.document.lineCount) - 1;\n\n    return {\n      start: vimState.cursorStartPosition,\n      stop: position.with({ line }).obeyStartOfLine(vimState.document),\n    };\n  }\n}\n\n@RegisterAction\nclass MoveNonBlankLast extends BaseMovement {\n  keys = ['G'];\n  override isJump = true;\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let stop: Position;\n    if (count === 0) {\n      stop = new Position(vimState.document.lineCount - 1, position.character).obeyStartOfLine(\n        vimState.document\n      );\n    } else {\n      stop = new Position(\n        Math.min(count, vimState.document.lineCount) - 1,\n        position.character\n      ).obeyStartOfLine(vimState.document);\n    }\n\n    return {\n      start: vimState.cursorStartPosition,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nclass EndOfSpecificLine extends BaseMovement {\n  keys = ['<C-End>'];\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position> {\n    const line = count\n      ? clamp(count - 1, 0, vimState.document.lineCount - 1)\n      : vimState.document.lineCount - 1;\n\n    return new Position(line, 0).getLineEnd();\n  }\n}\n\n@RegisterAction\nexport class MoveWordBegin extends BaseMovement {\n  keys = ['w'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position> {\n    if (\n      lastIteration &&\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      const line = vimState.document.lineAt(position);\n      if (line.text.length === 0) {\n        return position;\n      }\n\n      const char = line.text[position.character];\n\n      /*\n      From the Vim manual:\n\n      Special case: \"cw\" and \"cW\" are treated like \"ce\" and \"cE\" if the cursor is\n      on a non-blank.  This is because \"cw\" is interpreted as change-word, and a\n      word does not include the following white space.\n      */\n\n      if (' \\t'.includes(char)) {\n        return position.nextWordStart(vimState.document);\n      } else {\n        return position.nextWordEnd(vimState.document, { inclusive: true }).getRight();\n      }\n    } else {\n      return position.nextWordStart(vimState.document);\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<Position> {\n    const result = await this.execAction(position, vimState, firstIteration, lastIteration);\n\n    /*\n    From the Vim documentation:\n\n    Another special case: When using the \"w\" motion in combination with an\n    operator and the last word moved over is at the end of a line, the end of\n    that word becomes the end of the operated text, not the first word in the\n    next line.\n    */\n\n    if (\n      result.line > position.line + 1 ||\n      (result.line === position.line + 1 && result.isFirstWordOfLine(vimState.document))\n    ) {\n      return position.getLineEnd();\n    }\n\n    if (result.isLineEnd()) {\n      return new Position(result.line, result.character + 1);\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nexport class MoveFullWordBegin extends BaseMovement {\n  keys = [['W'], ['<C-right>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    if (\n      !configuration.changeWordIncludesWhitespace &&\n      vimState.recordedState.operator instanceof ChangeOperator\n    ) {\n      // TODO use execForOperator? Or maybe dont?\n\n      // See note for w\n      return position\n        .nextWordEnd(vimState.document, { wordType: WordType.Big, inclusive: true })\n        .getRight();\n    } else {\n      return position.nextWordStart(vimState.document, { wordType: WordType.Big });\n    }\n  }\n}\n\n@RegisterAction\nclass MoveWordEnd extends BaseMovement {\n  keys = ['e'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.nextWordEnd(vimState.document);\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    const end = position.nextWordEnd(vimState.document);\n\n    return new Position(end.line, end.character + 1);\n  }\n}\n\n@RegisterAction\nclass MoveFullWordEnd extends BaseMovement {\n  keys = ['E'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.nextWordEnd(vimState.document, { wordType: WordType.Big });\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position> {\n    return position.nextWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n  }\n}\n\n@RegisterAction\nclass MoveLastWordEnd extends BaseMovement {\n  keys = ['g', 'e'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordEnd(vimState.document);\n  }\n}\n\n@RegisterAction\nclass MoveLastFullWordEnd extends BaseMovement {\n  keys = ['g', 'E'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordEnd(vimState.document, { wordType: WordType.Big });\n  }\n}\n\n@RegisterAction\nclass MoveBeginningWord extends BaseMovement {\n  keys = [['b'], ['<C-left>']];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordStart(vimState.document);\n  }\n}\n\n@RegisterAction\nclass MoveBeginningFullWord extends BaseMovement {\n  keys = ['B'];\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.prevWordStart(vimState.document, { wordType: WordType.Big });\n  }\n}\n\n@RegisterAction\nclass MovePreviousSentenceBegin extends BaseMovement {\n  keys = ['('];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: false });\n  }\n}\n\n@RegisterAction\nclass GoToOffset extends BaseMovement {\n  keys = ['g', 'o'];\n  override isJump = true;\n\n  public override async execActionWithCount(position: Position, vimState: VimState, count: number) {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    return vimState.document.positionAt((count || 1) - 1);\n  }\n}\n\n@RegisterAction\nclass MoveNextSentenceBegin extends BaseMovement {\n  keys = [')'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return position.getSentenceBegin({ forward: true });\n  }\n}\n\n@RegisterAction\nclass MoveParagraphEnd extends BaseMovement {\n  keys = ['}'];\n  override isJump = true;\n  iteration = 0;\n  isFirstLineWise = false;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    const hasOperator = vimState.recordedState.operator;\n    const paragraphEnd = getCurrentParagraphEnd(position);\n\n    if (hasOperator) {\n      /**\n       * When paired with an `operator` and a `count` this move will be executed\n       * multiple times which could cause issues like https://github.com/VSCodeVim/Vim/issues/4488\n       * because subsequent runs will receive back whatever position we return\n       * (See comment in `BaseMotion.execActionWithCount()`).\n       *\n       * We keep track of the iteration we are in, this way we can\n       * return the correct position when on the last iteration, and we don't\n       * accidentally set the `registerMode` incorrectly.\n       */\n      this.iteration++;\n\n      const isLineWise = position.isLineBeginning() && vimState.currentMode === Mode.Normal;\n\n      // TODO: `execAction` receives `firstIteration` and `lastIteration` - don't reinvent the wheel\n      const isLastIteration = vimState.recordedState.count\n        ? vimState.recordedState.count === this.iteration\n        : true;\n\n      /**\n       * `position` may not represent the position of the cursor from which the command was initiated.\n       * In the case that we will be repeating this move more than once\n       * we want to respect whether the starting position was at the beginning of line or not.\n       */\n      this.isFirstLineWise = this.iteration === 1 ? isLineWise : this.isFirstLineWise;\n\n      vimState.currentRegisterMode = this.isFirstLineWise ? RegisterMode.LineWise : undefined;\n\n      /**\n       * `paragraphEnd` is the first blank line after the last word in the\n       * current paragraph, we want the position just before that one to\n       * accurately emulate Vim's behaviour, unless we are at EOF.\n       */\n      return isLastIteration && !paragraphEnd.isAtDocumentEnd()\n        ? paragraphEnd.getLeftThroughLineBreaks(true)\n        : paragraphEnd;\n    }\n\n    return paragraphEnd;\n  }\n}\n\n@RegisterAction\nclass MoveParagraphBegin extends BaseMovement {\n  keys = ['{'];\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<Position> {\n    return getCurrentParagraphBeginning(position);\n  }\n}\n\nabstract class MoveSectionBoundary extends BaseMovement {\n  abstract begin: boolean;\n  abstract forward: boolean;\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const document = vimState.document;\n\n    switch (document.languageId) {\n      case 'python':\n        return PythonDocument.moveClassBoundary(\n          document,\n          position,\n          vimState,\n          this.forward,\n          this.begin\n        );\n    }\n\n    const boundary = this.begin ? '{' : '}';\n    let line = position.line;\n\n    if (\n      (this.forward && line === vimState.document.lineCount - 1) ||\n      (!this.forward && line === 0)\n    ) {\n      return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    }\n\n    line = this.forward ? line + 1 : line - 1;\n\n    while (!vimState.document.lineAt(line).text.startsWith(boundary)) {\n      if (this.forward) {\n        if (line === vimState.document.lineCount - 1) {\n          break;\n        }\n\n        line++;\n      } else {\n        if (line === 0) {\n          break;\n        }\n\n        line--;\n      }\n    }\n\n    return TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n  }\n}\n\n@RegisterAction\nclass MoveNextSectionBegin extends MoveSectionBoundary {\n  keys = [']', ']'];\n  begin = true;\n  forward = true;\n}\n\n@RegisterAction\nclass MoveNextSectionEnd extends MoveSectionBoundary {\n  keys = [']', '['];\n  begin = false;\n  forward = true;\n}\n\n@RegisterAction\nclass MovePreviousSectionBegin extends MoveSectionBoundary {\n  keys = ['[', '['];\n  begin = true;\n  forward = false;\n}\n\n@RegisterAction\nclass MovePreviousSectionEnd extends MoveSectionBoundary {\n  keys = ['[', ']'];\n  begin = false;\n  forward = false;\n}\n\n@RegisterAction\nclass MoveToMatchingBracket extends BaseMovement {\n  keys = ['%'];\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    position = position.getLeftIfEOL();\n\n    const lineText = vimState.document.lineAt(position).text;\n    const failure = failedMovement(vimState);\n\n    for (let col = position.character; col < lineText.length; col++) {\n      const currentChar = lineText[col];\n      const pairing = PairMatcher.getPercentPairing(currentChar);\n\n      // we need to check pairing, because with text: bla |bla < blub > blub\n      // this for loop will walk over bla and check for a pairing till it finds <\n      if (pairing) {\n        // We found an opening char, now move to the matching closing char\n        return (\n          PairMatcher.nextPairedChar(\n            new Position(position.line, col),\n            lineText[col],\n            vimState,\n            false\n          ) || failure\n        );\n      }\n    }\n\n    // No matchable character on the line; admit defeat\n    return failure;\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n\n    if (isIMovement(result)) {\n      if (result.failed) {\n        return result;\n      } else {\n        throw new Error('Did not ever handle this case!');\n      }\n    }\n\n    if (position.isAfter(result)) {\n      return {\n        start: result,\n        stop: position.getRight(),\n      };\n    } else {\n      return result.getRight();\n    }\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement> {\n    // % has a special mode that lets you use it to jump to a percentage of the file\n    // However, some other bracket motions inherit from this so only do this behavior for % explicitly\n    if (Object.getPrototypeOf(this) === MoveToMatchingBracket.prototype) {\n      if (count === 0) {\n        if (vimState.recordedState.operator) {\n          return this.execActionForOperator(position, vimState);\n        } else {\n          return this.execAction(position, vimState);\n        }\n      }\n\n      // Check to make sure this is a valid percentage\n      if (count < 0 || count > 100) {\n        return failedMovement(vimState);\n      }\n\n      // See `:help N%`\n      const targetLine = Math.trunc((count * vimState.document.lineCount + 99) / 100) - 1;\n\n      return position.with({ line: targetLine }).obeyStartOfLine(vimState.document);\n    } else {\n      return super.execActionWithCount(position, vimState, count);\n    }\n  }\n}\n\nexport abstract class MoveInsideCharacter extends ExpandingSelection {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  protected abstract charToMatch: string;\n\n  /** True for \"around\" actions, such as `a(`, and false for \"inside\" actions, such as `i(`  */\n  protected includeSurrounding = false;\n  override isJump = true;\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<IMovement> {\n    const closingChar = PairMatcher.pairings[this.charToMatch].match;\n    const [selStart, selEnd] = sorted(vimState.cursorStartPosition, position);\n\n    // First, search backwards for the opening character of the sequence\n    let openPos = PairMatcher.nextPairedChar(selStart, closingChar, vimState, true);\n    if (openPos === undefined) {\n      return failedMovement(vimState);\n    }\n\n    // Next, search forwards for the closing character which matches\n    let closePos = PairMatcher.nextPairedChar(openPos, this.charToMatch, vimState, true);\n    if (closePos === undefined) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      !this.includeSurrounding &&\n      (isVisualMode(vimState.currentMode) || !firstIteration) &&\n      selStart.getLeftThroughLineBreaks(false).isBeforeOrEqual(openPos) &&\n      selEnd.getRightThroughLineBreaks(false).isAfterOrEqual(closePos)\n    ) {\n      // Special case: inner, with all inner content already selected\n      const outerOpenPos = PairMatcher.nextPairedChar(openPos, closingChar, vimState, false);\n      const outerClosePos = outerOpenPos\n        ? PairMatcher.nextPairedChar(outerOpenPos, this.charToMatch, vimState, false)\n        : undefined;\n\n      if (outerOpenPos && outerClosePos) {\n        openPos = outerOpenPos;\n        closePos = outerClosePos;\n      }\n    }\n\n    if (this.includeSurrounding) {\n      if (vimState.currentMode !== Mode.Visual) {\n        closePos = new Position(closePos.line, closePos.character + 1);\n      }\n    } else {\n      openPos = openPos.getRightThroughLineBreaks();\n      // If the closing character is the first on the line, don't swallow it.\n      if (closePos.isInLeadingWhitespace(vimState.document)) {\n        closePos = closePos.getLineBegin();\n      }\n\n      if (vimState.currentMode === Mode.Visual) {\n        closePos = closePos.getLeftThroughLineBreaks();\n      }\n    }\n\n    if (lastIteration && !isVisualMode(vimState.currentMode) && selStart.isBefore(openPos)) {\n      vimState.recordedState.operatorPositionDiff = openPos.subtract(selStart);\n    }\n\n    // TODO: setting the cursor manually like this shouldn't be necessary (probably a Cursor, not Position, should be passed to `exec`)\n    vimState.cursorStartPosition = openPos;\n    return {\n      start: openPos,\n      stop: closePos,\n    };\n  }\n}\n\n@RegisterAction\nexport class MoveInsideParentheses extends MoveInsideCharacter {\n  keys = [\n    ['i', '('],\n    ['i', ')'],\n    ['i', 'b'],\n  ];\n  charToMatch = '(';\n}\n\n@RegisterAction\nexport class MoveAroundParentheses extends MoveInsideCharacter {\n  keys = [\n    ['a', '('],\n    ['a', ')'],\n    ['a', 'b'],\n  ];\n  charToMatch = '(';\n  override includeSurrounding = true;\n}\n\n// special treatment for curly braces\nexport abstract class MoveCurlyBrace extends MoveInsideCharacter {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  protected charToMatch: string = '{'\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<IMovement> {\n\n    // curly braces has a special treatment. In case the cursor is before an opening curly brace,\n    // and there are no characters before the opening curly brace in the same line, it should jump\n    // to the next opening curly brace, even if it already inside a pair of curly braces.\n    const text = vimState.document.lineAt(position).text;\n    const openCurlyBraceIndexFromCursor = text.substring(position.character).indexOf('{');\n    const startSameAsEnd = vimState.cursorStartPosition.isEqual(position);\n    if (\n      openCurlyBraceIndexFromCursor !== -1 &&\n      text.substring(0, position.character + openCurlyBraceIndexFromCursor).trim().length === 0 &&\n      startSameAsEnd\n    ) {\n      const curlyPos = position.with(position.line, position.character + openCurlyBraceIndexFromCursor);\n      vimState.cursorStartPosition = vimState.cursorStopPosition = curlyPos;\n      const movement = await super.execAction(curlyPos, vimState, firstIteration, lastIteration);\n      if (movement.failed) {\n        return movement;\n      }\n      const { start, stop } = movement;\n      if (!isVisualMode(vimState.currentMode) && position.isBefore(start)) {\n        vimState.recordedState.operatorPositionDiff = start.subtract(position);\n      } else if (!isVisualMode(vimState.currentMode) && position.isAfter(stop)) {\n        if (position.line === stop.line) {\n          vimState.recordedState.operatorPositionDiff = stop.subtract(position);\n        } else {\n          vimState.recordedState.operatorPositionDiff = start.subtract(position);\n        }\n      }\n\n      vimState.cursorStartPosition = start;\n      vimState.cursorStopPosition = stop;\n      return movement;\n    }\n    else {\n      return super.execAction(position, vimState, firstIteration, lastIteration);\n    }\n  }\n}\n\n@RegisterAction\nexport class MoveInsideCurlyBrace extends MoveCurlyBrace {\n  keys = [\n    ['i', '{'],\n    ['i', '}'],\n    ['i', 'B'],\n  ];\n}\n\n@RegisterAction\nexport class MoveAroundCurlyBrace extends MoveCurlyBrace {\n  keys = [\n    ['a', '{'],\n    ['a', '}'],\n    ['a', 'B'],\n  ];\n  override includeSurrounding = true;\n}\n\n@RegisterAction\nexport class MoveInsideCaret extends MoveInsideCharacter {\n  keys = [\n    ['i', '<'],\n    ['i', '>'],\n  ];\n  charToMatch = '<';\n}\n\n@RegisterAction\nexport class MoveAroundCaret extends MoveInsideCharacter {\n  keys = [\n    ['a', '<'],\n    ['a', '>'],\n  ];\n  charToMatch = '<';\n  override includeSurrounding = true;\n}\n\n@RegisterAction\nexport class MoveInsideSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['i', '['],\n    ['i', ']'],\n  ];\n  charToMatch = '[';\n}\n\n@RegisterAction\nexport class MoveAroundSquareBracket extends MoveInsideCharacter {\n  keys = [\n    ['a', '['],\n    ['a', ']'],\n  ];\n  charToMatch = '[';\n  override includeSurrounding = true;\n}\n\n// TODO: Shouldn't this be a TextObject? A clearer delineation between motions and objects should be made.\nexport abstract class MoveQuoteMatch extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected readonly anyQuote: boolean = false;\n  protected abstract readonly charToMatch: '\"' | \"'\" | '`';\n  protected includeQuotes = false;\n  override isJump = true;\n  readonly which: WhichQuotes = 'current';\n\n  // HACK: surround uses these classes, but does not want trailing whitespace to be included\n  private adjustForTrailingWhitespace: boolean = true;\n\n  constructor(adjustForTrailingWhitespace: boolean = true) {\n    super();\n    this.adjustForTrailingWhitespace = adjustForTrailingWhitespace;\n  }\n\n  public override async execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<IMovement> {\n    // TODO: this is super janky\n    return (await super.execActionWithCount(position, vimState, 1)) as IMovement;\n  }\n\n  public override async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    if (\n      !this.includeQuotes &&\n      (vimState.recordedState.count > 1 || vimState.recordedState.operatorCount > 1)\n    ) {\n      // i\" special case: With a count of 2 the quotes are included, but no extra white space as with a\"/a'/a`.\n      // (a\" does not make use of count)\n      this.includeQuotes = true;\n      this.adjustForTrailingWhitespace = false;\n    }\n\n    if (useSmartQuotes()) {\n      const quoteMatcher = new SmartQuoteMatcher(\n        this.anyQuote ? 'any' : this.charToMatch,\n        vimState.document\n      );\n      const res = quoteMatcher.smartSurroundingQuotes(position, this.which);\n\n      if (res === undefined) {\n        return failedMovement(vimState);\n      }\n      let { start, stop, lineText } = res;\n\n      if (!this.includeQuotes) {\n        // Don't include the quotes\n        start = start.translate({ characterDelta: 1 });\n        stop = stop.translate({ characterDelta: -1 });\n      } else if (\n        this.adjustForTrailingWhitespace &&\n        configuration.targets.smartQuotes.aIncludesSurroundingSpaces\n      ) {\n        // Include trailing whitespace if there is any...\n        const trailingWhitespace = lineText.substring(stop.character + 1).search(/\\S|$/);\n        if (trailingWhitespace > 0) {\n          stop = stop.translate({ characterDelta: trailingWhitespace });\n        } else {\n          // ...otherwise include leading whitespace\n          start = start.with({ character: lineText.substring(0, start.character).search(/\\s*$/) });\n        }\n      }\n\n      if (!isVisualMode(vimState.currentMode) && position.isBefore(start)) {\n        vimState.recordedState.operatorPositionDiff = start.subtract(position);\n      } else if (!isVisualMode(vimState.currentMode) && position.isAfter(stop)) {\n        if (position.line === stop.line) {\n          vimState.recordedState.operatorPositionDiff = stop.getRight().subtract(position);\n        } else {\n          vimState.recordedState.operatorPositionDiff = start.subtract(position);\n        }\n      }\n\n      vimState.cursorStartPosition = start;\n      return {\n        start,\n        stop,\n      };\n    } else {\n      const text = vimState.document.lineAt(position).text;\n      const quoteMatcher = new QuoteMatcher(this.charToMatch, text);\n      const quoteIndices = quoteMatcher.surroundingQuotes(position.character);\n\n      if (quoteIndices === undefined) {\n        return failedMovement(vimState);\n      }\n\n      let [start, end] = quoteIndices;\n\n      if (!this.includeQuotes) {\n        // Don't include the quotes\n        start++;\n        end--;\n      } else if (this.adjustForTrailingWhitespace) {\n        // Include trailing whitespace if there is any...\n        const trailingWhitespace = text.substring(end + 1).search(/\\S|$/);\n        if (trailingWhitespace > 0) {\n          end += trailingWhitespace;\n        } else {\n          // ...otherwise include leading whitespace\n          start = text.substring(0, start).search(/\\s*$/);\n        }\n      }\n\n      const startPos = new Position(position.line, start);\n      const endPos = new Position(position.line, end);\n\n      if (!isVisualMode(vimState.currentMode) && position.isBefore(startPos)) {\n        vimState.recordedState.operatorPositionDiff = startPos.subtract(position);\n      }\n\n      return {\n        start: startPos,\n        stop: endPos,\n      };\n    }\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const result = await this.execAction(position, vimState);\n    if (isIMovement(result)) {\n      if (result.failed) {\n        vimState.recordedState.hasRunOperator = false;\n        vimState.recordedState.actionsRun = [];\n      } else {\n        result.stop = result.stop.getRight();\n      }\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveInsideSingleQuotes extends MoveQuoteMatch {\n  keys = ['i', \"'\"];\n  readonly charToMatch = \"'\";\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundSingleQuotes extends MoveQuoteMatch {\n  keys = ['a', \"'\"];\n  readonly charToMatch = \"'\";\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveInsideDoubleQuotes extends MoveQuoteMatch {\n  keys = ['i', '\"'];\n  readonly charToMatch = '\"';\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundDoubleQuotes extends MoveQuoteMatch {\n  keys = ['a', '\"'];\n  readonly charToMatch = '\"';\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveInsideBacktick extends MoveQuoteMatch {\n  keys = ['i', '`'];\n  readonly charToMatch = '`';\n  override includeQuotes = false;\n}\n\n@RegisterAction\nexport class MoveAroundBacktick extends MoveQuoteMatch {\n  keys = ['a', '`'];\n  readonly charToMatch = '`';\n  override includeQuotes = true;\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketBackward extends MoveToMatchingBracket {\n  override keys = ['[', '('];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = ')';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedRoundBracketForward extends MoveToMatchingBracket {\n  override keys = [']', ')'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '(';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketBackward extends MoveToMatchingBracket {\n  override keys = ['[', '{'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '}';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n    return result;\n  }\n}\n\n@RegisterAction\nclass MoveToUnclosedCurlyBracketForward extends MoveToMatchingBracket {\n  override keys = [']', '}'];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    const charToMatch = '{';\n    const result = PairMatcher.nextPairedChar(position, charToMatch, vimState, false);\n\n    if (!result) {\n      return failedMovement(vimState);\n    }\n\n    if (\n      vimState.recordedState.operator instanceof ChangeOperator ||\n      vimState.recordedState.operator instanceof DeleteOperator ||\n      vimState.recordedState.operator instanceof YankOperator\n    ) {\n      return result.getLeftThroughLineBreaks();\n    }\n\n    return result;\n  }\n}\n\nabstract class MoveTagMatch extends ExpandingSelection {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n  protected includeTag = false;\n  override isJump = true;\n\n  public override async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const editorText = vimState.document.getText();\n    const offset = vimState.document.offsetAt(position);\n    const tagMatcher = new TagMatcher(editorText, offset, vimState);\n    const start = tagMatcher.findOpening(this.includeTag);\n    const end = tagMatcher.findClosing(this.includeTag);\n\n    if (start === undefined || end === undefined) {\n      return failedMovement(vimState);\n    }\n\n    const startPosition =\n      start >= 0 ? vimState.document.positionAt(start) : vimState.cursorStartPosition;\n    let endPosition = end >= 0 ? vimState.document.positionAt(end) : position;\n    if (vimState.currentMode === Mode.Visual || vimState.currentMode === Mode.SurroundInputMode) {\n      endPosition = endPosition.getLeftThroughLineBreaks();\n    }\n\n    if (position.isAfter(endPosition)) {\n      vimState.recordedState.transformer.moveCursor(endPosition.subtract(position));\n    } else if (position.isBefore(startPosition)) {\n      vimState.recordedState.transformer.moveCursor(startPosition.subtract(position));\n    }\n    // if (start === end) {\n    //   if (vimState.recordedState.operator instanceof ChangeOperator) {\n    //     await vimState.setCurrentMode(ModeName.Insert);\n    //   }\n    //   return failedMovement(vimState);\n    // }\n    vimState.cursorStartPosition = startPosition;\n    return {\n      start: startPosition,\n      stop: endPosition,\n    };\n  }\n}\n\n@RegisterAction\nexport class MoveInsideTag extends MoveTagMatch {\n  keys = ['i', 't'];\n  override includeTag = false;\n}\n\n@RegisterAction\nexport class MoveAroundTag extends MoveTagMatch {\n  keys = ['a', 't'];\n  override includeTag = true;\n}\n","import * as vscode from 'vscode';\n\nimport { PositionDiff, earlierOf, sorted } from './../common/motion/position';\nimport { configuration } from './../configuration/configuration';\nimport { Mode, isVisualMode } from './../mode/mode';\nimport { Register, RegisterMode } from './../register/register';\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { BaseAction, RegisterAction } from './base';\nimport { CommandNumber } from './commands/actions';\nimport { reportLinesChanged, reportLinesYanked } from '../util/statusBarTextUtils';\nimport { ExCommandLine } from './../cmd_line/commandLine';\nimport { Position } from 'vscode';\nimport { isHighSurrogate, isLowSurrogate } from '../util/util';\nimport { Cursor } from './../common/motion/cursor';\n\nexport abstract class BaseOperator extends BaseAction {\n  override actionType = 'operator' as const;\n\n  constructor(multicursorIndex?: number) {\n    super();\n    this.multicursorIndex = multicursorIndex;\n  }\n  override createsUndoPoint = true;\n\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (this.doesRepeatedOperatorApply(vimState, keysPressed)) {\n      return true;\n    }\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys, keysPressed)) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    if (!this.modes.includes(vimState.currentMode)) {\n      return false;\n    }\n    if (!BaseAction.CompareKeypressSequence(this.keys.slice(0, keysPressed.length), keysPressed)) {\n      return false;\n    }\n    if (this instanceof BaseOperator && vimState.recordedState.operator) {\n      return false;\n    }\n\n    return true;\n  }\n\n  public doesRepeatedOperatorApply(vimState: VimState, keysPressed: string[]) {\n    const nonCountActions = vimState.recordedState.actionsRun.filter(\n      (x) => !(x instanceof CommandNumber)\n    );\n    const prevAction = nonCountActions[nonCountActions.length - 1];\n    return (\n      keysPressed.length === 1 &&\n      prevAction &&\n      this.modes.includes(vimState.currentMode) &&\n      // The previous action is the same as the one we're testing\n      prevAction.constructor === this.constructor &&\n      // The key pressed is the same as the previous action's last key.\n      BaseAction.CompareKeypressSequence(prevAction.keysPressed.slice(-1), keysPressed)\n    );\n  }\n\n  /**\n   * Run this operator on a range, returning the new location of the cursor.\n   */\n  public abstract run(vimState: VimState, start: Position, stop: Position): Promise<void>;\n\n  public async runRepeat(vimState: VimState, position: Position, count: number): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    await this.run(\n      vimState,\n      position.getLineBegin(),\n      position.getDown(Math.max(0, count - 1)).getLineEnd()\n    );\n  }\n\n  public highlightYankedRanges(vimState: VimState, ranges: vscode.Range[]) {\n    if (!configuration.highlightedyank.enable) {\n      return;\n    }\n\n    const yankDecoration = vscode.window.createTextEditorDecorationType({\n      backgroundColor: configuration.highlightedyank.color,\n      color: configuration.highlightedyank.textColor,\n    });\n\n    vimState.editor.setDecorations(yankDecoration, ranges);\n    setTimeout(() => yankDecoration.dispose(), configuration.highlightedyank.duration);\n  }\n}\n\n@RegisterAction\nexport class DeleteOperator extends BaseOperator {\n  public keys = ['d'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // TODO: this is off by one when character-wise and not including last EOL\n    const numLinesDeleted = Math.abs(start.line - end.line) + 1;\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      end = end.getLineEnd();\n    }\n\n    end = new Position(end.line, end.character + 1);\n\n    const isOnLastLine = end.line === vimState.document.lineCount - 1;\n\n    // Vim does this weird thing where it allows you to select and delete\n    // the newline character, which it places 1 past the last character\n    // in the line. Here we interpret a character position 1 past the end\n    // as selecting the newline character. Don't allow this in visual block mode\n    if (\n      vimState.currentMode !== Mode.VisualBlock &&\n      !isOnLastLine &&\n      end.character === vimState.document.lineAt(end).text.length + 1\n    ) {\n      end = new Position(end.line + 1, 0);\n    }\n\n    // Yank the text\n    let text = vimState.document.getText(new vscode.Range(start, end));\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      // When deleting linewise, exclude final newline\n      text = text.endsWith('\\r\\n')\n        ? text.slice(0, -2)\n        : text.endsWith('\\n')\n        ? text.slice(0, -1)\n        : text;\n    }\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    // When deleting the last line linewise, we need to delete the newline\n    // character BEFORE the range because there isn't one after the range.\n    if (\n      isOnLastLine &&\n      start.line !== 0 &&\n      vimState.currentRegisterMode === RegisterMode.LineWise\n    ) {\n      start = start.getUp().getLineEnd();\n    }\n\n    let diff: PositionDiff | undefined;\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      diff = PositionDiff.startOfLine();\n    } else if (start.character > vimState.document.lineAt(start).text.length) {\n      diff = PositionDiff.offset({ character: -1 });\n    }\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new vscode.Range(start, end),\n      diff,\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    reportLinesChanged(-numLinesDeleted, vimState);\n  }\n}\n\n@RegisterAction\nclass DeleteOperatorVisual extends BaseOperator {\n  public keys = ['D'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // ensures linewise deletion when in visual mode\n    // see special case in DeleteOperator.delete()\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nexport class YankOperator extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  override createsUndoPoint = false;\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n    let extendedEnd = new Position(end.line, end.character + 1);\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      extendedEnd = extendedEnd.getLineEnd();\n    }\n\n    const sLine = vimState.document.lineAt(start.line).text;\n    const eLine = vimState.document.lineAt(extendedEnd.line).text;\n    if (\n      start.character !== 0 &&\n      isLowSurrogate(sLine.charCodeAt(start.character)) &&\n      isHighSurrogate(sLine.charCodeAt(start.character - 1))\n    ) {\n      start = start.getLeft();\n    }\n    if (\n      extendedEnd.character !== 0 &&\n      isLowSurrogate(eLine.charCodeAt(extendedEnd.character)) &&\n      isHighSurrogate(eLine.charCodeAt(extendedEnd.character - 1))\n    ) {\n      extendedEnd = extendedEnd.getRight();\n    }\n    const range = new vscode.Range(start, extendedEnd);\n    let text = vimState.document.getText(range);\n\n    // If we selected the newline character, add it as well.\n    if (\n      vimState.currentMode === Mode.Visual &&\n      extendedEnd.character === vimState.document.lineAt(extendedEnd).text.length + 1\n    ) {\n      text = text + '\\n';\n    }\n\n    this.highlightYankedRanges(vimState, [range]);\n\n    Register.put(vimState, text, this.multicursorIndex, true);\n\n    vimState.cursorStopPosition =\n      vimState.currentMode === Mode.Normal && vimState.currentRegisterMode === RegisterMode.LineWise\n        ? start.with({ character: vimState.cursorStopPosition.character })\n        : start;\n\n    await vimState.setCurrentMode(Mode.Normal);\n\n    const numLinesYanked = text.split('\\n').length;\n    reportLinesYanked(numLinesYanked, vimState);\n  }\n}\n\n@RegisterAction\nclass FilterOperator extends BaseOperator {\n  public keys = ['!'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    let commandLineText: string;\n    if (vimState.currentMode === Mode.Normal && start.line === end.line) {\n      commandLineText = '.!';\n    } else if (vimState.currentMode === Mode.Normal && start.line !== end.line) {\n      commandLineText = `.,.+${end.line - start.line}!`;\n    } else {\n      commandLineText = \"'<,'>!\";\n    }\n\n    vimState.cursorStartPosition = start;\n    if (vimState.currentMode === Mode.Normal) {\n      vimState.cursorStopPosition = start;\n    } else {\n      vimState.cursors = vimState.cursorsInitialState;\n    }\n\n    const previousMode = vimState.currentMode;\n    await vimState.setCurrentMode(Mode.CommandlineInProgress);\n    // TODO: Change or supplement `setCurrentMode` API so this isn't necessary\n    if (vimState.modeData.mode === Mode.CommandlineInProgress) {\n      vimState.modeData.commandLine = new ExCommandLine(commandLineText, previousMode);\n    }\n  }\n}\n\n@RegisterAction\nclass ShiftYankOperatorVisual extends BaseOperator {\n  public keys = ['Y'];\n  public modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    await new YankOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass DeleteOperatorXVisual extends BaseOperator {\n  public keys = [['x'], ['<Del>']];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new DeleteOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass ChangeOperatorSVisual extends BaseOperator {\n  public keys = ['s'];\n  public modes = [Mode.Visual, Mode.VisualLine];\n\n  // Don't clash with Sneak plugin\n  public override doesActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    return super.doesActionApply(vimState, keysPressed) && !configuration.sneak;\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    await new ChangeOperator(this.multicursorIndex).run(vimState, start, end);\n  }\n}\n\n@RegisterAction\nclass FormatOperator extends BaseOperator {\n  public keys = ['='];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // = operates on complete lines\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.formatSelection');\n    let line = vimState.cursorStartPosition.line;\n\n    if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n      line = vimState.cursorStopPosition.line;\n    }\n\n    const newCursorPosition = TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, line);\n    vimState.cursorStopPosition = newCursorPosition;\n    vimState.cursorStartPosition = newCursorPosition;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\nabstract class ChangeCaseOperator extends BaseOperator {\n  public modes = [Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  abstract transformText(text: string): string;\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      for (const { start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n        const range = new vscode.Range(start, end);\n        vimState.recordedState.transformer.replace(\n          range,\n          this.transformText(vimState.document.getText(range))\n        );\n      }\n\n      // HACK: currently must do this nonsense to collapse all cursors into one\n      for (let i = 0; i < vimState.editor.selections.length; i++) {\n        vimState.recordedState.transformer.moveCursor(\n          PositionDiff.exactPosition(earlierOf(startPos, endPos)),\n          i\n        );\n      }\n    } else {\n      if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n        startPos = startPos.getLineBegin();\n        endPos = endPos.getLineEnd();\n      }\n\n      const range = new vscode.Range(startPos, new Position(endPos.line, endPos.character + 1));\n\n      vimState.recordedState.transformer.addTransformation({\n        type: 'replaceText',\n        range,\n        text: this.transformText(vimState.document.getText(range)),\n        diff: PositionDiff.exactPosition(startPos),\n      });\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass UpperCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', 'U'], ['U']];\n\n  public transformText(text: string): string {\n    return text.toUpperCase();\n  }\n}\n\n@RegisterAction\nclass UpperCaseWithMotion extends UpperCaseOperator {\n  public override keys = [['g', 'U']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass LowerCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', 'u'], ['u']];\n\n  public transformText(text: string): string {\n    return text.toLowerCase();\n  }\n}\n\n@RegisterAction\nclass LowerCaseWithMotion extends LowerCaseOperator {\n  public override keys = [['g', 'u']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass ToggleCaseOperator extends ChangeCaseOperator {\n  public keys = [['g', '~'], ['~']];\n\n  public transformText(text: string): string {\n    let newText = '';\n    for (const char of text) {\n      let toggled = char.toLocaleLowerCase();\n      if (toggled === char) {\n        toggled = char.toLocaleUpperCase();\n      }\n      newText += toggled;\n    }\n    return newText;\n  }\n}\n\n@RegisterAction\nclass ToggleCaseWithMotion extends ToggleCaseOperator {\n  public override keys = [['g', '~']];\n  public override modes = [Mode.Normal];\n}\n\n@RegisterAction\nclass IndentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.indentLines');\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n/**\n * `3>` to indent a line 3 times in visual mode is actually a bit of a special case.\n *\n * > is an operator, and generally speaking, you don't run operators multiple times, you run motions multiple times.\n * e.g. `d3w` runs `w` 3 times, then runs d once.\n *\n * Same with literally every other operator motion combination... until `3>`in visual mode\n * walked into my life.\n */\n@RegisterAction\nclass IndentOperatorVisualAndVisualLine extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.indentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = start.obeyStartOfLine(vimState.document);\n  }\n}\n\n@RegisterAction\nclass IndentOperatorVisualBlock extends BaseOperator {\n  modes = [Mode.VisualBlock];\n  keys = ['>'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    /**\n     * Repeating this command with dot should apply the indent to the left edge of the\n     * block formed by extending the cursor start position downward by the number of lines\n     * in the previous visual block selection.\n     */\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      const shiftSelectionByNum = Math.abs(\n        vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line\n      );\n\n      start = vimState.cursorStartPosition;\n      end = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n      vimState.editor.selection = new vscode.Selection(start, end);\n    }\n\n    for (let lineIdx = 0; lineIdx < end.line - start.line + 1; lineIdx++) {\n      const tabSize = Number(vimState.editor.options.tabSize);\n      const currentLineEnd = vimState.document.lineAt(start.line + lineIdx).range.end.character;\n\n      if (currentLineEnd > start.character) {\n        vimState.recordedState.transformer.addTransformation({\n          type: 'insertText',\n          text: ' '.repeat(tabSize).repeat(vimState.recordedState.count || 1),\n          position: start.getDown(lineIdx),\n          manuallySetCursorPositions: true,\n        });\n      }\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursors = [new Cursor(start, start)];\n  }\n}\n@RegisterAction\nclass OutdentOperator extends BaseOperator {\n  modes = [Mode.Normal];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start, end.getLineEnd());\n\n    await vscode.commands.executeCommand('editor.action.outdentLines');\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n/**\n * See comment for IndentOperatorVisualAndVisualLine\n */\n@RegisterAction\nclass OutdentOperatorVisualAndVisualLine extends BaseOperator {\n  modes = [Mode.Visual, Mode.VisualLine];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    // Repeating this command with dot should apply the indent to the previous selection\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      if (vimState.cursorStartPosition.isAfter(vimState.cursorStopPosition)) {\n        const shiftSelectionByNum =\n          vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line;\n\n        start = vimState.cursorStartPosition;\n        const newEnd = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n        vimState.editor.selection = new vscode.Selection(start, newEnd);\n      }\n    }\n\n    for (let i = 0; i < (vimState.recordedState.count || 1); i++) {\n      await vscode.commands.executeCommand('editor.action.outdentLines');\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      start.line\n    );\n  }\n}\n\n@RegisterAction\nclass OutdentOperatorVisualBlock extends BaseOperator {\n  modes = [Mode.VisualBlock];\n  keys = ['<'];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    /**\n     * Repeating this command with dot should apply the outdent to the left edge of the\n     * block formed by extending the cursor start position downward by the number of lines\n     * in the previous visual block selection.\n     */\n    if (vimState.isRunningDotCommand && vimState.dotCommandPreviousVisualSelection) {\n      const shiftSelectionByNum = Math.abs(\n        vimState.dotCommandPreviousVisualSelection.end.line -\n          vimState.dotCommandPreviousVisualSelection.start.line\n      );\n\n      start = vimState.cursorStartPosition;\n      end = vimState.cursorStartPosition.getDown(shiftSelectionByNum);\n\n      vimState.editor.selection = new vscode.Selection(start, end);\n    }\n\n    for (let lineIdx = 0; lineIdx < end.line - start.line + 1; lineIdx++) {\n      const tabSize = Number(vimState.editor.options.tabSize);\n      const currentLine = vimState.document.lineAt(start.line + lineIdx);\n      const currentLineEnd = currentLine.range.end.character;\n\n      if (currentLineEnd > start.character) {\n        const currentLineFromStart = currentLine.text.slice(start.character);\n        const isFirstCharBlank = /\\s/.test(currentLineFromStart.charAt(0));\n\n        if (isFirstCharBlank) {\n          const currentLinePosition = start.getDown(lineIdx);\n          const distToNonBlankChar = currentLineFromStart.match(/\\S/)?.index ?? 0;\n          const outdentDist = Math.min(\n            distToNonBlankChar,\n            tabSize * (vimState.recordedState.count || 1)\n          );\n\n          vimState.recordedState.transformer.addTransformation({\n            type: 'deleteRange',\n            range: new vscode.Range(currentLinePosition, currentLinePosition.getRight(outdentDist)),\n            manuallySetCursorPositions: true,\n          });\n        }\n      }\n    }\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursors = [new Cursor(start, start)];\n  }\n}\n\n@RegisterAction\nexport class ChangeOperator extends BaseOperator {\n  public keys = ['c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      start = start.getLineBegin();\n      end = end.getLineEnd();\n    } else if (vimState.currentMode === Mode.Visual && end.isLineEnd()) {\n      end = end.getRightThroughLineBreaks();\n    } else {\n      end = end.getRight();\n    }\n\n    const deleteRange = new vscode.Range(start, end);\n\n    Register.put(vimState, vimState.document.getText(deleteRange), this.multicursorIndex, true);\n\n    if (vimState.currentRegisterMode === RegisterMode.LineWise && configuration.autoindent) {\n      // Linewise is a bit of a special case - we want to preserve the first line's indentation,\n      // then let the language server adjust that indentation if it can.\n\n      const firstLineIndent = vimState.document.getText(\n        new vscode.Range(\n          deleteRange.start.getLineBegin(),\n          deleteRange.start.getLineBeginRespectingIndent(vimState.document)\n        )\n      );\n\n      vimState.recordedState.transformer.replace(\n        deleteRange,\n        firstLineIndent,\n        PositionDiff.exactPosition(new Position(deleteRange.start.line, firstLineIndent.length))\n      );\n\n      if (vimState.document.languageId !== 'plaintext') {\n        vimState.recordedState.transformer.vscodeCommand('editor.action.reindentselectedlines');\n        vimState.recordedState.transformer.moveCursor(\n          PositionDiff.endOfLine(),\n          this.multicursorIndex\n        );\n      }\n    } else {\n      vimState.recordedState.transformer.delete(deleteRange);\n    }\n\n    vimState.setCurrentMode(Mode.Insert);\n  }\n}\n\n@RegisterAction\nclass YankVisualBlockMode extends BaseOperator {\n  public keys = ['y'];\n  public modes = [Mode.VisualBlock];\n  override createsUndoPoint = false;\n  runsOnceForEveryCursor() {\n    return false;\n  }\n\n  public async run(vimState: VimState, startPos: Position, endPos: Position): Promise<void> {\n    const ranges: vscode.Range[] = [];\n    const lines: string[] = [];\n    for (const { line, start, end } of TextEditor.iterateLinesInBlock(vimState)) {\n      lines.push(line);\n      ranges.push(new vscode.Range(start, end));\n    }\n\n    vimState.currentRegisterMode = RegisterMode.BlockWise;\n\n    this.highlightYankedRanges(vimState, ranges);\n\n    Register.put(vimState, lines.join('\\n'), this.multicursorIndex, true);\n\n    vimState.historyTracker.addMark(startPos, '<');\n    vimState.historyTracker.addMark(endPos, '>');\n\n    const numLinesYanked = lines.length;\n    reportLinesYanked(numLinesYanked, vimState);\n\n    await vimState.setCurrentMode(Mode.Normal);\n    vimState.cursorStopPosition = startPos;\n  }\n}\n\n@RegisterAction\nclass CommentOperator extends BaseOperator {\n  public keys = ['g', 'c'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    vimState.editor.selection = new vscode.Selection(start.getLineBegin(), end.getLineEnd());\n    await vscode.commands.executeCommand('editor.action.commentLine');\n\n    vimState.cursorStopPosition = new Position(start.line, 0);\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nexport class ROT13Operator extends BaseOperator {\n  public keys = ['g', '?'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    let selections: readonly vscode.Selection[];\n    if (isVisualMode(vimState.currentMode)) {\n      selections = vimState.editor.selections;\n    } else if (vimState.currentRegisterMode === RegisterMode.LineWise) {\n      selections = [new vscode.Selection(start.getLineBegin(), end.getLineEnd())];\n    } else {\n      selections = [new vscode.Selection(start, end.getRight())];\n    }\n\n    for (const range of selections) {\n      const original = vimState.document.getText(range);\n      vimState.recordedState.transformer.replace(range, ROT13Operator.rot13(original));\n    }\n  }\n\n  /**\n   * https://en.wikipedia.org/wiki/ROT13\n   */\n  public static rot13(str: string) {\n    return str\n      .split('')\n      .map((char: string) => {\n        let charCode = char.charCodeAt(0);\n\n        if (char >= 'a' && char <= 'z') {\n          const a = 'a'.charCodeAt(0);\n          charCode = ((charCode - a + 13) % 26) + a;\n        }\n\n        if (char >= 'A' && char <= 'Z') {\n          const A = 'A'.charCodeAt(0);\n          charCode = ((charCode - A + 13) % 26) + A;\n        }\n\n        return String.fromCharCode(charCode);\n      })\n      .join('');\n  }\n}\n\n@RegisterAction\nclass CommentBlockOperator extends BaseOperator {\n  public keys = ['g', 'C'];\n  public modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    if (vimState.currentMode === Mode.Normal) {\n      // If we're in normal mode, we need to construct a selection for the\n      // command to operate on. If we're not, we've already got it.\n      const endPosition = end.getRight();\n      vimState.editor.selection = new vscode.Selection(start, endPosition);\n    }\n    await vscode.commands.executeCommand('editor.action.blockComment');\n\n    vimState.cursorStopPosition = start;\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\ninterface CommentTypeSingle {\n  singleLine: true;\n\n  start: string;\n}\n\ninterface CommentTypeMultiLine {\n  singleLine: false;\n\n  start: string;\n  inner: string;\n  final: string;\n}\n\ntype CommentType = CommentTypeSingle | CommentTypeMultiLine;\n\n@RegisterAction\nclass ActionVisualReflowParagraph extends BaseOperator {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine];\n  keys = ['g', 'q'];\n\n  public static CommentTypes: CommentType[] = [\n    { singleLine: false, start: '/**', inner: '*', final: '*/' },\n    { singleLine: false, start: '/*', inner: '*', final: '*/' },\n    { singleLine: false, start: '{-', inner: '-', final: '-}' },\n    { singleLine: true, start: '///' },\n    { singleLine: true, start: '//!' },\n    { singleLine: true, start: '//' },\n    { singleLine: true, start: '--' },\n    { singleLine: true, start: '#' },\n    { singleLine: true, start: ';' },\n    { singleLine: true, start: '*' },\n    { singleLine: true, start: '%' },\n\n    // Needs to come last, since everything starts with the empty string!\n    { singleLine: true, start: '' },\n  ];\n\n  public getIndentation(s: string): string {\n    // Use the indentation of the first non-whitespace line, if any such line is\n    // selected.\n    for (const line of s.split('\\n')) {\n      const result = line.match(/^\\s+/g);\n      const indent = result ? result[0] : '';\n\n      if (indent !== line) {\n        return indent;\n      }\n    }\n\n    return '';\n  }\n\n  public reflowParagraph(s: string): string {\n    const indent = this.getIndentation(s);\n\n    let indentLevel = 0;\n    for (const char of indent) {\n      indentLevel += char === '\\t' ? configuration.tabstop : 1;\n    }\n    const maximumLineLength = configuration.textwidth - indentLevel;\n\n    // Chunk the lines by commenting style.\n\n    interface Chunk {\n      commentType: CommentType;\n      content: string;\n      indentLevelAfterComment: number;\n      final: boolean;\n    }\n    const chunksToReflow: Chunk[] = [];\n\n    for (const line of s.split('\\n')) {\n      let lastChunk: Chunk | undefined = chunksToReflow[chunksToReflow.length - 1];\n      const trimmedLine = line.trimStart();\n\n      // See what comment type they are using.\n\n      let commentType: CommentType | undefined;\n\n      for (const type of ActionVisualReflowParagraph.CommentTypes) {\n        if (trimmedLine.startsWith(type.start)) {\n          commentType = type;\n\n          break;\n        }\n\n        // If they're currently in a multiline comment, see if they continued it.\n        if (\n          lastChunk &&\n          !lastChunk.final &&\n          type.start === lastChunk.commentType.start &&\n          !type.singleLine\n        ) {\n          if (trimmedLine.startsWith(type.inner)) {\n            commentType = type;\n\n            break;\n          }\n\n          if (trimmedLine.endsWith(type.final)) {\n            commentType = type;\n\n            break;\n          }\n        }\n      }\n\n      if (!commentType) {\n        break;\n      } // will never happen, just to satisfy typechecker.\n\n      // Did they start a new comment type?\n      if (!lastChunk || lastChunk.final || commentType.start !== lastChunk.commentType.start) {\n        const chunk = {\n          commentType,\n          content: `${trimmedLine.substr(commentType.start.length).trimStart()}`,\n          indentLevelAfterComment: 0,\n          final: false,\n        };\n        if (commentType.singleLine) {\n          chunk.indentLevelAfterComment =\n            trimmedLine.substr(commentType.start.length).length - chunk.content.length;\n        } else if (chunk.content.endsWith(commentType.final)) {\n          // Multiline comment started and ended on one line\n          chunk.content = chunk.content\n            .substr(0, chunk.content.length - commentType.final.length)\n            .trim();\n          chunk.final = true;\n        }\n        chunksToReflow.push(chunk);\n\n        continue;\n      }\n\n      // Parse out commenting style, gather words.\n\n      lastChunk = chunksToReflow[chunksToReflow.length - 1];\n\n      if (lastChunk.commentType.singleLine) {\n        // is it a continuation of a comment like \"//\"\n        lastChunk.content += `\\n${trimmedLine\n          .substr(lastChunk.commentType.start.length)\n          .trimStart()}`;\n      } else if (!lastChunk.final) {\n        // are we in the middle of a multiline comment like \"/*\"\n        if (trimmedLine.endsWith(lastChunk.commentType.final)) {\n          lastChunk.final = true;\n          const prefix = trimmedLine.startsWith(lastChunk.commentType.inner)\n            ? lastChunk.commentType.inner.length\n            : 0;\n          lastChunk.content += `\\n${trimmedLine\n            .substr(prefix, trimmedLine.length - lastChunk.commentType.final.length - prefix)\n            .trim()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.inner)) {\n          lastChunk.content += `\\n${trimmedLine\n            .substr(lastChunk.commentType.inner.length)\n            .trimStart()}`;\n        } else if (trimmedLine.startsWith(lastChunk.commentType.start)) {\n          lastChunk.content += `\\n${trimmedLine\n            .substr(lastChunk.commentType.start.length)\n            .trimStart()}`;\n        }\n      }\n    }\n\n    // Reflow each chunk.\n    const result: string[] = [];\n\n    for (const { commentType, content, indentLevelAfterComment } of chunksToReflow) {\n      let lines: string[];\n      const indentAfterComment = Array(indentLevelAfterComment + 1).join(' ');\n      const commentLength = commentType.start.length + indentAfterComment.length;\n\n      // Start with a single empty content line.\n      lines = [``];\n\n      for (let line of content.split('\\n')) {\n        // Preserve blank lines in output.\n        if (line.trim() === '') {\n          // Replace empty content line with blank line.\n          if (lines[lines.length - 1] === '') {\n            lines.pop();\n          }\n\n          lines.push(line);\n\n          // Add new empty content line for remaining content.\n          lines.push(``);\n\n          continue;\n        }\n\n        // Repeatedly partition line into pieces that fit in maximumLineLength\n        while (line) {\n          const lastLine = lines[lines.length - 1];\n\n          // Determine the separator that we'd need to add to the last line\n          // in order to join onto this line.\n          let separator;\n          if (!lastLine) {\n            separator = '';\n          } else if (\n            configuration.joinspaces &&\n            (lastLine.endsWith('.') || lastLine.endsWith('?') || lastLine.endsWith('!'))\n          ) {\n            separator = '  ';\n          } else if (lastLine.endsWith(' ')) {\n            if (\n              configuration.joinspaces &&\n              (lastLine.endsWith('. ') || lastLine.endsWith('? ') || lastLine.endsWith('! '))\n            ) {\n              separator = ' ';\n            } else {\n              separator = '';\n            }\n          } else {\n            separator = ' ';\n          }\n\n          // Consider appending separator and part of line to last line\n          const remaining = maximumLineLength - separator.length - lastLine.length - commentLength;\n          const trimmedLine = line.trimStart();\n          if (trimmedLine.length <= remaining) {\n            // Entire line fits on last line\n            lines[lines.length - 1] += `${separator}${trimmedLine}`;\n            break;\n          } else {\n            // Find largest portion of line that fits on last line,\n            // by searching backward for a whitespace character (space or tab).\n            let breakpoint = Math.max(\n              trimmedLine.lastIndexOf(' ', remaining),\n              trimmedLine.lastIndexOf('\\t', remaining)\n            );\n            if (breakpoint < 0) {\n              // Next word is too long to fit on the current line.\n              if (lastLine) {\n                // Start a new line and try again next round.\n                lines.push('');\n                continue;\n              } else {\n                // Next word is too long to fit on a line by itself.\n                // Break it at the next word boundary, if there is one.\n                breakpoint = trimmedLine.search(/[ \\t]/);\n                if (breakpoint < 0) breakpoint = line.length;\n              }\n            }\n\n            // Split the line into the part that fits on the last line\n            // and the remainder.  Start a new line for the remainder.\n            lines[lines.length - 1] += `${separator}${trimmedLine.slice(0, breakpoint).trimEnd()}`;\n            line = line.slice(breakpoint + 1);\n            lines.push('');\n          }\n        }\n      }\n\n      // Drop final empty content line.\n      if (lines[lines.length - 1] === '') {\n        lines.pop();\n      }\n\n      for (let i = 0; i < lines.length; i++) {\n        if (commentType.singleLine) {\n          lines[i] = `${indent}${commentType.start}${indentAfterComment}${lines[i]}`;\n        } else {\n          if (i === 0) {\n            if (lines[i] === '') {\n              lines[i] = `${indent}${commentType.start}`;\n            } else {\n              lines[i] = `${indent}${commentType.start} ${lines[i]}`;\n            }\n            if (i === lines.length - 1) {\n              lines[i] += ` ${commentType.final}`;\n            }\n          } else if (i === lines.length - 1) {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.final}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]} ${commentType.final}`;\n            }\n          } else {\n            if (lines[i] === '') {\n              lines[i] = `${indent} ${commentType.inner}`;\n            } else {\n              lines[i] = `${indent} ${commentType.inner} ${lines[i]}`;\n            }\n          }\n        }\n      }\n\n      result.push(...lines);\n    }\n\n    return result.join('\\n');\n  }\n\n  public async run(vimState: VimState, start: Position, end: Position): Promise<void> {\n    [start, end] = sorted(start, end);\n\n    start = start.getLineBegin();\n    end = end.getLineEnd();\n\n    let textToReflow = vimState.document.getText(new vscode.Range(start, end));\n    textToReflow = this.reflowParagraph(textToReflow);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: textToReflow,\n      range: new vscode.Range(start, end),\n      // Move cursor to front of line to realign the view\n      diff: PositionDiff.exactCharacter({ character: 0 }),\n    });\n\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n","import { VimState } from '../../../state/vimState';\nimport { configuration } from './../../../configuration/configuration';\nimport { Mode, isVisualMode } from './../../../mode/mode';\nimport { RegisterAction, BaseCommand } from './../../base';\nimport { EasyMotion } from './easymotion';\nimport {\n  EasyMotionCharMoveOpions,\n  EasyMotionMoveOptionsBase,\n  EasyMotionWordMoveOpions,\n  EasyMotionSearchAction,\n  Match,\n  SearchOptions,\n} from './types';\nimport { globalState } from '../../../state/globalState';\nimport { TextEditor } from '../../../textEditor';\nimport { MarkerGenerator } from './markerGenerator';\nimport { Position } from 'vscode';\n\nexport interface EasymotionTrigger {\n  key: string;\n  leaderCount?: number;\n}\n\nexport function buildTriggerKeys(trigger: EasymotionTrigger) {\n  return [\n    ...Array.from({ length: trigger.leaderCount || 2 }, () => '<leader>'),\n    ...trigger.key.split(''),\n  ];\n}\n\nabstract class BaseEasyMotionCommand extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n\n  private _baseOptions: EasyMotionMoveOptionsBase;\n\n  public abstract getMatches(position: Position, vimState: VimState): Match[];\n\n  constructor(baseOptions: EasyMotionMoveOptionsBase) {\n    super();\n    this._baseOptions = baseOptions;\n  }\n\n  public abstract resolveMatchPosition(match: Match): Position;\n\n  public processMarkers(matches: Match[], cursorPosition: Position, vimState: VimState) {\n    // Clear existing markers, just in case\n    vimState.easyMotion.clearMarkers();\n\n    let index = 0;\n    const markerGenerator = new MarkerGenerator(matches.length);\n    for (const match of matches) {\n      const matchPosition = this.resolveMatchPosition(match);\n      // Skip if the match position equals to cursor position\n      if (!matchPosition.isEqual(cursorPosition)) {\n        const marker = markerGenerator.generateMarker(index++, matchPosition);\n        if (marker) {\n          vimState.easyMotion.addMarker(marker);\n        }\n      }\n    }\n  }\n\n  protected searchOptions(position: Position): SearchOptions {\n    switch (this._baseOptions.searchOptions) {\n      case 'min':\n        return { min: position };\n      case 'max':\n        return { max: position };\n      default:\n        return {};\n    }\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if the configuration is set\n    if (configuration.easymotion) {\n      // Search all occurences of the character pressed\n      const matches = this.getMatches(position, vimState);\n\n      // Stop if there are no matches\n      if (matches.length > 0) {\n        vimState.easyMotion = new EasyMotion();\n        this.processMarkers(matches, position, vimState);\n\n        if (matches.length === 1) {\n          // Only one found, navigate to it\n          const marker = vimState.easyMotion.markers[0];\n          // Set cursor position based on marker entered\n          vimState.cursorStopPosition = marker.position;\n          vimState.easyMotion.clearDecorations(vimState.editor);\n        } else {\n          // Store mode to return to after performing easy motion\n          vimState.easyMotion.previousMode = vimState.currentMode;\n          // Enter the EasyMotion mode and await further keys\n          await vimState.setCurrentMode(Mode.EasyMotionMode);\n        }\n      }\n    }\n  }\n}\n\nfunction getMatchesForString(\n  position: Position,\n  vimState: VimState,\n  searchString: string,\n  options?: SearchOptions\n): Match[] {\n  switch (searchString) {\n    case '':\n      return [];\n    case ' ':\n      // Searching for space should only find the first space\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(' {1,}', 'g'),\n        options\n      );\n    default:\n      // Search all occurences of the character pressed\n\n      // If the input is not a letter, treating it as regex can cause issues\n      if (!/[a-zA-Z]/.test(searchString)) {\n        return vimState.easyMotion.sortedSearch(vimState.document, position, searchString, options);\n      }\n\n      const ignorecase =\n        configuration.ignorecase && !(configuration.smartcase && /[A-Z]/.test(searchString));\n      const regexFlags = ignorecase ? 'gi' : 'g';\n      return vimState.easyMotion.sortedSearch(\n        vimState.document,\n        position,\n        new RegExp(searchString, regexFlags),\n        options\n      );\n  }\n}\n\nexport class SearchByCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  keys = [];\n  public searchString: string = '';\n  private _options: EasyMotionCharMoveOpions;\n\n  get searchCharCount() {\n    return this._options.charCount;\n  }\n\n  constructor(options: EasyMotionCharMoveOpions) {\n    super(options);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(position, vimState, this.searchString, this.searchOptions(position));\n  }\n\n  public shouldFire() {\n    const charCount = this._options.charCount;\n    return charCount ? this.searchString.length >= charCount : true;\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    await this.exec(position, vimState);\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + this._options.charCount);\n      case 'before':\n        return new Position(line, Math.max(0, character - 1));\n      default:\n        return match.position;\n    }\n  }\n}\n\nexport class SearchByNCharCommand extends BaseEasyMotionCommand implements EasyMotionSearchAction {\n  keys = [];\n  public searchString: string = '';\n\n  get searchCharCount() {\n    return -1;\n  }\n\n  constructor() {\n    super({});\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return getMatchesForString(\n      position,\n      vimState,\n      this.removeTrailingLineBreak(this.searchString),\n      {}\n    );\n  }\n\n  private removeTrailingLineBreak(s: string) {\n    return s.replace(new RegExp('\\n+$', 'g'), '');\n  }\n\n  public shouldFire() {\n    // Fire when <CR> typed\n    return this.searchString.endsWith('\\n');\n  }\n\n  public async fire(position: Position, vimState: VimState): Promise<void> {\n    if (this.removeTrailingLineBreak(this.searchString) !== '') {\n      await this.exec(position, vimState);\n    }\n  }\n}\n\nexport abstract class EasyMotionCharMoveCommandBase extends BaseCommand {\n  modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  private _action: EasyMotionSearchAction;\n\n  constructor(action: EasyMotionSearchAction) {\n    super();\n    this._action = action;\n  }\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    // Only execute the action if easymotion is enabled\n    if (configuration.easymotion) {\n      vimState.easyMotion = new EasyMotion();\n      vimState.easyMotion.previousMode = vimState.currentMode;\n      vimState.easyMotion.searchAction = this._action;\n      globalState.hl = true;\n\n      await vimState.setCurrentMode(Mode.EasyMotionInputMode);\n    }\n  }\n}\n\nexport abstract class EasyMotionWordMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionWordMoveOpions;\n\n  constructor(options: EasyMotionWordMoveOpions = {}) {\n    super(options);\n    this._options = options;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForWord(position, vimState, this.searchOptions(position));\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    const { line, character } = match.position;\n    switch (this._options.labelPosition) {\n      case 'after':\n        return new Position(line, character + match.text.length - 1);\n      default:\n        return match.position;\n    }\n  }\n\n  private getMatchesForWord(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    const regex = this._options.jumpToAnywhere\n      ? new RegExp(configuration.easymotionJumpToAnywhereRegex, 'g')\n      : new RegExp('\\\\w{1,}', 'g');\n    return vimState.easyMotion.sortedSearch(vimState.document, position, regex, options);\n  }\n}\n\nexport abstract class EasyMotionLineMoveCommandBase extends BaseEasyMotionCommand {\n  private _options: EasyMotionMoveOptionsBase;\n\n  constructor(options: EasyMotionMoveOptionsBase = {}) {\n    super(options);\n    this._options = options;\n  }\n\n  public resolveMatchPosition(match: Match): Position {\n    return match.position;\n  }\n\n  public getMatches(position: Position, vimState: VimState): Match[] {\n    return this.getMatchesForLineStart(position, vimState, this.searchOptions(position));\n  }\n\n  private getMatchesForLineStart(\n    position: Position,\n    vimState: VimState,\n    options?: SearchOptions\n  ): Match[] {\n    // Search for the beginning of all non whitespace chars on each line before the cursor\n    const matches = vimState.easyMotion.sortedSearch(\n      vimState.document,\n      position,\n      new RegExp('^.', 'gm'),\n      options\n    );\n    for (const match of matches) {\n      match.position = TextEditor.getFirstNonWhitespaceCharOnLine(\n        vimState.document,\n        match.position.line\n      );\n    }\n    return matches;\n  }\n}\n\n@RegisterAction\nclass EasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<character>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    const action = vimState.easyMotion.searchAction;\n    action.searchString =\n      key === '<BS>' || key === '<S-BS>'\n        ? action.searchString.slice(0, -1)\n        : action.searchString + key;\n    if (action.shouldFire()) {\n      // Skip Easymotion input mode to make sure not to back to it\n      await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      await action.fire(vimState.cursorStopPosition, vimState);\n    }\n  }\n}\n\n@RegisterAction\nclass CommandEscEasyMotionCharInputMode extends BaseCommand {\n  modes = [Mode.EasyMotionInputMode];\n  keys = ['<Esc>'];\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n  }\n}\n\n@RegisterAction\nclass MoveEasyMotion extends BaseCommand {\n  modes = [Mode.EasyMotionMode];\n  keys = ['<character>'];\n  override isJump = true;\n\n  public override async exec(position: Position, vimState: VimState): Promise<void> {\n    const key = this.keysPressed[0];\n    if (key) {\n      // \"nail\" refers to the accumulated depth keys\n      const nail = vimState.easyMotion.accumulation + key;\n      vimState.easyMotion.accumulation = nail;\n\n      // Find markers starting with \"nail\"\n      const markers = vimState.easyMotion.findMarkers(nail, true);\n\n      if (markers.length === 1) {\n        // Only one found, navigate to it\n        const marker = markers[0];\n\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        // Restore the mode from before easy motion\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n\n        // Set cursor position based on marker entered\n        vimState.cursorStopPosition = marker.position;\n      } else if (markers.length === 0) {\n        // None found, exit mode\n        vimState.easyMotion.clearDecorations(vimState.editor);\n        await vimState.setCurrentMode(vimState.easyMotion.previousMode);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../../configuration/configuration';\nimport { TextEditor } from './../../../textEditor';\nimport { IEasyMotion, EasyMotionSearchAction, Marker, Match, SearchOptions } from './types';\nimport { Mode } from '../../../mode/mode';\nimport { Position } from 'vscode';\n\nexport class EasyMotion implements IEasyMotion {\n  /**\n   * Refers to the accumulated keys for depth navigation\n   */\n  public accumulation = '';\n\n  // TODO: is this actually always set?\n  public searchAction!: EasyMotionSearchAction;\n\n  /**\n   * Array of all markers and decorations\n   */\n  public readonly markers: Marker[];\n\n  private visibleMarkers: Marker[]; // Array of currently showing markers\n  private decorations: vscode.DecorationOptions[][];\n\n  private static readonly fade = vscode.window.createTextEditorDecorationType({\n    color: configuration.easymotionDimColor,\n  });\n  private static readonly hide = vscode.window.createTextEditorDecorationType({\n    color: 'transparent',\n  });\n\n  /**\n   * TODO: For future motions\n   */\n  private static specialCharactersRegex: RegExp = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n\n  /**\n   * Caches for decorations\n   */\n  private static decorationTypeCache: vscode.TextEditorDecorationType[] = [];\n\n  /**\n   * Mode to return to after attempting easymotion\n   */\n  // TODO: make this optional (in some circumstances it isn't actually set)\n  public previousMode!: Mode;\n\n  constructor() {\n    this.markers = [];\n    this.visibleMarkers = [];\n    this.decorations = [];\n  }\n\n  /**\n   * Create and cache decoration types for different marker lengths\n   */\n  public static getDecorationType(\n    length: number,\n    decorations?: vscode.DecorationRenderOptions\n  ): vscode.TextEditorDecorationType {\n    const cache = this.decorationTypeCache[length];\n    if (cache) {\n      return cache;\n    } else {\n      const type = vscode.window.createTextEditorDecorationType(decorations || {});\n\n      this.decorationTypeCache[length] = type;\n\n      return type;\n    }\n  }\n\n  /**\n   * Clear all decorations\n   */\n  public clearDecorations(editor: vscode.TextEditor) {\n    for (let i = 1; i <= this.decorations.length; i++) {\n      editor.setDecorations(EasyMotion.getDecorationType(i), []);\n    }\n\n    editor.setDecorations(EasyMotion.fade, []);\n    editor.setDecorations(EasyMotion.hide, []);\n  }\n\n  /**\n   * Clear all markers\n   */\n  public clearMarkers() {\n    while (this.markers.length) {\n      this.markers.pop();\n    }\n    this.visibleMarkers = [];\n  }\n\n  public addMarker(marker: Marker) {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Find markers beginning with a string\n   */\n  public findMarkers(nail: string, onlyVisible: boolean): Marker[] {\n    const markers = onlyVisible ? this.visibleMarkers : this.markers;\n    return markers.filter((marker) => marker.name.startsWith(nail));\n  }\n\n  /**\n   * Search and sort using the index of a match compared to the index of position (usually the cursor)\n   */\n  public sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search: string | RegExp = '',\n    options: SearchOptions = {}\n  ): Match[] {\n    const regex =\n      typeof search === 'string'\n        ? new RegExp(search.replace(EasyMotion.specialCharactersRegex, '\\\\$&'), 'g')\n        : search;\n\n    const matches: Match[] = [];\n\n    // Cursor index refers to the index of the marker that is on or to the right of the cursor\n    let cursorIndex = position.character;\n    let prevMatch: Match | undefined;\n\n    // Calculate the min/max bounds for the search\n    const lineCount = document.lineCount;\n    const lineMin = options.min ? Math.max(options.min.line, 0) : 0;\n    const lineMax = options.max ? Math.min(options.max.line + 1, lineCount) : lineCount;\n\n    outer: for (let lineIdx = lineMin; lineIdx < lineMax; lineIdx++) {\n      const line = document.lineAt(lineIdx).text;\n      let result = regex.exec(line);\n\n      while (result) {\n        if (matches.length >= 1000) {\n          break outer;\n        } else {\n          const pos = new Position(lineIdx, result.index);\n\n          // Check if match is within bounds\n          if (\n            (options.min && pos.isBefore(options.min)) ||\n            (options.max && pos.isAfter(options.max)) ||\n            Math.abs(pos.line - position.line) > 100\n          ) {\n            // Stop searching after 100 lines in both directions\n            result = regex.exec(line);\n          } else {\n            // Update cursor index to the marker on the right side of the cursor\n            if (!prevMatch || prevMatch.position.isBefore(position)) {\n              cursorIndex = matches.length;\n            }\n            // Matches on the cursor position should be ignored\n            if (pos.isEqual(position)) {\n              result = regex.exec(line);\n            } else {\n              prevMatch = new Match(pos, result[0], matches.length);\n              matches.push(prevMatch);\n              result = regex.exec(line);\n            }\n          }\n        }\n      }\n    }\n\n    // Sort by the index distance from the cursor index\n    matches.sort((a: Match, b: Match): number => {\n      const absDiffA = computeAboluteDiff(a.index);\n      const absDiffB = computeAboluteDiff(b.index);\n      return absDiffA - absDiffB;\n\n      function computeAboluteDiff(matchIndex: number) {\n        const absDiff = Math.abs(cursorIndex - matchIndex);\n        // Prioritize the matches on the right side of the cursor index\n        return matchIndex < cursorIndex ? absDiff - 0.5 : absDiff;\n      }\n    });\n\n    return matches;\n  }\n\n  private getMarkerColor(\n    customizedValue: string,\n    themeColorId: string\n  ): string | vscode.ThemeColor {\n    if (customizedValue) {\n      return customizedValue;\n    } else if (!themeColorId.startsWith('#')) {\n      return new vscode.ThemeColor(themeColorId);\n    } else {\n      return themeColorId;\n    }\n  }\n\n  private getEasymotionMarkerBackgroundColor() {\n    return this.getMarkerColor(configuration.easymotionMarkerBackgroundColor, '#0000');\n  }\n\n  private getEasymotionMarkerForegroundColorOneChar() {\n    return this.getMarkerColor(configuration.easymotionMarkerForegroundColorOneChar, '#ff0000');\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharFirst() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharFirst,\n      '#ffb400'\n    );\n  }\n\n  private getEasymotionMarkerForegroundColorTwoCharSecond() {\n    return this.getMarkerColor(\n      configuration.easymotionMarkerForegroundColorTwoCharSecond,\n      '#b98300'\n    );\n  }\n\n  private getEasymotionDimColor() {\n    return this.getMarkerColor(configuration.easymotionDimColor, '#777777');\n  }\n\n  public updateDecorations(editor: vscode.TextEditor) {\n    this.clearDecorations(editor);\n\n    this.visibleMarkers = [];\n    this.decorations = [];\n\n    // Set the decorations for all the different marker lengths\n    const dimmingZones: vscode.DecorationOptions[] = [];\n    const dimmingRenderOptions: vscode.ThemableDecorationRenderOptions = {\n      // we update the color here again in case the configuration has changed\n      color: this.getEasymotionDimColor(),\n    };\n    // Why this instead of `background-color` on the marker?\n    // The easy fix would've been to let the user set the marker background to the same\n    // color as the editor so it would hide the character behind, However this would require\n    // the user to do more work, with this solution we temporarily hide the marked character\n    // so no user specific setting is needed\n    const hiddenChars: vscode.Range[] = [];\n    const markers = this.markers\n      .filter((m) => m.name.startsWith(this.accumulation))\n      .sort((a, b) => (a.position.isBefore(b.position) ? -1 : 1));\n\n    // Ignore markers that do not start with the accumulated depth level\n    for (const marker of markers) {\n      const pos = marker.position;\n      // Get keys after the depth we're at\n      const keystroke = marker.name.substr(this.accumulation.length);\n\n      if (!this.decorations[keystroke.length]) {\n        this.decorations[keystroke.length] = [];\n      }\n\n      //#region Hack (remove once backend handles this)\n\n      /*\n        This hack is here because the backend for easy motion reports two adjacent\n        2 char markers resulting in a 4 char wide markers, this isn't what happens in\n        original easymotion for instance: for doom\n            - original reports d[m][m2]m where [m] is a marker and [m2] is secondary\n            - here it reports d[m][m][m][m]m\n        The reason this won't work with current impl is that it overflows resulting in\n        one extra hidden character, hence the check below (until backend truely mimics original)\n\n        if two consecutive 2 char markers, we only use the first char from the current marker\n        and reduce the char substitution by 1. Once backend properly reports adjacent markers\n        all instances of `trim` can be removed\n      */\n      let trim = 0;\n      const next = markers[markers.indexOf(marker) + 1];\n\n      if (\n        next &&\n        next.position.character - pos.character === 1 &&\n        next.position.line === pos.line\n      ) {\n        const nextKeystroke = next.name.substr(this.accumulation.length);\n\n        if (keystroke.length > 1 && nextKeystroke.length > 1) {\n          trim = -1;\n        }\n      }\n\n      //#endregion\n\n      // First Char/One Char decoration\n      const firstCharFontColor =\n        keystroke.length > 1\n          ? this.getEasymotionMarkerForegroundColorTwoCharFirst()\n          : this.getEasymotionMarkerForegroundColorOneChar();\n      const backgroundColor = this.getEasymotionMarkerBackgroundColor();\n      const firstCharRange = new vscode.Range(pos.line, pos.character, pos.line, pos.character);\n      const firstCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n        before: {\n          contentText: keystroke.substring(0, 1),\n          backgroundColor,\n          color: firstCharFontColor,\n          margin: `0 -1ch 0 0;\n          position: absolute;\n          font-weight: ${configuration.easymotionMarkerFontWeight};`,\n          height: '100%',\n        },\n      };\n\n      this.decorations[keystroke.length].push({\n        range: firstCharRange,\n        renderOptions: {\n          dark: firstCharRenderOptions,\n          light: firstCharRenderOptions,\n        },\n      });\n\n      // Second Char decoration\n      if (keystroke.length + trim > 1) {\n        const secondCharFontColor = this.getEasymotionMarkerForegroundColorTwoCharSecond();\n        const secondCharRange = new vscode.Range(\n          pos.line,\n          pos.character + 1,\n          pos.line,\n          pos.character + 1\n        );\n\n        const secondCharRenderOptions: vscode.ThemableDecorationInstanceRenderOptions = {\n          before: {\n            contentText: keystroke.slice(1),\n            backgroundColor,\n            color: secondCharFontColor,\n            margin: `0 -1ch 0 0;\n            position: absolute;\n            font-weight: ${configuration.easymotionMarkerFontWeight};`,\n            height: '100%',\n          },\n        };\n        this.decorations[keystroke.length].push({\n          range: secondCharRange,\n          renderOptions: {\n            dark: secondCharRenderOptions,\n            light: secondCharRenderOptions,\n          },\n        });\n      }\n\n      hiddenChars.push(\n        new vscode.Range(pos.line, pos.character, pos.line, pos.character + keystroke.length + trim)\n      );\n\n      if (configuration.easymotionDimBackground) {\n        // This excludes markers from the dimming ranges by using them as anchors\n        // each marker adds the range between it and previous marker to the dimming zone\n        // except last marker after which the rest of document is dimmed\n        //\n        // example [m1] text that has multiple [m2] marks\n        // |<------    |<----------------------     ---->|\n        if (dimmingZones.length === 0) {\n          dimmingZones.push({\n            range: new vscode.Range(0, 0, pos.line, pos.character),\n            renderOptions: dimmingRenderOptions,\n          });\n        } else {\n          const prevMarker = markers[markers.indexOf(marker) - 1];\n          const prevKeystroke = prevMarker.name.substring(this.accumulation.length);\n          const prevDimPos = prevMarker.position;\n          const offsetPrevDimPos = prevDimPos.withColumn(\n            prevDimPos.character + prevKeystroke.length\n          );\n\n          // Don't create dimming ranges in between consecutive markers (the 'after' is in the cases\n          // where you have 2 char consecutive markers where the first one only shows the first char.\n          // since we don't take that into account when creating 'offsetPrevDimPos' it will be after\n          // the current marker position which means we are in the middle of two consecutive markers.\n          // See the hack region above.)\n          if (!offsetPrevDimPos.isAfterOrEqual(pos)) {\n            dimmingZones.push({\n              range: new vscode.Range(\n                offsetPrevDimPos.line,\n                offsetPrevDimPos.character,\n                pos.line,\n                pos.character\n              ),\n              renderOptions: dimmingRenderOptions,\n            });\n          }\n        }\n      }\n\n      this.visibleMarkers.push(marker);\n    }\n\n    // for the last marker dim till document end\n    if (configuration.easymotionDimBackground && markers.length > 0) {\n      const prevMarker = markers[markers.length - 1];\n      const prevKeystroke = prevMarker.name.substring(this.accumulation.length);\n      const prevDimPos = dimmingZones[dimmingZones.length - 1].range.end;\n      const offsetPrevDimPos = prevDimPos.withColumn(prevDimPos.character + prevKeystroke.length);\n\n      // Don't create any more dimming ranges when the last marker is at document end\n      if (!offsetPrevDimPos.isEqual(TextEditor.getDocumentEnd(editor.document))) {\n        dimmingZones.push({\n          range: new vscode.Range(\n            offsetPrevDimPos,\n            new Position(editor.document.lineCount, Number.MAX_VALUE)\n          ),\n          renderOptions: dimmingRenderOptions,\n        });\n      }\n    }\n\n    for (let j = 1; j < this.decorations.length; j++) {\n      if (this.decorations[j]) {\n        editor.setDecorations(EasyMotion.getDecorationType(j), this.decorations[j]);\n      }\n    }\n\n    editor.setDecorations(EasyMotion.hide, hiddenChars);\n\n    if (configuration.easymotionDimBackground) {\n      editor.setDecorations(EasyMotion.fade, dimmingZones);\n    }\n  }\n}\n","import { Position } from 'vscode';\nimport { configuration } from './../../../configuration/configuration';\nimport { Marker } from './types';\n\nexport class MarkerGenerator {\n  private matchesCount: number;\n  private keyTable: string[];\n  private prefixKeyTable: string[];\n\n  constructor(matchesCount: number) {\n    this.matchesCount = matchesCount;\n    this.keyTable = this.getKeyTable();\n    this.prefixKeyTable = this.createPrefixKeyTable();\n  }\n\n  public generateMarker(index: number, markerPosition: Position): Marker | null {\n    const { keyTable, prefixKeyTable } = this;\n\n    if (index >= keyTable.length - prefixKeyTable.length) {\n      const remainder = index - (keyTable.length - prefixKeyTable.length);\n      const currentStep = Math.floor(remainder / keyTable.length) + 1;\n      if (currentStep > prefixKeyTable.length) {\n        return null;\n      } else {\n        const prefix = prefixKeyTable[currentStep - 1];\n        const label = keyTable[remainder % keyTable.length];\n        return {\n          name: prefix + label,\n          position: markerPosition,\n        };\n      }\n    } else {\n      return {\n        name: keyTable[index],\n        position: markerPosition,\n      };\n    }\n  }\n\n  private createPrefixKeyTable(): string[] {\n    const totalRemainder = Math.max(this.matchesCount - this.keyTable.length, 0);\n    const totalSteps = Math.ceil(totalRemainder / this.keyTable.length);\n    const reversed = this.keyTable.slice().reverse();\n    const count = Math.min(totalSteps, reversed.length);\n    return reversed.slice(0, count);\n  }\n\n  /**\n   * The key sequence for marker name generation\n   */\n  private getKeyTable(): string[] {\n    if (configuration.easymotionKeys) {\n      return configuration.easymotionKeys.split('');\n    } else {\n      return 'hklyuiopnm,qwertzxcvbasdgjf;'.split('');\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\nimport { Mode } from '../../../mode/mode';\nimport type { VimState } from '../../../state/vimState';\n\nexport type LabelPosition = 'after' | 'before';\nexport type JumpToAnywhere = true | false;\n\nexport interface EasyMotionMoveOptionsBase {\n  searchOptions?: 'min' | 'max';\n}\n\nexport interface EasyMotionCharMoveOpions extends EasyMotionMoveOptionsBase {\n  charCount: number;\n  labelPosition?: LabelPosition;\n}\n\nexport interface EasyMotionWordMoveOpions extends EasyMotionMoveOptionsBase {\n  labelPosition?: LabelPosition;\n  jumpToAnywhere?: JumpToAnywhere;\n}\n\nexport interface Marker {\n  name: string;\n  position: Position;\n}\n\nexport class Match {\n  public position: Position;\n  public readonly text: string;\n  public readonly index: number;\n\n  constructor(position: Position, text: string, index: number) {\n    this.position = position;\n    this.text = text;\n    this.index = index;\n  }\n\n  public toRange(): vscode.Range {\n    return new vscode.Range(this.position, this.position.translate(0, this.text.length));\n  }\n}\n\nexport interface SearchOptions {\n  /**\n   * The minimum bound of the search\n   */\n  min?: Position;\n\n  /**\n   * The maximum bound of the search\n   */\n  max?: Position;\n}\n\nexport interface EasyMotionSearchAction {\n  searchString: string;\n\n  /**\n   * True if it should go to Easymotion mode\n   */\n  shouldFire(): boolean;\n\n  /**\n   * Command to execute when it should fire\n   */\n  fire(position: Position, vimState: VimState): Promise<void>;\n  getMatches(position: Position, vimState: VimState): Match[];\n  readonly searchCharCount: number;\n}\n\nexport interface IEasyMotion {\n  accumulation: string;\n  previousMode: Mode;\n  markers: Marker[];\n  searchAction: EasyMotionSearchAction;\n\n  addMarker(marker: Marker): void;\n  findMarkers(nail: string, onlyVisible: boolean): Marker[];\n  sortedSearch(\n    document: vscode.TextDocument,\n    position: Position,\n    search?: string | RegExp,\n    options?: SearchOptions\n  ): Match[];\n  updateDecorations(editor: vscode.TextEditor): void;\n  clearMarkers(): void;\n  clearDecorations(editor: vscode.TextEditor): void;\n}\n","import { IConfiguration, IKeyRemapping } from '../../configuration/iconfiguration';\n\nexport class PluginDefaultMappings {\n  // plugin authers may add entries here\n  private static defaultMappings: Array<{\n    mode: string;\n    configSwitch: string;\n    mapping: IKeyRemapping;\n  }> = [\n    // default maps for surround\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['y', 's'], after: ['<plugys>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['y', 's', 's'], after: ['<plugys>', '<plugys>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['c', 's'], after: ['<plugcs>'] },\n    },\n    {\n      mode: 'normalModeKeyBindingsNonRecursive',\n      configSwitch: 'surround',\n      mapping: { before: ['d', 's'], after: ['<plugds>'] },\n    },\n  ];\n\n  public static getPluginDefaultMappings(mode: string, config: IConfiguration): IKeyRemapping[] {\n    return this.defaultMappings\n      .filter((m) => m.mode === mode && config[m.configSwitch])\n      .map((m) => m.mapping);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { configuration } from './../../configuration/configuration';\nimport { RegisterAction } from './../base';\nimport { BaseMovement, IMovement } from '../baseMotion';\nimport { Position } from 'vscode';\n\n@RegisterAction\nexport class SneakForward extends BaseMovement {\n  keys = [\n    ['s', '<character>', '<character>'],\n    ['z', '<character>', '<character>'],\n  ];\n  override isJump = true;\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 's' : 'z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakForward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakBackward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    const lineCount = document.lineCount;\n    for (let i = position.line; i < lineCount; ++i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching after the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character + 1 : 0;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .indexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.indexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n\n@RegisterAction\nexport class SneakBackward extends BaseMovement {\n  keys = [\n    ['S', '<character>', '<character>'],\n    ['Z', '<character>', '<character>'],\n  ];\n  override isJump = true;\n\n  public override couldActionApply(vimState: VimState, keysPressed: string[]): boolean {\n    const startingLetter = vimState.recordedState.operator === undefined ? 'S' : 'Z';\n\n    return (\n      configuration.sneak &&\n      super.couldActionApply(vimState, keysPressed) &&\n      keysPressed[0] === startingLetter\n    );\n  }\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState\n  ): Promise<Position | IMovement> {\n    if (!this.isRepeat) {\n      vimState.lastSemicolonRepeatableMovement = new SneakBackward(this.keysPressed, true);\n      vimState.lastCommaRepeatableMovement = new SneakForward(this.keysPressed, true);\n    }\n\n    if (this.keysPressed[2] === '\\n') {\n      // Single key sneak\n      this.keysPressed[2] = '';\n    }\n\n    const searchString = this.keysPressed[1] + this.keysPressed[2];\n\n    const document = vimState.document;\n    for (let i = position.line; i >= 0; --i) {\n      const lineText = document.lineAt(i).text;\n\n      // Start searching before the current character so we don't find the same match twice\n      const fromIndex = i === position.line ? position.character - 1 : +Infinity;\n\n      let matchIndex = -1;\n\n      const ignorecase =\n        configuration.sneakUseIgnorecaseAndSmartcase &&\n        configuration.ignorecase &&\n        !(configuration.smartcase && /[A-Z]/.test(searchString));\n\n      // Check for matches\n      if (ignorecase) {\n        matchIndex = lineText\n          .toLocaleLowerCase()\n          .lastIndexOf(searchString.toLocaleLowerCase(), fromIndex);\n      } else {\n        matchIndex = lineText.lastIndexOf(searchString, fromIndex);\n      }\n\n      if (matchIndex >= 0) {\n        return new Position(i, matchIndex);\n      }\n    }\n\n    return position;\n  }\n}\n","import { Position } from 'vscode';\nimport { TextDocument } from 'vscode';\nimport { configuration } from '../../../configuration/configuration';\n\ntype Quote = '\"' | \"'\" | '`';\nenum QuoteMatch {\n  Opening,\n  Closing,\n}\nexport type WhichQuotes = 'current' | 'next' | 'last';\ntype Dir = '>' | '<';\ntype SearchAction = {\n  first: Dir;\n  second: Dir;\n  includeCurrent: boolean;\n};\ntype QuotesAction = {\n  search: SearchAction | undefined;\n  skipToLeft: number; // for last quotes, how many quotes need to skip while searching\n  skipToRight: number; // for next quotes, how many quotes need to skip while searching\n};\n\n/**\n * This mapping is used to give a way to identify which action we need to take when operating on a line.\n * The keys here are, in some sense, the number of quotes in the line, in the format of `lcr`, where:\n * `l` means left of the cursor, `c` whether the cursor is on a quote, and `r` is right of the cursor.\n *\n * It is based on the ideas used in `targets.vim`. For each line & cursor position, we count the number of quotes\n * left (#L) and right (#R) of the cursor. Using those numbers and whether the cursor it on a quote, we know\n * what action to make.\n *\n * For each entry we have an example of a line & position.\n */\nconst quoteDirs: Record<string, QuotesAction> = {\n  '002': {\n    // | \"a\" \"b\" \"c\"\n    search: { first: '>', second: '>', includeCurrent: false },\n    skipToLeft: 0,\n    skipToRight: 1,\n  },\n  '012': {\n    // |\"a\" \"b\" \"c\" \"\n    search: { first: '>', second: '>', includeCurrent: true },\n    skipToLeft: 0,\n    skipToRight: 2,\n  },\n  '102': {\n    // \"a\" \"|b\" \"c\" \"\n    search: { first: '<', second: '>', includeCurrent: false },\n    skipToLeft: 2,\n    skipToRight: 2,\n  },\n  '112': {\n    //  \"a\" \"b|\" \"c\"\n    search: { first: '<', second: '<', includeCurrent: true },\n    skipToLeft: 2,\n    skipToRight: 1,\n  },\n  '202': {\n    //  \"a\"| \"b\" \"c\"\n    search: { first: '>', second: '>', includeCurrent: false },\n    skipToLeft: 1,\n    skipToRight: 1,\n  },\n  '211': {\n    //  \"a\" |\"b\" \"c\"\n    search: { first: '>', second: '>', includeCurrent: true },\n    skipToLeft: 1,\n    skipToRight: 2,\n  },\n  '101': {\n    //  \"a\" \"|b\" \"c\"\n    search: { first: '<', second: '>', includeCurrent: false },\n    skipToLeft: 2,\n    skipToRight: 2,\n  },\n  '011': {\n    //  |\"a\" \"b\" \"c\"\n    search: { first: '>', second: '>', includeCurrent: true },\n    skipToLeft: 0,\n    skipToRight: 2,\n  },\n  '110': {\n    //  \"a\" \"b\" \"c|\"\n    search: { first: '<', second: '<', includeCurrent: true },\n    skipToLeft: 2,\n    skipToRight: 0,\n  },\n  '212': {\n    //  \"a\" |\"b\" \"c\" \"\n    search: { first: '>', second: '>', includeCurrent: true },\n    skipToLeft: 1,\n    skipToRight: 2,\n  },\n  '111': {\n    //  \"a\" \"b|\" \"c\" \"\n    search: { first: '<', second: '<', includeCurrent: true },\n    skipToLeft: 2,\n    skipToRight: 1,\n  },\n  '200': {\n    //  \"a\" \"b\" \"c\"|\n    search: { first: '<', second: '<', includeCurrent: false },\n    skipToLeft: 1,\n    skipToRight: 0,\n  },\n  '201': {\n    //  \"a\" \"b\" \"c\"| \"\n    //  \"a\"| \"b\" \"c\" \"\n    search: { first: '>', second: '>', includeCurrent: false },\n    skipToLeft: 1,\n    skipToRight: 1,\n  },\n  '210': {\n    //  \"a\" \"b\" \"c\" |\"\n    search: undefined,\n    skipToLeft: 1,\n    skipToRight: 0,\n  },\n  '001': {\n    // | \"a\" \"b\" \"c\" \"\n    search: undefined,\n    skipToLeft: 0,\n    skipToRight: 1,\n  },\n  '010': {\n    //  a|\"b\n    search: undefined,\n    skipToLeft: 0,\n    skipToRight: 0,\n  },\n  '100': {\n    //  \"a\" \"b\" \"c\" \"|\n    search: undefined,\n    skipToLeft: 2,\n    skipToRight: 0,\n  },\n  '000': {\n    //  |ab\n    search: undefined,\n    skipToLeft: 0,\n    skipToRight: 0,\n  },\n};\n\nexport class SmartQuoteMatcher {\n  static readonly escapeChar = '\\\\';\n\n  private document: TextDocument;\n  private quote: Quote | 'any';\n\n  constructor(quote: Quote | 'any', document: TextDocument) {\n    this.quote = quote;\n    this.document = document;\n  }\n\n  private buildQuoteMap(text: string) {\n    const quoteMap: QuoteMatch[] = [];\n    let openingQuote = true;\n    // Loop over text, marking quotes and respecting escape characters.\n    for (let i = 0; i < text.length; i++) {\n      if (text[i] === SmartQuoteMatcher.escapeChar) {\n        i += 1;\n        continue;\n      }\n\n      if (\n        (this.quote === 'any' && (text[i] === '\"' || text[i] === \"'\" || text[i] === '`')) ||\n        text[i] === this.quote\n      ) {\n        quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n        openingQuote = !openingQuote;\n      }\n    }\n    return quoteMap;\n  }\n\n  private static lineSearchAction(cursorIndex: number, quoteMap: QuoteMatch[]) {\n    // base on ideas from targets.vim\n\n    // cut line in left of, on and right of cursor\n    const left = Array.from(quoteMap.entries()).slice(undefined, cursorIndex);\n    const cursor = quoteMap[cursorIndex];\n    const right = Array.from(quoteMap.entries()).slice(cursorIndex + 1, undefined);\n\n    // how many delimiters left, on and right of cursor\n    const lc = left.filter(([_, v]) => v !== undefined).length;\n    const cc = cursor !== undefined ? 1 : 0;\n    const rc = right.filter(([_, v]) => v !== undefined).length;\n\n    // truncate counts\n    const lct = lc === 0 ? 0 : lc % 2 === 0 ? 2 : 1;\n    const rct = rc === 0 ? 0 : rc >= 2 ? 2 : 1;\n\n    const key = `${lct}${cc}${rct}`;\n    const act = quoteDirs[key];\n\n    return act;\n  }\n\n  public smartSurroundingQuotes(\n    position: Position,\n    which: WhichQuotes\n  ): { start: Position; stop: Position; lineText: string } | undefined {\n    position = this.document.validatePosition(position);\n    const cursorIndex = position.character;\n    const lineText = this.document.lineAt(position).text;\n    const quoteMap = this.buildQuoteMap(lineText);\n\n    const act = SmartQuoteMatcher.lineSearchAction(cursorIndex, quoteMap);\n\n    if (which === 'current') {\n      if (act.search) {\n        const searchRes = this.smartSearch(cursorIndex, act.search, quoteMap);\n        return searchRes\n          ? {\n              start: position.with({ character: searchRes[0] }),\n              stop: position.with({ character: searchRes[1] }),\n              lineText,\n            }\n          : undefined;\n      } else {\n        return undefined;\n      }\n    } else if (which === 'next') {\n      // search quote in current line\n      const right = Array.from(quoteMap.entries()).slice(cursorIndex + 1, undefined);\n      const [index, found] = right.filter(([i, v]) => v !== undefined)[act.skipToRight] ?? [\n        +Infinity,\n        undefined,\n      ];\n      // find next position for surrounding quotes, possibly breaking through lines\n      let nextPos;\n      position = position.with({ character: index });\n      if (found === undefined && configuration.targets.smartQuotes.breakThroughLines) {\n        // nextPos = State.evalGenerator(this.getNextQuoteThroughLineBreaks(), position);\n        nextPos = this.getNextQuoteThroughLineBreaks(position);\n      } else {\n        nextPos = found !== undefined ? position : undefined;\n      }\n\n      // find surrounding with new position\n      if (nextPos) {\n        return this.smartSurroundingQuotes(nextPos, 'current');\n      } else {\n        return undefined;\n      }\n    } else if (which === 'last') {\n      // search quote in current line\n      const left = Array.from(quoteMap.entries()).slice(undefined, cursorIndex);\n      const [index, found] = left.reverse().filter(([i, v]) => v !== undefined)[act.skipToLeft] ?? [\n        0,\n        undefined,\n      ];\n      // find last position for surrounding quotes, possibly breaking through lines\n      let lastPos;\n      position = position.with({ character: index });\n      if (found === undefined && configuration.targets.smartQuotes.breakThroughLines) {\n        position = position.getLeftThroughLineBreaks();\n        lastPos = this.getLastQuoteThroughLineBreaks(position);\n      } else {\n        lastPos = found !== undefined ? position : undefined;\n      }\n\n      // find surrounding with new position\n      if (lastPos) {\n        return this.smartSurroundingQuotes(lastPos, 'current');\n      } else {\n        return undefined;\n      }\n    } else {\n      return undefined;\n    }\n  }\n\n  private smartSearch(\n    start: number,\n    action: SearchAction,\n    quoteMap: QuoteMatch[]\n  ): [number, number] | undefined {\n    const offset = action.includeCurrent ? 1 : 0;\n    let cursorPos: number | undefined = start;\n    let fst: number | undefined;\n    let snd: number | undefined;\n\n    if (action.first === '>') {\n      cursorPos = fst = this.getNextQuote(cursorPos - offset, quoteMap);\n    } else {\n      // dir === '<'\n      cursorPos = fst = this.getPrevQuote(cursorPos + offset, quoteMap);\n    }\n    if (cursorPos === undefined) return undefined;\n\n    if (action.second === '>') {\n      snd = this.getNextQuote(cursorPos, quoteMap);\n    } else {\n      // dir === '<'\n      snd = this.getPrevQuote(cursorPos, quoteMap);\n    }\n\n    if (fst === undefined || snd === undefined) return undefined;\n\n    if (fst < snd) return [fst, snd];\n    else return [snd, fst];\n  }\n\n  private getNextQuoteThroughLineBreaks(position: Position): Position | undefined {\n    for (let line = position.line; line < this.document.lineCount; line++) {\n      position = this.document.validatePosition(position.with({ line }));\n      const text = this.document.lineAt(position).text;\n      if (this.quote === 'any') {\n        for (let i = position.character; i < text.length; i++) {\n          if (text[i] === '\"' || text[i] === \"'\" || text[i] === '`') {\n            return position.with({ character: i });\n          }\n        }\n      } else {\n        const index = text.indexOf(this.quote, position.character);\n        if (index >= 0) {\n          return position.with({ character: index });\n        }\n      }\n      position = position.with({ character: 0 }); // set at line begin for next iteration\n    }\n    return undefined;\n  }\n  private getLastQuoteThroughLineBreaks(position: Position): Position | undefined {\n    for (let line = position.line; line >= 0; line--) {\n      position = this.document.validatePosition(position.with({ line }));\n      const text = this.document.lineAt(position).text;\n      if (this.quote === 'any') {\n        for (let i = position.character; i >= 0; i--) {\n          if (text[i] === '\"' || text[i] === \"'\" || text[i] === '`') {\n            return position.with({ character: i });\n          }\n        }\n      } else {\n        const index = text.lastIndexOf(this.quote, position.character);\n        if (index >= 0) {\n          return position.with({ character: index });\n        }\n      }\n      position = position.with({ character: +Infinity }); // set at line end for next iteration\n    }\n    return undefined;\n  }\n\n  private getNextQuote(start: number, quoteMap: QuoteMatch[]): number | undefined {\n    for (let i = start + 1; i < quoteMap.length; i++) {\n      if (quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  private getPrevQuote(start: number, quoteMap: QuoteMatch[]): number | undefined {\n    for (let i = start - 1; i >= 0; i--) {\n      if (quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n}\n","import { configuration } from '../../../configuration/configuration';\n\nexport function useSmartQuotes(): boolean {\n  return (\n    (configuration.targets.enable === true && configuration.targets.smartQuotes.enable !== false) ||\n    (configuration.targets.enable === undefined &&\n      configuration.targets.smartQuotes.enable === true)\n  );\n}\n\nexport function bracketObjectsEnabled(): boolean {\n  return (\n    (configuration.targets.enable === true &&\n      configuration.targets.bracketObjects.enable !== false) ||\n    (configuration.targets.enable === undefined &&\n      configuration.targets.bracketObjects.enable === true)\n  );\n}\n","import { configuration } from './../configuration/configuration';\nimport { Mode } from './../mode/mode';\n\n/**\n * See https://vimhelp.org/options.txt.html#%27whichwrap%27\n *\n * @returns true if the given key should cause the cursor to wrap around line boundary\n */\nexport const shouldWrapKey = (mode: Mode, key: string): boolean => {\n  let k: string;\n  if (key === '<left>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? '[' : '<';\n  } else if (key === '<right>') {\n    k = [Mode.Insert, Mode.Replace].includes(mode) ? ']' : '>';\n  } else if (['<BS>', '<C-BS>', '<S-BS>'].includes(key)) {\n    k = 'b';\n  } else if (key === ' ') {\n    k = 's';\n  } else if (['h', 'l', '~'].includes(key)) {\n    k = key;\n  } else {\n    throw new Error(`shouldWrapKey called with unexpected key='${key}'`);\n  }\n  return configuration.whichwrap.split(',').includes(k);\n};\n","import { CommandLineHistory, HistoryFile, SearchHistory } from '../history/historyFile';\nimport { Mode } from './../mode/mode';\nimport { Logger } from '../util/logger';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode } from '../error';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Register } from '../register/register';\nimport { RecordedState } from '../state/recordedState';\nimport { exCommandParser } from '../vimscript/exCommandParser';\nimport { IndexedPosition, IndexedRange, SearchState } from '../state/searchState';\nimport { getWordLeftInText, getWordRightInText, WordType } from '../textobject/word';\nimport { CommandShowCommandHistory, CommandShowSearchHistory } from '../actions/commands/actions';\nimport { SearchDirection } from '../vimscript/pattern';\nimport { reportSearch, escapeCSSIcons } from '../util/statusBarTextUtils';\nimport { SearchDecorations, getDecorationsForSearchMatchRanges } from '../util/decorationUtils';\nimport { Position, ExtensionContext, window } from 'vscode';\nimport { globalState } from '../state/globalState';\nimport { scrollView } from '../util/util';\nimport { ExCommand } from '../vimscript/exCommand';\nimport { LineRange } from '../vimscript/lineRange';\nimport { RegisterCommand } from './commands/register';\nimport { SubstituteCommand } from './commands/substitute';\n\nexport abstract class CommandLine {\n  public cursorIndex: number;\n  public previousMode: Mode;\n  protected historyIndex: number | undefined;\n  private savedText: string;\n\n  constructor(text: string, previousMode: Mode) {\n    this.cursorIndex = text.length;\n    this.historyIndex = this.getHistory().get().length;\n    this.previousMode = previousMode;\n    this.savedText = text;\n  }\n\n  /**\n   * @returns the text to be displayed in the status bar\n   */\n  public abstract display(cursorChar: string): string;\n\n  /**\n   * What the user has typed, minus any prefix, etc.\n   */\n  public abstract get text(): string;\n  public abstract set text(text: string);\n\n  /**\n   * @returns the SearchState associated with this CommandLine, if one exists\n   *\n   * This applies to `/`, `:s`, `:g`, `:v`, etc.\n   */\n  public abstract getSearchState(): SearchState | undefined;\n\n  public abstract getHistory(): HistoryFile;\n\n  public abstract getDecorations(vimState: VimState): SearchDecorations | undefined;\n\n  /**\n   * Called when `<Enter>` is pressed\n   */\n  public abstract run(vimState: VimState): Promise<void>;\n\n  /**\n   * Called when `<Esc>` is pressed\n   */\n  public abstract escape(vimState: VimState): Promise<void>;\n\n  /**\n   * Called when `<C-f>` is pressed\n   */\n  public abstract ctrlF(vimState: VimState): Promise<void>;\n\n  public async historyBack(): Promise<void> {\n    if (this.historyIndex === 0) {\n      return;\n    }\n\n    const historyEntries = this.getHistory().get();\n    if (this.historyIndex === undefined) {\n      this.historyIndex = historyEntries.length - 1;\n      this.savedText = this.text;\n    } else if (this.historyIndex > 0) {\n      this.historyIndex--;\n    }\n\n    this.text = historyEntries[this.historyIndex];\n    this.cursorIndex = this.text.length;\n  }\n\n  public async historyForward(): Promise<void> {\n    if (this.historyIndex === undefined) {\n      return;\n    }\n\n    const historyEntries = this.getHistory().get();\n    if (this.historyIndex === historyEntries.length - 1) {\n      this.historyIndex = undefined;\n      this.text = this.savedText;\n    } else if (this.historyIndex < historyEntries.length - 1) {\n      this.historyIndex++;\n      this.text = historyEntries[this.historyIndex];\n    }\n\n    this.cursorIndex = this.text.length;\n  }\n\n  /**\n   * Called when `<BS>` is pressed\n   */\n  public async backspace(vimState: VimState): Promise<void> {\n    if (this.cursorIndex === 0) {\n      if (this.text.length === 0) {\n        await this.escape(vimState);\n      }\n      return;\n    }\n\n    this.text = this.text.slice(0, this.cursorIndex - 1) + this.text.slice(this.cursorIndex);\n    this.cursorIndex = Math.max(this.cursorIndex - 1, 0);\n  }\n\n  /**\n   * Called when `<Del>` is pressed\n   */\n  public async delete(vimState: VimState): Promise<void> {\n    if (this.cursorIndex === this.text.length) {\n      return this.backspace(vimState);\n    }\n\n    this.text = this.text.slice(0, this.cursorIndex) + this.text.slice(this.cursorIndex + 1);\n  }\n\n  /**\n   * Called when `<Home>` is pressed\n   */\n  public async home(): Promise<void> {\n    this.cursorIndex = 0;\n  }\n\n  /**\n   * Called when `<End>` is pressed\n   */\n  public async end(): Promise<void> {\n    this.cursorIndex = this.text.length;\n  }\n\n  /**\n   * Called when `<C-Left>` is pressed\n   */\n  public async wordLeft(): Promise<void> {\n    this.cursorIndex = getWordLeftInText(this.text, this.cursorIndex, WordType.Big) ?? 0;\n  }\n\n  /**\n   * Called when `<C-Right>` is pressed\n   */\n  public async wordRight(): Promise<void> {\n    this.cursorIndex =\n      getWordRightInText(this.text, this.cursorIndex, WordType.Big) ?? this.text.length;\n  }\n\n  /**\n   * Called when `<C-BS>` is pressed\n   */\n  public async deleteWord(): Promise<void> {\n    const wordStart = getWordLeftInText(this.text, this.cursorIndex, WordType.Normal);\n    if (wordStart !== undefined) {\n      this.text = this.text.substring(0, wordStart).concat(this.text.slice(this.cursorIndex));\n      this.cursorIndex = this.cursorIndex - (this.cursorIndex - wordStart);\n    }\n  }\n\n  /**\n   * Called when `<C-BS>` is pressed\n   */\n  public async deleteToBeginning(): Promise<void> {\n    this.text = this.text.slice(this.cursorIndex);\n    this.cursorIndex = 0;\n  }\n\n  public async typeCharacter(char: string): Promise<void> {\n    const modifiedString = this.text.split('');\n    modifiedString.splice(this.cursorIndex, 0, char);\n    this.text = modifiedString.join('');\n    this.cursorIndex += char.length;\n  }\n}\n\nexport class ExCommandLine extends CommandLine {\n  static history: CommandLineHistory;\n\n  public static async loadHistory(context: ExtensionContext): Promise<void> {\n    ExCommandLine.history = new CommandLineHistory(context);\n    await ExCommandLine.history.load();\n  }\n\n  // TODO: Make this stuff private?\n  public autoCompleteIndex = 0;\n  public autoCompleteItems: string[] = [];\n  public preCompleteCharacterPos = 0;\n  public preCompleteCommand = '';\n\n  private commandText: string;\n  private lineRange: LineRange | undefined;\n  private command: ExCommand | undefined;\n\n  private static readonly logger = Logger.get('CommandLine');\n\n  constructor(commandText: string, previousMode: Mode) {\n    super(commandText, previousMode);\n    this.commandText = commandText;\n    this.text = commandText;\n    this.previousMode = previousMode;\n  }\n\n  public display(cursorChar: string): string {\n    return escapeCSSIcons(\n      `:${this.text.substring(0, this.cursorIndex)}${cursorChar}${this.text.substring(\n        this.cursorIndex\n      )}`\n    );\n  }\n\n  public get text(): string {\n    return this.commandText;\n  }\n  public set text(text: string) {\n    this.commandText = text;\n\n    try {\n      // TODO: This eager parsing is costly, and if it's not `:s` or similar, don't need to parse the args at all\n      const { lineRange, command } = exCommandParser.tryParse(this.commandText);\n      this.lineRange = lineRange;\n      this.command = command;\n    } catch (err) {\n      this.lineRange = undefined;\n      this.command = undefined;\n    }\n  }\n\n  public getSearchState(): SearchState | undefined {\n    return undefined;\n  }\n\n  public getDecorations(vimState: VimState): SearchDecorations | undefined {\n    return this.command instanceof SubstituteCommand &&\n      vimState.currentMode === Mode.CommandlineInProgress\n      ? this.command.getSubstitutionDecorations(vimState, this.lineRange)\n      : undefined;\n  }\n\n  public getHistory(): HistoryFile {\n    return ExCommandLine.history;\n  }\n\n  public async run(vimState: VimState): Promise<void> {\n    ExCommandLine.history.add(this.text);\n    this.historyIndex = ExCommandLine.history.get().length;\n\n    if (!(this.command instanceof RegisterCommand)) {\n      // TODO(jfields): Wait...why are we saving the `:` register as a RecordedState?\n      const recState = new RecordedState();\n      recState.registerName = ':';\n      recState.commandList = this.text.split('');\n      Register.setReadonlyRegister(':', recState);\n    }\n\n    try {\n      if (this.command === undefined) {\n        // TODO: A bit gross:\n        exCommandParser.tryParse(this.text);\n        throw new Error(`Expected parsing ExCommand '${this.text}' to fail`);\n      }\n\n      const useNeovim = configuration.enableNeovim && this.command.neovimCapable();\n      if (useNeovim && vimState.nvim) {\n        const { statusBarText, error } = await vimState.nvim.run(vimState, this.text);\n        StatusBar.setText(vimState, statusBarText, error);\n      } else {\n        if (this.lineRange) {\n          await this.command.executeWithRange(vimState, this.lineRange);\n        } else {\n          await this.command.execute(vimState);\n        }\n      }\n    } catch (e) {\n      if (e instanceof VimError) {\n        if (\n          e.code === ErrorCode.NotAnEditorCommand &&\n          configuration.enableNeovim &&\n          vimState.nvim\n        ) {\n          const { statusBarText } = await vimState.nvim.run(vimState, this.text);\n          StatusBar.setText(vimState, statusBarText, true);\n        } else {\n          StatusBar.setText(vimState, e.toString(), true);\n        }\n      } else {\n        ExCommandLine.logger.error(`Error executing cmd=${this.text}. err=${e}.`);\n      }\n    }\n\n    // Update state if this command is repeatable via dot command.\n    vimState.lastCommandDotRepeatable = this.command?.isRepeatableWithDot ?? false;\n  }\n\n  public async escape(vimState: VimState): Promise<void> {\n    await vimState.setCurrentMode(Mode.Normal);\n    if (this.text.length > 0) {\n      ExCommandLine.history.add(this.text);\n    }\n  }\n\n  public async ctrlF(vimState: VimState): Promise<void> {\n    new CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n  }\n}\n\nexport class SearchCommandLine extends CommandLine {\n  public static history: SearchHistory;\n  public static readonly previousSearchStates: SearchState[] = [];\n\n  /**\n   * Shows the search history as a QuickPick (popup list)\n   *\n   * @returns The SearchState that was selected by the user, if there was one.\n   */\n  public static async showSearchHistory(): Promise<SearchState | undefined> {\n    const items = SearchCommandLine.previousSearchStates\n      .slice()\n      .reverse()\n      .map((searchState) => {\n        return {\n          label: searchState.searchString,\n          searchState,\n        };\n      });\n\n    const item = await window.showQuickPick(items, {\n      placeHolder: 'Vim search history',\n      ignoreFocusOut: false,\n    });\n\n    return item?.searchState;\n  }\n\n  public static async loadHistory(context: ExtensionContext): Promise<void> {\n    SearchCommandLine.history = new SearchHistory(context);\n    SearchCommandLine.history\n      .get()\n      .forEach((val) =>\n        SearchCommandLine.previousSearchStates.push(\n          new SearchState(SearchDirection.Forward, new Position(0, 0), val, undefined)\n        )\n      );\n  }\n\n  public static async addSearchStateToHistory(searchState: SearchState) {\n    const prevSearchString =\n      SearchCommandLine.previousSearchStates.length === 0\n        ? undefined\n        : SearchCommandLine.previousSearchStates[SearchCommandLine.previousSearchStates.length - 1]\n            .searchString;\n    // Store this search if different than previous\n    if (searchState.searchString !== prevSearchString) {\n      SearchCommandLine.previousSearchStates.push(searchState);\n      if (SearchCommandLine.history !== undefined) {\n        await SearchCommandLine.history.add(searchState.searchString);\n      }\n    }\n\n    // Make sure search history does not exceed configuration option\n    if (SearchCommandLine.previousSearchStates.length > configuration.history) {\n      SearchCommandLine.previousSearchStates.splice(0, 1);\n    }\n  }\n\n  /**\n   * Keeps the state of the current match, i.e. the match to which the cursor moves when the search is executed.\n   * Incremented / decremented by \\<C-g> or \\<C-t> in SearchInProgress mode.\n   * Resets to 0 if the search string becomes empty.\n   *\n   * @see {@link getCurrentMatchRelativeIndex}\n   */\n  private currentMatchDisplacement: number = 0;\n  private searchState: SearchState;\n\n  constructor(vimState: VimState, searchString: string, direction: SearchDirection) {\n    super(searchString, vimState.currentMode);\n    this.searchState = new SearchState(direction, vimState.cursorStopPosition, searchString);\n  }\n\n  public display(cursorChar: string): string {\n    return escapeCSSIcons(\n      `${this.searchState.direction === SearchDirection.Forward ? '/' : '?'}${this.text.substring(\n        0,\n        this.cursorIndex\n      )}${cursorChar}${this.text.substring(this.cursorIndex)}`\n    );\n  }\n\n  public get text(): string {\n    return this.searchState.searchString;\n  }\n  public set text(text: string) {\n    this.searchState.searchString = text;\n    if (text === '') {\n      this.currentMatchDisplacement = 0;\n    }\n  }\n\n  public getSearchState(): SearchState {\n    return this.searchState;\n  }\n\n  public getHistory(): HistoryFile {\n    return SearchCommandLine.history;\n  }\n\n  /**\n   * @returns the index of the current match, relative to the next match.\n   */\n  private getCurrentMatchRelativeIndex(vimState: VimState): number {\n    const count = vimState.recordedState.count || 1;\n    return count - 1 + this.currentMatchDisplacement * count;\n  }\n\n  /**\n   * @returns The start of the current match range (after applying the search offset) and its rank in the document's matches\n   */\n  public getCurrentMatchPosition(vimState: VimState): IndexedPosition | undefined {\n    return this.searchState.getNextSearchMatchPosition(\n      vimState,\n      vimState.cursorStopPosition,\n      SearchDirection.Forward,\n      this.getCurrentMatchRelativeIndex(vimState)\n    );\n  }\n\n  /**\n   * @returns The current match range and its rank in the document's matches\n   *\n   * NOTE: This method does not take the search offset into account\n   */\n  public getCurrentMatchRange(vimState: VimState): IndexedRange | undefined {\n    return this.searchState.getNextSearchMatchRange(\n      vimState,\n      vimState.cursorStopPosition,\n      SearchDirection.Forward,\n      this.getCurrentMatchRelativeIndex(vimState)\n    );\n  }\n\n  public getDecorations(vimState: VimState): SearchDecorations | undefined {\n    return getDecorationsForSearchMatchRanges(\n      this.searchState.getMatchRanges(vimState),\n      configuration.incsearch && vimState.currentMode === Mode.SearchInProgressMode\n        ? this.getCurrentMatchRange(vimState)?.index\n        : undefined\n    );\n  }\n\n  public async run(vimState: VimState): Promise<void> {\n    // Repeat the previous search if no new string is entered\n    if (this.text === '') {\n      if (SearchCommandLine.previousSearchStates.length > 0) {\n        this.text =\n          SearchCommandLine.previousSearchStates[\n            SearchCommandLine.previousSearchStates.length - 1\n          ].searchString;\n      }\n    }\n\n    this.cursorIndex = 0;\n    Register.setReadonlyRegister('/', this.text);\n    SearchCommandLine.addSearchStateToHistory(this.searchState);\n    globalState.hl = true;\n\n    if (this.searchState.getMatchRanges(vimState).length === 0) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.PatternNotFound, this.text));\n      return;\n    }\n\n    const currentMatch = this.getCurrentMatchPosition(vimState);\n\n    if (currentMatch === undefined) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(\n          this.searchState.direction === SearchDirection.Backward\n            ? ErrorCode.SearchHitTop\n            : ErrorCode.SearchHitBottom,\n          this.text\n        )\n      );\n      return;\n    }\n\n    vimState.cursorStopPosition = currentMatch.pos;\n\n    reportSearch(currentMatch.index, this.searchState.getMatchRanges(vimState).length, vimState);\n  }\n\n  public async escape(vimState: VimState): Promise<void> {\n    vimState.cursorStopPosition = this.searchState.cursorStartPosition;\n\n    const prevSearchList = SearchCommandLine.previousSearchStates;\n    globalState.searchState = prevSearchList\n      ? prevSearchList[prevSearchList.length - 1]\n      : undefined;\n\n    if (vimState.modeData.mode === Mode.SearchInProgressMode) {\n      const offset =\n        vimState.editor.visibleRanges[0].start.line -\n        vimState.modeData.firstVisibleLineBeforeSearch;\n      scrollView(vimState, offset);\n    }\n\n    await vimState.setCurrentMode(this.previousMode);\n    if (this.text.length > 0) {\n      SearchCommandLine.addSearchStateToHistory(this.searchState);\n    }\n  }\n\n  public async ctrlF(vimState: VimState): Promise<void> {\n    await new CommandShowSearchHistory(this.searchState.direction).exec(\n      vimState.cursorStopPosition,\n      vimState\n    );\n  }\n\n  /**\n   * Called when <C-g> or <C-t> is pressed during SearchInProgress mode\n   */\n  public async advanceCurrentMatch(vimState: VimState, direction: SearchDirection): Promise<void> {\n    // <C-g> always moves forward in the document, and <C-t> always moves back, regardless of search direction.\n    // To compensate, multiply the desired direction by the searchState's direction, so that\n    // effectiveDirection == direction * (searchState.direction)^2 == direction.\n    this.currentMatchDisplacement += this.searchState.direction * direction;\n\n    // With nowrapscan, <C-g>/<C-t> shouldn't do anything if it would mean advancing past the last reachable match in the buffer.\n    // We account for this by checking whether getCurrentMatchRange returns undefined once this.currentMatchDisplacement is advanced.\n    // If it does, we undo the change to this.currentMatchDisplacement before exiting, making this command a noop.\n    if (!configuration.wrapscan && !this.getCurrentMatchRange(vimState)) {\n      this.currentMatchDisplacement -= this.searchState.direction * direction;\n    }\n  }\n}\n","import { CommandUnicodeName } from '../../actions/commands/actions';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class AsciiCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    await new CommandUnicodeName().exec(vimState.cursorStopPosition, vimState);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { PositionDiff } from '../../common/motion/position';\nimport { externalCommand } from '../../util/externalCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { all, Parser } from 'parsimmon';\n\nexport interface IBangCommandArguments {\n  command: string;\n}\n\nexport class BangCommand extends ExCommand {\n  public static readonly argParser: Parser<BangCommand> = all.map(\n    (command) =>\n      new BangCommand({\n        command,\n      })\n  );\n\n  protected _arguments: IBangCommandArguments;\n  constructor(args: IBangCommandArguments) {\n    super();\n    this._arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  private getReplaceDiff(text: string): PositionDiff {\n    const lines = text.split('\\n');\n    const numNewlines = lines.length - 1;\n    const check = lines[0].match(/^\\s*/);\n    const numWhitespace = check ? check[0].length : 0;\n\n    return PositionDiff.exactCharacter({\n      lineOffset: -numNewlines,\n      character: numWhitespace,\n    });\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await externalCommand.run(this._arguments.command);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const resolvedRange = range.resolveToRange(vimState);\n\n    // pipe in stdin from lines in range\n    const input = vimState.document.getText(resolvedRange);\n    const output = await externalCommand.run(this._arguments.command, input);\n\n    // place cursor at the start of the replaced text and first non-whitespace character\n    const diff = this.getReplaceDiff(output);\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      text: output,\n      range: resolvedRange,\n      diff,\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport {\n  all,\n  alt,\n  eof,\n  optWhitespace,\n  regexp,\n  seqObj,\n  string,\n  succeed,\n  whitespace,\n} from 'parsimmon';\nimport { fileNameParser, numberParser } from '../../vimscript/parserUtils';\n\nfunction isSourceBreakpoint(b: vscode.Breakpoint): b is vscode.SourceBreakpoint {\n  return (b as vscode.SourceBreakpoint).location !== undefined;\n}\nfunction isFunctionBreakpoint(b: vscode.Breakpoint): b is vscode.FunctionBreakpoint {\n  return (b as vscode.FunctionBreakpoint).functionName !== undefined;\n}\n\n/**\n * Add Breakpoint Command\n */\ntype AddBreakpointHere = { type: 'here' };\ntype AddBreakpointFile = { type: 'file'; line: number; file: string };\ntype AddBreakpointFunction = { type: 'func'; function: string };\ntype AddBreakpointExpr = { type: 'expr'; expr: string };\ntype AddBreakpoint =\n  | AddBreakpointHere\n  | AddBreakpointFile\n  | AddBreakpointFunction\n  | AddBreakpointExpr;\n\nclass AddBreakpointCommand extends ExCommand {\n  public override isRepeatableWithDot: boolean = false;\n  private readonly addBreakpoint: AddBreakpoint;\n\n  constructor(addBreakpoint: AddBreakpoint) {\n    super();\n    this.addBreakpoint = addBreakpoint;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.addBreakpoint.type === 'here') {\n      const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n      return vscode.debug.addBreakpoints([new vscode.SourceBreakpoint(location)]);\n    } else if (this.addBreakpoint.type === 'file') {\n      let file: vscode.Uri;\n      if (this.addBreakpoint.file === '') {\n        file = vimState.document.uri;\n      } else {\n        const workspaceFolder =\n          vscode.workspace.getWorkspaceFolder(vimState.document.uri)?.uri ?? vscode.Uri.file('./');\n        file = vscode.Uri.joinPath(workspaceFolder, this.addBreakpoint.file);\n      }\n      const location = new vscode.Location(\n        file,\n        new vscode.Position(this.addBreakpoint.line - 1, 0)\n      );\n      return vscode.debug.addBreakpoints([new vscode.SourceBreakpoint(location)]);\n    } else if (this.addBreakpoint.type === 'func') {\n      return vscode.debug.addBreakpoints([\n        new vscode.FunctionBreakpoint(this.addBreakpoint.function),\n      ]);\n    } else if (this.addBreakpoint.type === 'expr') {\n      const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n      return vscode.debug.addBreakpoints([\n        new vscode.SourceBreakpoint(location, undefined, this.addBreakpoint.expr),\n      ]);\n    }\n  }\n}\n\n/**\n * Delete Breakpoint Command\n */\ntype DelBreakpointById = { type: 'byId'; id: number };\ntype DelAllBreakpoints = { type: 'all' };\ntype DelBreakpointFunction = { type: 'func'; function: string };\ntype DelBreakpointFile = { type: 'file'; line: number; file: string };\ntype DelBreakpointHere = { type: 'here' };\ntype DelBreakpoint =\n  | DelBreakpointById\n  | DelAllBreakpoints\n  | DelBreakpointFunction\n  | DelBreakpointFile\n  | DelBreakpointHere;\n\nclass DeleteBreakpointCommand extends ExCommand {\n  public override isRepeatableWithDot: boolean = false;\n  private readonly delBreakpoint: DelBreakpoint;\n\n  constructor(delBreakpoint: DelBreakpoint) {\n    super();\n    this.delBreakpoint = delBreakpoint;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.delBreakpoint.type === 'byId') {\n      return vscode.debug.removeBreakpoints(\n        vscode.debug.breakpoints.slice(this.delBreakpoint.id - 1, 1)\n      );\n    } else if (this.delBreakpoint.type === 'all') {\n      return vscode.debug.removeBreakpoints(vscode.debug.breakpoints);\n    } else if (this.delBreakpoint.type === 'file') {\n      let reqUri: vscode.Uri;\n      if (this.delBreakpoint.file === '') {\n        reqUri = vimState.document.uri;\n      } else {\n        const workspaceFolder =\n          vscode.workspace.getWorkspaceFolder(vimState.document.uri)?.uri ?? vscode.Uri.file('./');\n        reqUri = vscode.Uri.joinPath(workspaceFolder, this.delBreakpoint.file);\n      }\n      const reqLine = this.delBreakpoint.line - 1;\n      const breakpoint = vscode.debug.breakpoints\n        .filter(isSourceBreakpoint)\n        .find(\n          (b) =>\n            b.location.uri.toString() === reqUri.toString() &&\n            b.location.range.start.line === reqLine\n        );\n      if (breakpoint) return vscode.debug.removeBreakpoints([breakpoint]);\n    } else if (this.delBreakpoint.type === 'func') {\n      const functionName = this.delBreakpoint.function;\n      const breakpoint = vscode.debug.breakpoints\n        .filter(isFunctionBreakpoint)\n        .filter((b) => b.functionName === functionName);\n      if (breakpoint) return vscode.debug.removeBreakpoints(breakpoint);\n    } else if (this.delBreakpoint.type === 'here') {\n      const location = new vscode.Location(vimState.document.uri, vimState.cursorStartPosition);\n      const distFromLocationCharacter = (b: vscode.SourceBreakpoint) =>\n        Math.abs(b.location.range.start.character - location.range.start.character);\n\n      const breakpoint = vscode.debug.breakpoints\n        .filter(isSourceBreakpoint)\n        .filter(\n          (b) =>\n            b.location.uri.toString() === location.uri.toString() &&\n            b.location.range.start.line === location.range.start.line\n        )\n        .sort((a, b) => distFromLocationCharacter(a) - distFromLocationCharacter(b))[0];\n      if (breakpoint) return vscode.debug.removeBreakpoints([breakpoint]);\n    }\n  }\n}\n\n/**\n * List Breakpoints Command\n */\nclass ListBreakpointsCommand extends ExCommand {\n  public override isRepeatableWithDot: boolean = false;\n\n  async execute(vimState: VimState): Promise<void> {\n    const breakpoints = vscode.debug.breakpoints;\n    type BreakpointQuickPick = { breakpointId: string } & vscode.QuickPickItem;\n    const lines = breakpoints.map((b, i): BreakpointQuickPick => {\n      const { id, enabled, condition } = b;\n      let label = '';\n      label += `#${i + 1}\\t`;\n      label += enabled ? '$(circle-filled)\\t' : '$(circle-outline)\\t';\n      label += condition ? '$(debug-breakpoint-conditional)\\t' : '\\t';\n      if (isSourceBreakpoint(b))\n        label += `${path.basename(b.location.uri.fsPath)}:${b.location.range.start.line + 1}`;\n      if (isFunctionBreakpoint(b)) label += `$(debug-breakpoint-function)${b.functionName}`;\n      return {\n        label,\n        breakpointId: id,\n      };\n    });\n    await vscode.window.showQuickPick(lines).then(async (selected) => {\n      if (selected) {\n        const id = selected.breakpointId;\n        const breakpoint = breakpoints.find((b) => b.id === id);\n        if (breakpoint && isSourceBreakpoint(breakpoint)) {\n          await vscode.window.showTextDocument(breakpoint.location.uri).then(() => {\n            vimState.cursorStopPosition = breakpoint.location.range.start;\n          });\n        }\n      }\n    });\n  }\n}\n\nexport class Breakpoints {\n  public static readonly argParsers = {\n    add: whitespace\n      .then(\n        alt(\n          // here\n          seqObj<AddBreakpointHere>(['type', string('here')], optWhitespace),\n          // file\n          seqObj<AddBreakpointFile>(\n            ['type', string('file')],\n            ['line', optWhitespace.then(numberParser).fallback(1)],\n            ['file', optWhitespace.then(fileNameParser).fallback('')]\n          ),\n          // func\n          seqObj<AddBreakpointFunction>(\n            ['type', string('func')],\n            optWhitespace.then(numberParser).fallback(1), // we don't support line numbers in function names, but Vim does, so we'll allow it.\n            ['function', optWhitespace.then(regexp(/\\S+/))]\n          ),\n          // expr\n          seqObj<AddBreakpointExpr>(['type', string('expr')], ['expr', optWhitespace.then(all)])\n        )\n      )\n      .or(\n        // without arg\n        eof.result<DelBreakpointHere>({ type: 'here' })\n      )\n      .map((a) => new AddBreakpointCommand(a)),\n\n    del: whitespace\n      .then(\n        alt(\n          // here\n          seqObj<DelBreakpointHere>(['type', string('here')], optWhitespace),\n          // file\n          seqObj<DelBreakpointFile>(\n            ['type', string('file')],\n            ['line', optWhitespace.then(numberParser).fallback(1)],\n            ['file', optWhitespace.then(fileNameParser).fallback('')]\n          ),\n          // func\n          seqObj<DelBreakpointFunction>(\n            ['type', string('func')],\n            optWhitespace.then(numberParser).fallback(1), // we don't support line numbers in function names, but Vim does, so we'll allow it.\n            ['function', optWhitespace.then(regexp(/\\S+/))]\n          ),\n          // all\n          string('*').then(optWhitespace).result<DelAllBreakpoints>({ type: 'all' }),\n          // by number\n          numberParser.map((n) => ({ type: 'byId', id: n }))\n        )\n      )\n      .or(\n        // without arg\n        eof.result<DelBreakpointHere>({ type: 'here' })\n      )\n      .map((a) => new DeleteBreakpointCommand(a)),\n\n    list: succeed(new ListBreakpointsCommand()),\n  };\n}\n","import { alt, optWhitespace, Parser, seq, whitespace } from 'parsimmon';\nimport * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser, fileNameParser, numberParser } from '../../vimscript/parserUtils';\n\ninterface IBufferDeleteCommandArguments {\n  bang: boolean;\n  buffers: Array<string | number>;\n}\n\n//\n//  Implements :bd\n// http://vimdoc.sourceforge.net/htmldoc/windows.html#buffers\n//\nexport class BufferDeleteCommand extends ExCommand {\n  public static readonly argParser: Parser<BufferDeleteCommand> = seq(\n    bangParser.skip(optWhitespace),\n    alt(numberParser, fileNameParser).sepBy(whitespace)\n  ).map(([bang, buffers]) => new BufferDeleteCommand({ bang, buffers }));\n\n  public readonly arguments: IBufferDeleteCommandArguments;\n  constructor(args: IBufferDeleteCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.arguments.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this.arguments.buffers.length === 0) {\n      await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n    } else {\n      for (const buffer of this.arguments.buffers) {\n        if (typeof buffer === 'string') {\n          // TODO\n          StatusBar.setText(\n            vimState,\n            ':bd[elete][!] {bufname} is not yet implemented (PRs are welcome!)',\n            true\n          );\n          continue;\n        }\n\n        try {\n          await vscode.commands.executeCommand(`workbench.action.openEditorAtIndex${buffer}`);\n        } catch (e) {\n          throw error.VimError.fromCode(error.ErrorCode.NoBuffersDeleted);\n        }\n\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      }\n    }\n  }\n}\n","import { Parser } from 'parsimmon';\nimport * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser } from '../../vimscript/parserUtils';\n\n//\n//  Implements :close\n//  http://vimdoc.sourceforge.net/htmldoc/windows.html#:close\n//\nexport class CloseCommand extends ExCommand {\n  public static readonly argParser: Parser<CloseCommand> = bangParser.map(\n    (bang) => new CloseCommand(bang)\n  );\n\n  public readonly bang: boolean;\n  constructor(bang: boolean) {\n    super();\n    this.bang = bang;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (vimState.document.isDirty && !this.bang) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (vscode.window.visibleTextEditors.length === 1) {\n      throw error.VimError.fromCode(error.ErrorCode.CannotCloseLastWindow);\n    }\n\n    const oldViewColumn = vimState.editor.viewColumn;\n    await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n\n    if (\n      vscode.window.activeTextEditor !== undefined &&\n      vscode.window.activeTextEditor.viewColumn === oldViewColumn\n    ) {\n      await vscode.commands.executeCommand('workbench.action.previousEditor');\n    }\n  }\n}\n","import { optWhitespace, Parser } from 'parsimmon';\nimport { Position, Range } from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\nimport { ErrorCode, VimError } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { Address, LineRange } from '../../vimscript/lineRange';\n\nexport class CopyCommand extends ExCommand {\n  public static readonly argParser: Parser<CopyCommand> = optWhitespace\n    .then(Address.parser.fallback(undefined))\n    .map((address) => new CopyCommand(address));\n\n  private address?: Address;\n  constructor(address?: Address) {\n    super();\n    this.address = address;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  private copyLines(vimState: VimState, sourceStart: number, sourceEnd: number) {\n    const dest = this.address?.resolve(vimState, 'left', false);\n    if (dest === undefined || dest < -1 || dest > vimState.document.lineCount) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.InvalidAddress));\n      return;\n    }\n\n    if (sourceEnd < sourceStart) {\n      [sourceStart, sourceEnd] = [sourceEnd, sourceStart];\n    }\n\n    const copiedText = vimState.document.getText(\n      new Range(new Position(sourceStart, 0), new Position(sourceEnd, 0).getLineEnd())\n    );\n\n    let text: string;\n    let position: Position;\n    if (dest === -1) {\n      text = copiedText + '\\n';\n      position = new Position(0, 0);\n    } else {\n      text = '\\n' + copiedText;\n      position = new Position(dest, 0).getLineEnd();\n    }\n\n    const lines = copiedText.split('\\n');\n    const cursorPosition = new Position(\n      Math.max(dest + lines.length, 0),\n      lines[lines.length - 1].match(/\\S/)?.index ?? 0\n    );\n\n    vimState.recordedState.transformer.insert(\n      position,\n      text,\n      PositionDiff.exactPosition(cursorPosition)\n    );\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    const line = vimState.cursors[0].stop.line;\n    this.copyLines(vimState, line, line);\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n    this.copyLines(vimState, start, end);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register, RegisterMode } from '../../register/register';\nimport { Position } from 'vscode';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { Parser, alt, seq, any, whitespace, optWhitespace } from 'parsimmon';\nimport { numberParser } from '../../vimscript/parserUtils';\n\nexport interface IDeleteCommandArguments {\n  register?: string;\n  count?: number;\n}\n\nexport class DeleteCommand extends ExCommand {\n  // TODO: this is copy-pasted from `:y[ank]`\n  public static readonly argParser: Parser<DeleteCommand> = optWhitespace.then(\n    alt(\n      numberParser.map((count) => {\n        return { register: undefined, count };\n      }),\n      seq(any.fallback(undefined), whitespace.then(numberParser).fallback(undefined)).map(\n        ([register, count]) => {\n          return { register, count };\n        }\n      )\n    ).map(\n      ({ register, count }) =>\n        new DeleteCommand({\n          register,\n          count,\n        })\n    )\n  );\n\n  private readonly arguments: IDeleteCommandArguments;\n  constructor(args: IDeleteCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  /**\n   * Deletes text between `startLine` and `endLine`, inclusive.\n   * Puts the cursor at the start of the line where the deleted range was.\n   */\n  private deleteRange(startLine: number, endLine: number, vimState: VimState): void {\n    let start = new Position(startLine, 0);\n    let end = new Position(endLine, 0).getLineEndIncludingEOL();\n\n    if (endLine < vimState.document.lineCount - 1) {\n      end = end.getRightThroughLineBreaks();\n    } else if (startLine > 0) {\n      start = start.getLeftThroughLineBreaks();\n    }\n\n    const range = new vscode.Range(start, end);\n    const text = vimState.document\n      .getText(range)\n      // Remove leading or trailing newline\n      .replace(/^\\r?\\n/, '')\n      .replace(/\\r?\\n$/, '');\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'deleteRange',\n      range: new vscode.Range(start, end),\n      manuallySetCursorPositions: true,\n    });\n    vimState.cursorStopPosition = start.getLineBegin();\n\n    if (this.arguments.register) {\n      vimState.recordedState.registerName = this.arguments.register;\n    }\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    Register.put(vimState, text, 0, true);\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const linesToRemove = this.arguments.count ?? 1;\n    // :d[elete][cnt] removes [cnt] lines\n    const startLine = vimState.cursorStartPosition.line;\n    const endLine = startLine + (linesToRemove - 1);\n    this.deleteRange(startLine, endLine, vimState);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    /**\n     * If a [cnt] and [range] is specified (e.g. :.+2d3), :delete [cnt] is called from\n     * the end of the [range].\n     * Ex. if two lines are VisualLine highlighted, :<,>d3 will :d3\n     * from the end of the selected lines.\n     */\n    const { start, end } = range.resolve(vimState);\n    if (this.arguments.count) {\n      vimState.cursorStartPosition = new Position(end, 0);\n      await this.execute(vimState);\n      return;\n    }\n    this.deleteRange(start, end, vimState);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { VimState } from '../../state/vimState';\nimport { DefaultDigraphs } from '../../actions/commands/digraphs';\nimport { TextEditor } from '../../textEditor';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { any, Parser, seq, whitespace } from 'parsimmon';\nimport { bangParser, numberParser } from '../../vimscript/parserUtils';\n\nexport interface IDigraphsCommandArguments {\n  bang: boolean;\n  newDigraphs: Array<[string, string, number]>;\n}\n\ninterface DigraphQuickPickItem extends vscode.QuickPickItem {\n  charCodes: number[];\n}\n\nexport class DigraphsCommand extends ExCommand {\n  public static readonly argParser: Parser<DigraphsCommand> = seq(\n    bangParser,\n    whitespace.then(seq(any, any, whitespace.then(numberParser))).many()\n  ).map(([bang, newDigraphs]) => new DigraphsCommand({ bang, newDigraphs }));\n\n  private readonly arguments: IDigraphsCommandArguments;\n  constructor(args: IDigraphsCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  // TODO: replace 'any' with sensible index signature\n  private makeQuickPicks(digraphs: any): DigraphQuickPickItem[] {\n    const quickPicks = new Array<DigraphQuickPickItem>();\n    for (const digraphKey of Object.keys(digraphs)) {\n      const [charDesc, charCodes] = digraphs[digraphKey];\n      quickPicks.push({\n        label: digraphKey,\n        description: `${charDesc} (user)`,\n        charCodes,\n      });\n    }\n    return quickPicks;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO: use arguments\n\n    const digraphKeyAndContent = this.makeQuickPicks(configuration.digraphs).concat(\n      this.makeQuickPicks(DefaultDigraphs)\n    );\n\n    vscode.window.showQuickPick(digraphKeyAndContent).then(async (val) => {\n      if (val) {\n        const char = String.fromCharCode(...val.charCodes);\n        await TextEditor.insert(vimState.editor, char);\n      }\n    });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { getPathDetails, resolveUri } from '../../util/path';\nimport { doesFileExist } from 'platform/fs';\nimport untildify = require('untildify');\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport {\n  bangParser,\n  FileCmd,\n  fileCmdParser,\n  fileNameParser,\n  FileOpt,\n  fileOptParser,\n} from '../../vimscript/parserUtils';\nimport { optWhitespace, regexp, seq } from 'parsimmon';\n\nexport enum FilePosition {\n  NewWindowVerticalSplit,\n  NewWindowHorizontalSplit,\n}\n\nexport type IFileCommandArguments =\n  | {\n      name: 'edit';\n      bang: boolean;\n      opt: FileOpt;\n      cmd?: FileCmd;\n      file?: string;\n      createFileIfNotExists?: boolean;\n    }\n  | {\n      name: 'enew';\n      bang: boolean;\n      createFileIfNotExists?: boolean;\n    }\n  | {\n      name: 'new' | 'vnew' | 'split' | 'vsplit';\n      opt: FileOpt;\n      cmd?: FileCmd;\n      file?: string;\n      createFileIfNotExists?: boolean;\n    };\n\n// TODO: This is a hack to get this to work in the short term with new arg parsing logic.\ntype LegacyArgs = {\n  file?: string;\n  bang?: boolean;\n  position?: FilePosition;\n  cmd?: FileCmd;\n  createFileIfNotExists?: boolean;\n};\nfunction getLegacyArgs(args: IFileCommandArguments): LegacyArgs {\n  if (args.name === 'edit') {\n    return { file: args.file, bang: args.bang, createFileIfNotExists: true };\n  } else if (args.name === 'enew') {\n    return { bang: args.bang, createFileIfNotExists: true };\n  } else if (args.name === 'new') {\n    return {\n      file: args.file,\n      position: FilePosition.NewWindowHorizontalSplit,\n      createFileIfNotExists: true,\n    };\n  } else if (args.name === 'vnew') {\n    return {\n      file: args.file,\n      position: FilePosition.NewWindowVerticalSplit,\n      createFileIfNotExists: true,\n    };\n  } else if (args.name === 'split') {\n    return { file: args.file, position: FilePosition.NewWindowHorizontalSplit };\n  } else if (args.name === 'vsplit') {\n    return { file: args.file, position: FilePosition.NewWindowVerticalSplit };\n  } else {\n    throw new Error(`Unexpected FileCommand.arguments.name: ${args.name}`);\n  }\n}\n\nexport class FileCommand extends ExCommand {\n  // TODO: There's a lot of duplication here\n  // TODO: These `optWhitespace` calls should be `whitespace`\n  public static readonly argParsers = {\n    edit: seq(\n      bangParser,\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(fileNameParser).fallback(undefined)\n    ).map(([bang, opt, cmd, file]) => new FileCommand({ name: 'edit', bang, opt, cmd, file })),\n    enew: bangParser.map((bang) => new FileCommand({ name: 'enew', bang })),\n    new: seq(\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(fileNameParser).fallback(undefined)\n    ).map(([opt, cmd, file]) => new FileCommand({ name: 'new', opt, cmd, file })),\n    split: seq(\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(fileNameParser).fallback(undefined)\n    ).map(([opt, cmd, file]) => new FileCommand({ name: 'split', opt, cmd, file })),\n    vnew: seq(\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(fileNameParser).fallback(undefined)\n    ).map(([opt, cmd, file]) => new FileCommand({ name: 'vnew', opt, cmd, file })),\n    vsplit: seq(\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(fileNameParser).fallback(undefined)\n    ).map(([opt, cmd, file]) => new FileCommand({ name: 'vsplit', opt, cmd, file })),\n  };\n\n  private readonly arguments: IFileCommandArguments;\n  private readonly logger = Logger.get('File');\n\n  constructor(args: IFileCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const args = getLegacyArgs(this.arguments);\n\n    if (args.bang) {\n      await vscode.commands.executeCommand('workbench.action.files.revert');\n      return;\n    }\n\n    // Need to do this before the split since it loses the activeTextEditor\n    const editorFileUri = vscode.window.activeTextEditor!.document.uri;\n    const editorFilePath = editorFileUri.fsPath;\n\n    // Do the split if requested\n    let split = false;\n    if (args.position === FilePosition.NewWindowVerticalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorRight');\n      split = true;\n    }\n    if (args.position === FilePosition.NewWindowHorizontalSplit) {\n      await vscode.commands.executeCommand('workbench.action.splitEditorDown');\n      split = true;\n    }\n\n    const hidePreviousEditor = async () => {\n      if (split === true) {\n        await vscode.commands.executeCommand('workbench.action.previousEditor');\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      }\n    };\n\n    // No file was specified\n    if (args.file === undefined) {\n      if (args.createFileIfNotExists === true) {\n        await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        await hidePreviousEditor();\n      }\n      return;\n    }\n\n    // Only untidify when the currently open page and file completion is local\n    if (args.file && editorFileUri.scheme === 'file') {\n      args.file = untildify(args.file);\n    }\n\n    let fileUri = editorFileUri;\n    // Using the empty string will request to open a file\n    if (args.file === '') {\n      // No file on split is fine and just return\n      if (split === true) {\n        return;\n      }\n\n      const fileList = await vscode.window.showOpenDialog({});\n      if (fileList && fileList.length > 0) {\n        fileUri = fileList[0];\n      }\n    } else {\n      // remove file://\n      args.file = args.file.replace(/^file:\\/\\//, '');\n\n      // Using a filename, open or create the file\n      const isRemote = !!vscode.env.remoteName;\n      const { fullPath, path: p } = getPathDetails(args.file, editorFileUri, isRemote);\n      // Only if the expanded path of the full path is different than\n      // the currently opened window path\n      if (fullPath !== editorFilePath) {\n        const uriPath = resolveUri(fullPath, p.sep, editorFileUri, isRemote);\n        if (uriPath === null) {\n          // return if the path is invalid\n          return;\n        }\n\n        let fileExists = await doesFileExist(uriPath);\n        if (fileExists) {\n          // If the file without the added ext exists\n          fileUri = uriPath;\n        } else {\n          // if file does not exist\n          // try to find it with the same extension as the current file\n          const pathWithExt = fullPath + p.extname(editorFilePath);\n          const uriPathWithExt = resolveUri(pathWithExt, p.sep, editorFileUri, isRemote);\n          if (uriPathWithExt !== null) {\n            fileExists = await doesFileExist(uriPathWithExt);\n            if (fileExists) {\n              // if the file with the added ext exists\n              fileUri = uriPathWithExt;\n            }\n          }\n        }\n\n        // If both with and without ext path do not exist\n        if (!fileExists) {\n          if (args.createFileIfNotExists) {\n            // Change the scheme to untitled to open an\n            // untitled tab\n            fileUri = uriPath.with({ scheme: 'untitled' });\n          } else {\n            this.logger.error(`${args.file} does not exist.`);\n            return;\n          }\n        }\n      }\n    }\n\n    const doc = await vscode.workspace.openTextDocument(fileUri);\n    vscode.window.showTextDocument(doc);\n\n    const lineNumber =\n      args.cmd?.type === 'line_number'\n        ? args.cmd.line\n        : args.cmd?.type === 'last_line'\n        ? vscode.window.activeTextEditor!.document.lineCount - 1\n        : undefined;\n    if (lineNumber !== undefined && lineNumber >= 0) {\n      vscode.window.activeTextEditor!.revealRange(\n        new vscode.Range(new vscode.Position(lineNumber, 0), new vscode.Position(lineNumber, 0))\n      );\n    }\n    await hidePreviousEditor();\n  }\n}\n","import { all, optWhitespace, Parser, seq } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { reportFileInfo } from '../../util/statusBarTextUtils';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser } from '../../vimscript/parserUtils';\n\nexport class FileInfoCommand extends ExCommand {\n  public static readonly argParser: Parser<FileInfoCommand> = seq(\n    bangParser,\n    optWhitespace.then(all)\n  ).map(([bang, fileName]) => new FileInfoCommand({ bang, fileName }));\n\n  private args: {\n    bang: boolean;\n    fileName?: string;\n  };\n  private constructor(args: { bang: boolean; fileName?: string }) {\n    super();\n    this.args = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO: Use `this.args`\n    reportFileInfo(vimState.cursors[0].start, vimState);\n  }\n}\n","import { optWhitespace, Parser } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { numberParser } from '../../vimscript/parserUtils';\n\nexport class GotoCommand extends ExCommand {\n  public static readonly argParser: Parser<GotoCommand> = optWhitespace\n    .then(numberParser.fallback(undefined))\n    .map((count) => new GotoCommand(count));\n\n  private offset?: number;\n  constructor(offset?: number) {\n    super();\n    this.offset = offset;\n  }\n\n  private gotoOffset(vimState: VimState, offset: number) {\n    vimState.cursorStopPosition = vimState.document.positionAt(offset);\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    this.gotoOffset(vimState, this.offset ?? 0);\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    if (this.offset === undefined) {\n      this.offset = range.resolve(vimState)?.end ?? 0;\n    }\n    this.gotoOffset(vimState, this.offset);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\n\nexport class GotoLineCommand extends ExCommand {\n  public async execute(vimState: VimState): Promise<void> {\n    return;\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    vimState.cursorStartPosition = vimState.cursorStopPosition = vimState.cursorStopPosition\n      .with({ line: range.resolve(vimState).end })\n      .obeyStartOfLine(vimState.document);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport {\n  CommandShowSearchHistory,\n  CommandShowCommandHistory,\n} from '../../actions/commands/actions';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { SearchDirection } from '../../vimscript/pattern';\nimport { alt, optWhitespace, Parser, string } from 'parsimmon';\nimport { nameAbbrevParser } from '../../vimscript/parserUtils';\n\nexport enum HistoryCommandType {\n  Cmd,\n  Search,\n  Expr,\n  Input,\n  Debug,\n  All,\n}\n\nconst historyTypeParser: Parser<HistoryCommandType> = alt(\n  alt(nameAbbrevParser('c', 'md'), string(':')).result(HistoryCommandType.Cmd),\n  alt(nameAbbrevParser('s', 'earch'), string('/')).result(HistoryCommandType.Search),\n  alt(nameAbbrevParser('e', 'xpr'), string('=')).result(HistoryCommandType.Expr),\n  alt(nameAbbrevParser('i', 'nput'), string('@')).result(HistoryCommandType.Input),\n  alt(nameAbbrevParser('d', 'ebug'), string('>')).result(HistoryCommandType.Debug),\n  nameAbbrevParser('a', 'll').result(HistoryCommandType.All)\n);\n\nexport interface IHistoryCommandArguments {\n  type: HistoryCommandType;\n  // TODO: :history can also accept a range\n}\n\n// http://vimdoc.sourceforge.net/htmldoc/cmdline.html#:history\nexport class HistoryCommand extends ExCommand {\n  public static readonly argParser: Parser<HistoryCommand> = optWhitespace\n    .then(historyTypeParser.fallback(HistoryCommandType.Cmd))\n    .map((type) => new HistoryCommand({ type }));\n\n  private readonly arguments: IHistoryCommandArguments;\n  constructor(args: IHistoryCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this.arguments.type) {\n      case HistoryCommandType.Cmd:\n        await new CommandShowCommandHistory().exec(vimState.cursorStopPosition, vimState);\n        break;\n      case HistoryCommandType.Search:\n        await new CommandShowSearchHistory(SearchDirection.Forward).exec(\n          vimState.cursorStopPosition,\n          vimState\n        );\n        break;\n      // TODO: Implement these\n      case HistoryCommandType.Expr:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Input:\n        throw new Error('Not implemented');\n      case HistoryCommandType.Debug:\n        throw new Error('Not implemented');\n      case HistoryCommandType.All:\n        throw new Error('Not implemented');\n    }\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { globalState } from '../../state/globalState';\nimport { Jump } from '../../jumps/jump';\nimport { Cursor } from '../../common/motion/cursor';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nclass JumpPickItem implements QuickPickItem {\n  jump: Jump;\n\n  label: string;\n  description?: string;\n  detail?: string;\n  picked?: boolean;\n  alwaysShow?: boolean;\n\n  constructor(jump: Jump, idx: number) {\n    this.jump = jump;\n    this.label = jump.fileName;\n    this.detail = `jump ${idx} line ${jump.position.line + 1} col ${jump.position.character}`;\n    try {\n      this.description = jump.document.lineAt(jump.position).text;\n    } catch (e) {\n      this.description = undefined;\n    }\n  }\n}\n\nexport class JumpsCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    if (jumpTracker.hasJumps) {\n      const quickPickItems = jumpTracker.jumps.map((jump, idx) => new JumpPickItem(jump, idx));\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item && item.jump.document !== undefined) {\n        window.showTextDocument(item.jump.document);\n        vimState.cursors = [new Cursor(item.jump.position, item.jump.position)];\n      }\n    } else {\n      window.showInformationMessage('No jumps available');\n    }\n  }\n}\n\nexport class ClearJumpsCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    const jumpTracker = globalState.jumpTracker;\n    jumpTracker.clearJumps();\n  }\n}\n","import { optWhitespace, Parser } from 'parsimmon';\nimport { Range, TextLine } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { Address, LineRange } from '../../vimscript/lineRange';\nimport { numberParser } from '../../vimscript/parserUtils';\n\ntype LeftArgs = {\n  indent: number;\n};\n\nexport class LeftCommand extends ExCommand {\n  public static readonly argParser: Parser<LeftCommand> = optWhitespace\n    .then(numberParser.fallback(0))\n    .map((indent) => new LeftCommand({ indent }));\n\n  private args: LeftArgs;\n  constructor(args: LeftArgs) {\n    super();\n    this.args = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n\n    const lines: TextLine[] = [];\n    for (let line = start; line <= end; line++) {\n      lines.push(vimState.document.lineAt(line));\n    }\n\n    vimState.recordedState.transformer.replace(\n      new Range(lines[0].range.start, lines[lines.length - 1].range.end),\n      lines\n        .map(\n          (line) =>\n            ' '.repeat(this.args.indent) + line.text.slice(line.firstNonWhitespaceCharacterIndex)\n        )\n        .join('\\n')\n    );\n  }\n}\n\ntype RightArgs = {\n  width: number;\n};\n\nexport class RightCommand extends ExCommand {\n  public static readonly argParser: Parser<RightCommand> = optWhitespace\n    .then(numberParser.fallback(undefined))\n    .map((width) => new RightCommand({ width: width ?? configuration.textwidth }));\n\n  private args: RightArgs;\n  constructor(args: RightArgs) {\n    super();\n    this.args = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n\n    const lines: TextLine[] = [];\n    for (let line = start; line <= end; line++) {\n      lines.push(vimState.document.lineAt(line));\n    }\n\n    vimState.recordedState.transformer.replace(\n      new Range(lines[0].range.start, lines[lines.length - 1].range.end),\n      lines\n        .map((line) => {\n          const indent = ' '.repeat(\n            Math.max(\n              0,\n              this.args.width - (line.text.length - line.firstNonWhitespaceCharacterIndex)\n            )\n          );\n          return indent + line.text.slice(line.firstNonWhitespaceCharacterIndex);\n        })\n        .join('\\n')\n    );\n  }\n}\n\ntype CenterArgs = {\n  width: number;\n};\n\nexport class CenterCommand extends ExCommand {\n  public static readonly argParser: Parser<CenterCommand> = optWhitespace\n    .then(numberParser.fallback(undefined))\n    .map((width) => new CenterCommand({ width: width ?? configuration.textwidth }));\n\n  private args: CenterArgs;\n  constructor(args: CenterArgs) {\n    super();\n    this.args = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n\n    const lines: TextLine[] = [];\n    for (let line = start; line <= end; line++) {\n      lines.push(vimState.document.lineAt(line));\n    }\n\n    vimState.recordedState.transformer.replace(\n      new Range(lines[0].range.start, lines[lines.length - 1].range.end),\n      lines\n        .map((line) => {\n          const indent = ' '.repeat(\n            Math.max(\n              0,\n              this.args.width - (line.text.length - line.firstNonWhitespaceCharacterIndex)\n            ) / 2\n          );\n          return indent + line.text.slice(line.firstNonWhitespaceCharacterIndex);\n        })\n        .join('\\n')\n    );\n  }\n}\n","import { window, QuickPickItem } from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { IMark } from '../../history/historyTracker';\nimport { Cursor } from '../../common/motion/cursor';\nimport { ErrorCode, VimError } from '../../error';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { alt, noneOf, optWhitespace, Parser, regexp, seq, string, whitespace } from 'parsimmon';\n\nclass MarkQuickPickItem implements QuickPickItem {\n  mark: IMark;\n\n  label: string;\n  description: string;\n  detail: string;\n  picked = false;\n  alwaysShow = false;\n\n  constructor(vimState: VimState, mark: IMark) {\n    this.mark = mark;\n    this.label = mark.name;\n    if (mark.document && mark.document !== vimState.document) {\n      this.description = mark.document.fileName;\n    } else {\n      this.description = vimState.document.lineAt(mark.position).text.trim();\n    }\n    this.detail = `line ${mark.position.line} col ${mark.position.character}`;\n  }\n}\n\nexport class MarksCommand extends ExCommand {\n  public static readonly argParser: Parser<MarksCommand> = optWhitespace\n    .then(noneOf('|'))\n    .many()\n    .map((marks) => new MarksCommand(marks));\n\n  private marksFilter: string[];\n  constructor(marksFilter: string[]) {\n    super();\n    this.marksFilter = marksFilter;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const quickPickItems: MarkQuickPickItem[] = vimState.historyTracker\n      .getMarks()\n      .filter((mark) => {\n        return this.marksFilter.length === 0 || this.marksFilter.includes(mark.name);\n      })\n      .map((mark) => new MarkQuickPickItem(vimState, mark));\n\n    if (quickPickItems.length > 0) {\n      const item = await window.showQuickPick(quickPickItems, {\n        canPickMany: false,\n      });\n      if (item) {\n        vimState.cursors = [new Cursor(item.mark.position, item.mark.position)];\n      }\n    } else {\n      window.showInformationMessage('No marks set');\n    }\n  }\n}\n\ntype DeleteMarksArgs = Array<{ start: string; end: string } | string> | '!';\n\nexport class DeleteMarksCommand extends ExCommand {\n  public static readonly argParser: Parser<DeleteMarksCommand> = alt<DeleteMarksArgs>(\n    string('!'),\n    whitespace.then(\n      optWhitespace\n        .then(\n          alt<{ start: string; end: string } | string>(\n            seq(regexp(/[a-z]/).skip(string('-')), regexp(/[a-z]/)).map(([start, end]) => {\n              return { start, end };\n            }),\n            seq(regexp(/[A-Z]/).skip(string('-')), regexp(/[A-Z]/)).map(([start, end]) => {\n              return { start, end };\n            }),\n            seq(regexp(/[0-9]/).skip(string('-')), regexp(/[0-9]/)).map(([start, end]) => {\n              return { start, end };\n            }),\n            noneOf('-')\n          )\n        )\n        .many()\n    )\n  ).map((marks) => new DeleteMarksCommand(marks));\n\n  private args: DeleteMarksArgs;\n  constructor(args: DeleteMarksArgs) {\n    super();\n    this.args = args;\n  }\n\n  private static resolveMarkList(vimState: VimState, args: DeleteMarksArgs) {\n    const asciiRange = (start: string, end: string) => {\n      if (start > end) {\n        throw VimError.fromCode(ErrorCode.InvalidArgument);\n      }\n\n      const [asciiStart, asciiEnd] = [start.charCodeAt(0), end.charCodeAt(0)];\n\n      const chars: string[] = [];\n      for (let ascii = asciiStart; ascii <= asciiEnd; ascii++) {\n        chars.push(String.fromCharCode(ascii));\n      }\n      return chars;\n    };\n\n    if (args === '!') {\n      // TODO: clear change list\n      return asciiRange('a', 'z');\n    }\n\n    const marks: string[] = [];\n    for (const x of args) {\n      if (typeof x === 'string') {\n        marks.push(x);\n      } else {\n        const range = asciiRange(x.start, x.end);\n        if (range === undefined) {\n          throw VimError.fromCode(ErrorCode.InvalidArgument);\n        }\n        marks.push(...range.concat());\n      }\n    }\n    return marks;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const marks = DeleteMarksCommand.resolveMarkList(vimState, this.args);\n    vimState.historyTracker.removeMarks(marks);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { globalState } from '../../state/globalState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class NohlCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    globalState.hl = false;\n\n    // Clear the `match x of y` message from status bar\n    StatusBar.clear(vimState);\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class OnlyCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    await Promise.allSettled([\n      vscode.commands.executeCommand('workbench.action.closeEditorsInOtherGroups'),\n      vscode.commands.executeCommand('workbench.action.maximizeEditor'),\n      vscode.commands.executeCommand('workbench.action.closePanel'),\n    ]);\n  }\n}\n","import { Parser, succeed } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { Address, LineRange } from '../../vimscript/lineRange';\n\ntype PrintArgs = {\n  printNumbers: boolean;\n  printText: boolean;\n};\n\n// TODO: `:l[ist]` is more than an alias\n// TODO: `:z`\nexport class PrintCommand extends ExCommand {\n  // TODO: Print {count} and [flags]\n  public static readonly argParser = (args: {\n    printNumbers: boolean;\n    printText: boolean;\n  }): Parser<PrintCommand> => succeed(new PrintCommand(args));\n\n  private args: PrintArgs;\n  constructor(args: PrintArgs) {\n    super();\n    this.args = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO: Wrong default for `:=`\n    this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { end } = range.resolve(vimState);\n\n    // For now, we just print the last line.\n    // TODO: Create a dynamic document if there's more than one line?\n    const line = vimState.document.lineAt(end);\n    let output: string;\n    if (this.args.printNumbers) {\n      if (this.args.printText) {\n        output = `${line.lineNumber + 1} ${line.text}`;\n      } else {\n        output = `${line.lineNumber + 1}`;\n      }\n    } else {\n      if (this.args.printText) {\n        output = `${line.text}`;\n      } else {\n        output = '';\n      }\n    }\n    StatusBar.setText(vimState, output);\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\n\nimport { Register } from '../../register/register';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { Position } from 'vscode';\nimport { PutBeforeFromCmdLine, PutFromCmdLine } from '../../actions/commands/put';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { any, optWhitespace, Parser, seq } from 'parsimmon';\nimport { bangParser } from '../../vimscript/parserUtils';\n\nexport interface IPutCommandArguments {\n  bang: boolean;\n  register?: string;\n}\n\n//\n// Implements :put\n// http://vimdoc.sourceforge.net/htmldoc/change.html#:put\n//\n\nexport class PutExCommand extends ExCommand {\n  public static readonly argParser: Parser<PutExCommand> = seq(\n    bangParser,\n    optWhitespace.then(any).fallback(undefined)\n  ).map(([bang, register]) => new PutExCommand({ bang, register }));\n\n  public readonly arguments: IPutCommandArguments;\n\n  constructor(args: IPutCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async doPut(vimState: VimState, position: Position): Promise<void> {\n    const registerName = this.arguments.register || (configuration.useSystemClipboard ? '*' : '\"');\n    if (!Register.isValidRegister(registerName)) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.TrailingCharacters));\n      return;\n    }\n\n    vimState.recordedState.registerName = registerName;\n\n    const putCmd = this.arguments.bang ? new PutBeforeFromCmdLine() : new PutFromCmdLine();\n    putCmd.setInsertionLine(position.line);\n    await putCmd.exec(position, vimState);\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await this.doPut(vimState, vimState.cursorStopPosition);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { end } = range.resolve(vimState);\n    await this.doPut(vimState, new Position(end, 0).getLineEnd());\n  }\n}\n","import { Parser } from 'parsimmon';\nimport * as vscode from 'vscode';\n\nimport * as error from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser } from '../../vimscript/parserUtils';\n\nexport interface IQuitCommandArguments {\n  bang?: boolean;\n  quitAll?: boolean;\n}\n\n//\n//  Implements :quit\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:quit\n//\nexport class QuitCommand extends ExCommand {\n  public static readonly argParser: (quitAll: boolean) => Parser<QuitCommand> = (\n    quitAll: boolean\n  ) =>\n    bangParser.map(\n      (bang) =>\n        new QuitCommand({\n          bang,\n          quitAll,\n        })\n    );\n\n  public override isRepeatableWithDot = false;\n\n  public arguments: IQuitCommandArguments;\n  constructor(args: IQuitCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // NOTE: We can't currently get all open text editors, so this isn't perfect. See #3809\n    const duplicatedInSplit =\n      vscode.window.visibleTextEditors.filter((editor) => editor.document === vimState.document)\n        .length > 1;\n    if (\n      vimState.document.isDirty &&\n      !this.arguments.bang &&\n      (!duplicatedInSplit || this.arguments.quitAll)\n    ) {\n      throw error.VimError.fromCode(error.ErrorCode.NoWriteSinceLastChange);\n    }\n\n    if (this.arguments.quitAll) {\n      await vscode.commands.executeCommand('workbench.action.closeAllEditors');\n    } else {\n      if (!this.arguments.bang) {\n        await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n      } else {\n        await vscode.commands.executeCommand('workbench.action.revertAndCloseActiveEditor');\n      }\n    }\n  }\n}\n","import { readFileAsync } from 'platform/fs';\nimport { SUPPORT_READ_COMMAND } from 'platform/constants';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { fileNameParser, FileOpt, fileOptParser } from '../../vimscript/parserUtils';\nimport { all, alt, optWhitespace, Parser, seq, string, whitespace } from 'parsimmon';\n\nexport type IReadCommandArguments =\n  | {\n      opt: FileOpt;\n    } & ({ cmd: string } | { file: string } | {});\n\n//\n//  Implements :read and :read!\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read\n//  http://vimdoc.sourceforge.net/htmldoc/insert.html#:read!\n//\nexport class ReadCommand extends ExCommand {\n  public static readonly argParser: Parser<ReadCommand> = seq(\n    whitespace.then(fileOptParser).fallback([]),\n    optWhitespace\n      .then(\n        alt<{ cmd: string } | { file: string }>(\n          string('!')\n            .then(all)\n            .map((cmd) => {\n              return { cmd };\n            }),\n          fileNameParser.map((file) => {\n            return { file };\n          })\n        )\n      )\n      .fallback(undefined)\n  ).map(([opt, other]) => new ReadCommand({ opt, ...other }));\n\n  private readonly arguments: IReadCommandArguments;\n  constructor(args: IReadCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const textToInsert = await this.getTextToInsert(vimState);\n    if (textToInsert) {\n      vimState.recordedState.transformer.insert(vimState.cursorStopPosition.getLineEnd(), '\\n' + textToInsert);\n    }\n  }\n\n  // TODO: executeWithRange()\n\n  async getTextToInsert(vimState: VimState): Promise<string> {\n    if ('file' in this.arguments) {\n        return readFileAsync(this.arguments.file, 'utf8');\n    } else if ('cmd' in this.arguments) {\n      if (this.arguments.cmd.length > 0) {\n        if (SUPPORT_READ_COMMAND) {\n          const cmd = this.arguments.cmd;\n          return new Promise<string>(async (resolve, reject) => {\n            const { exec } = await import('child_process');\n            exec(cmd, (err, stdout, stderr) => {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(stdout);\n              }\n            });\n          });\n        } else {\n          return '';\n        }\n      } else {\n        // TODO: error message?\n        return '';\n      }\n    } else {\n      return vimState.document.getText();\n    }\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { VimState } from '../../state/vimState';\nimport { Register } from '../../register/register';\nimport { RecordedState } from '../../state/recordedState';\nimport { StatusBar } from '../../statusBar';\nimport { VimError, ErrorCode } from '../../error';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { any, optWhitespace, Parser } from 'parsimmon';\n\nexport class RegisterCommand extends ExCommand {\n  public static readonly argParser: Parser<RegisterCommand> = optWhitespace.then(\n    any.sepBy(optWhitespace).map((registers) => new RegisterCommand(registers))\n  );\n\n  private readonly registers: string[];\n  constructor(registers: string[]) {\n    super();\n    this.registers = registers;\n  }\n\n  private async getRegisterDisplayValue(register: string): Promise<string | undefined> {\n    let result = (await Register.get(register))?.text;\n    if (result instanceof Array) {\n      result = result.join('\\n').substr(0, 100);\n    } else if (result instanceof RecordedState) {\n      result = result.actionsRun.map((x) => x.keysPressed.join('')).join('');\n    }\n\n    return result;\n  }\n\n  async displayRegisterValue(vimState: VimState, register: string): Promise<void> {\n    let result = await this.getRegisterDisplayValue(register);\n    if (result === undefined) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.NothingInRegister, register));\n    } else {\n      result = result.replace(/\\n/g, '\\\\n');\n      vscode.window.showInformationMessage(`${register} ${result}`);\n    }\n  }\n\n  private regSortOrder(register: string): number {\n    const specials = ['-', '*', '+', '.', ':', '%', '#', '/', '='];\n    if (register === '\"') {\n      return 0;\n    } else if (register >= '0' && register <= '9') {\n      return 10 + parseInt(register, 10);\n    } else if (register >= 'a' && register <= 'z') {\n      return 100 + (register.charCodeAt(0) - 'a'.charCodeAt(0));\n    } else if (specials.includes(register)) {\n      return 1000 + specials.indexOf(register);\n    } else {\n      throw new Error(`Unexpected register ${register}`);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.registers.length === 1) {\n      await this.displayRegisterValue(vimState, this.registers[0]);\n    } else {\n      const currentRegisterKeys = Register.getKeys()\n        .filter(\n          (reg) => reg !== '_' && (this.registers.length === 0 || this.registers.includes(reg))\n        )\n        .sort((reg1: string, reg2: string) => this.regSortOrder(reg1) - this.regSortOrder(reg2));\n      const registerKeyAndContent = new Array<vscode.QuickPickItem>();\n\n      for (const registerKey of currentRegisterKeys) {\n        registerKeyAndContent.push({\n          label: registerKey,\n          description: await this.getRegisterDisplayValue(registerKey),\n        });\n      }\n\n      vscode.window.showQuickPick(registerKeyAndContent).then(async (val) => {\n        if (val) {\n          const result = val.description;\n          vscode.window.showInformationMessage(`${val.label} ${result}`);\n        }\n      });\n    }\n  }\n}\n","import { optWhitespace, Parser, seq } from 'parsimmon';\nimport { Range } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\nimport { isVisualMode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { bangParser, numberParser } from '../../vimscript/parserUtils';\nimport { SetCommand } from './set';\n\nexport interface IRetabCommandArguments {\n  replaceSpaces: boolean;\n  newTabstop?: number;\n}\n\ninterface UpdatedLineSegment {\n  value: string;\n  length: number;\n}\n\n// :[range]ret[ab][!] [new_tabstop]\nexport class RetabCommand extends ExCommand {\n  public static readonly argParser: Parser<RetabCommand> = seq(\n    bangParser,\n    optWhitespace.then(numberParser).fallback(undefined)\n  ).map(\n    ([replaceSpaces, newTabstop]) =>\n      new RetabCommand({\n        replaceSpaces,\n        newTabstop,\n      })\n  );\n\n  private readonly arguments: IRetabCommandArguments;\n\n  constructor(args: IRetabCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode)) {\n      const { start, end } = vimState.editor.selection;\n      this.retab(vimState, start.line, end.line);\n    } else {\n      this.retab(vimState, 0, vimState.document.lineCount - 1);\n    }\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n    this.retab(vimState, start, end);\n  }\n\n  private concat(count: number, char: string): string {\n    let result = '';\n\n    for (let i = 0; i < count; i++) {\n      result += char;\n    }\n\n    return result;\n  }\n\n  private hasTabs(str: string): boolean {\n    return str.indexOf('\\t') >= 0;\n  }\n\n  expandtab(str: string, start = 0, tabstop = configuration.tabstop): string {\n    let expanded = '';\n\n    let i = start;\n    for (const char of str) {\n      if (char === '\\t') {\n        const spaces = tabstop - (i % tabstop) || tabstop;\n\n        expanded += this.concat(spaces, ' ');\n        i += spaces;\n      } else {\n        expanded += char;\n        i++;\n      }\n    }\n\n    return expanded;\n  }\n\n  retabLineSegment(\n    segment: string,\n    start: number,\n    tabstop = configuration.tabstop\n  ): UpdatedLineSegment {\n    const retab = this.arguments.replaceSpaces || this.hasTabs(segment);\n\n    if (!retab) {\n      return {\n        value: segment,\n        length: segment.length,\n      };\n    }\n\n    const retabTabstop = this.arguments.newTabstop || tabstop;\n    const detabbed = this.expandtab(segment, start, tabstop);\n\n    const spaces = Math.min((start + detabbed.length) % retabTabstop, detabbed.length);\n    const tabs = Math.ceil((detabbed.length - spaces) / retabTabstop);\n\n    let result = '';\n\n    result += this.concat(tabs, '\\t');\n    result += this.concat(spaces, ' ');\n\n    return {\n      value: result,\n      length: detabbed.length,\n    };\n  }\n\n  retabLine(line: string, tabstop = configuration.tabstop): string {\n    const segments = line.split(/(\\s+)/);\n    let i = 0;\n\n    let retabbed = '';\n    for (const str of segments) {\n      if (!str) {\n        continue;\n      }\n\n      if (![' ', '\\t'].includes(str[0])) {\n        retabbed += str;\n        i += str.length;\n      } else {\n        const result = this.retabLineSegment(str, i, tabstop);\n\n        retabbed += result.value;\n        i += result.length;\n      }\n    }\n\n    return retabbed;\n  }\n\n  public retab(vimState: VimState, startLine: number, endLine: number) {\n    const originalLines: string[] = [];\n\n    const lastLine = Math.min(endLine, vimState.document.lineCount - 1);\n    for (let i = startLine; i <= lastLine; i++) {\n      originalLines.push(vimState.document.lineAt(i).text);\n    }\n\n    const replacedLines = originalLines.map((line: string) => {\n      return configuration.expandtab ? this.expandtab(line) : this.retabLine(line);\n    });\n\n    const replacedContent = replacedLines.join('\\n');\n    const lastLineLength = originalLines[originalLines.length - 1].length;\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range: new Range(startLine, 0, endLine, lastLineLength),\n      text: replacedContent,\n    });\n\n    if (this.arguments.newTabstop) {\n      const setTabstop = new SetCommand({\n        type: 'equal',\n        option: 'tabstop',\n        value: this.arguments.newTabstop.toString(),\n      });\n\n      setTabstop.execute(vimState);\n    }\n  }\n}\n","import { alt, oneOf, Parser, regexp, seq, string, whitespace } from 'parsimmon';\nimport { configuration, optionAliases } from '../../configuration/configuration';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { StatusBar } from '../../statusBar';\nimport { ExCommand } from '../../vimscript/exCommand';\n\ntype SetOperation =\n  | {\n      // :se[t]\n      // :se[t] {option}\n      type: 'show_or_set';\n      option: string | undefined;\n    }\n  | {\n      // :se[t] {option}?\n      type: 'show';\n      option: string;\n    }\n  | {\n      // :se[t] no{option}\n      type: 'unset';\n      option: string;\n    }\n  | {\n      // :se[t] {option}!\n      // :se[t] inv{option}\n      type: 'invert';\n      option: string;\n    }\n  | {\n      // :se[t] {option}&\n      // :se[t] {option}&vi\n      // :se[t] {option}&vim\n      type: 'default';\n      option: string;\n      source: 'vi' | 'vim' | '';\n    }\n  | {\n      // :se[t] {option}={value}\n      // :se[t] {option}:{value}\n      type: 'equal';\n      option: string;\n      value: string;\n    }\n  | {\n      // :se[t] {option}+={value}\n      type: 'add';\n      option: string;\n      value: string;\n    }\n  | {\n      // :se[t] {option}^={value}\n      type: 'multiply';\n      option: string;\n      value: string;\n    }\n  | {\n      // :se[t] {option}-={value}\n      type: 'subtract';\n      option: string;\n      value: string;\n    };\n\nconst optionParser = regexp(/[a-z]+/);\nconst valueParser = regexp(/\\S*/);\nconst setOperationParser: Parser<SetOperation> = whitespace\n  .then(\n    alt<SetOperation>(\n      string('no')\n        .then(optionParser)\n        .map((option) => {\n          return {\n            type: 'unset',\n            option,\n          };\n        }),\n      string('inv')\n        .then(optionParser)\n        .map((option) => {\n          return {\n            type: 'invert',\n            option,\n          };\n        }),\n      optionParser.skip(string('!')).map((option) => {\n        return {\n          type: 'invert',\n          option,\n        };\n      }),\n      optionParser.skip(string('?')).map((option) => {\n        return {\n          type: 'show',\n          option,\n        };\n      }),\n      seq(optionParser.skip(string('&')), alt(string('vim'), string('vi'), string(''))).map(\n        ([option, source]) => {\n          return {\n            type: 'default',\n            option,\n            source,\n          };\n        }\n      ),\n      seq(optionParser.skip(oneOf('=:')), valueParser).map(([option, value]) => {\n        return {\n          type: 'equal',\n          option,\n          value,\n        };\n      }),\n      seq(optionParser.skip(string('+=')), valueParser).map(([option, value]) => {\n        return {\n          type: 'add',\n          option,\n          value,\n        };\n      }),\n      seq(optionParser.skip(string('^=')), valueParser).map(([option, value]) => {\n        return {\n          type: 'multiply',\n          option,\n          value,\n        };\n      }),\n      seq(optionParser.skip(string('-=')), valueParser).map(([option, value]) => {\n        return {\n          type: 'subtract',\n          option,\n          value,\n        };\n      }),\n      optionParser.map((option) => {\n        return {\n          type: 'show_or_set',\n          option,\n        };\n      })\n    )\n  )\n  .fallback({ type: 'show_or_set', option: undefined });\n\nexport class SetCommand extends ExCommand {\n  public static readonly argParser: Parser<SetCommand> = setOperationParser.map(\n    (operation) => new SetCommand(operation)\n  );\n\n  private readonly operation: SetOperation;\n  constructor(operation: SetOperation) {\n    super();\n    this.operation = operation;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (this.operation.option === undefined) {\n      // TODO: Show all options that differ from their default value\n      return;\n    }\n\n    const option = optionAliases.get(this.operation.option) ?? this.operation.option;\n    const currentValue = configuration[option];\n    if (currentValue === undefined) {\n      throw VimError.fromCode(ErrorCode.UnknownOption, option);\n    }\n    const type =\n      typeof currentValue === 'boolean'\n        ? 'boolean'\n        : typeof currentValue === 'string'\n        ? 'string'\n        : 'number';\n\n    switch (this.operation.type) {\n      case 'show_or_set': {\n        if (this.operation.option === 'all') {\n          // TODO: Show all options\n        } else {\n          if (type === 'boolean') {\n            configuration[option] = true;\n          } else {\n            this.showOption(vimState, option, currentValue);\n          }\n        }\n        break;\n      }\n      case 'show': {\n        this.showOption(vimState, option, currentValue);\n        break;\n      }\n      case 'unset': {\n        if (type === 'boolean') {\n          configuration[option] = false;\n        } else {\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `no${option}`);\n        }\n        break;\n      }\n      case 'invert': {\n        if (type === 'boolean') {\n          configuration[option] = !currentValue;\n        } else {\n          // TODO: Could also be {option}!\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `inv${option}`);\n        }\n        break;\n      }\n      case 'default': {\n        if (this.operation.option === 'all') {\n          // TODO: Set all options to default\n        } else {\n          // TODO: Set the option to default\n        }\n        break;\n      }\n      case 'equal': {\n        if (type === 'boolean') {\n          // TODO: Could also be {option}:{value}\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `${option}=${this.operation.value}`);\n        } else if (type === 'string') {\n          configuration[option] = this.operation.value;\n        } else {\n          const value = Number.parseInt(this.operation.value, 10);\n          if (isNaN(value)) {\n            // TODO: Could also be {option}:{value}\n            throw VimError.fromCode(\n              ErrorCode.NumberRequiredAfterEqual,\n              `${option}=${this.operation.value}`\n            );\n          }\n          configuration[option] = value;\n        }\n        break;\n      }\n      case 'add': {\n        if (type === 'boolean') {\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `${option}+=${this.operation.value}`);\n        } else if (type === 'string') {\n          configuration[option] = currentValue + this.operation.value;\n        } else {\n          const value = Number.parseInt(this.operation.value, 10);\n          if (isNaN(value)) {\n            throw VimError.fromCode(\n              ErrorCode.NumberRequiredAfterEqual,\n              `${option}+=${this.operation.value}`\n            );\n          }\n          configuration[option] = currentValue + value;\n        }\n        break;\n      }\n      case 'multiply': {\n        if (type === 'boolean') {\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `${option}^=${this.operation.value}`);\n        } else if (type === 'string') {\n          configuration[option] = this.operation.value + currentValue;\n        } else {\n          const value = Number.parseInt(this.operation.value, 10);\n          if (isNaN(value)) {\n            throw VimError.fromCode(\n              ErrorCode.NumberRequiredAfterEqual,\n              `${option}^=${this.operation.value}`\n            );\n          }\n          configuration[option] = currentValue * value;\n        }\n        break;\n      }\n      case 'subtract': {\n        if (type === 'boolean') {\n          throw VimError.fromCode(ErrorCode.InvalidArgument, `${option}-=${this.operation.value}`);\n        } else if (type === 'string') {\n          configuration[option] = currentValue.split(this.operation.value).join('');\n        } else {\n          const value = Number.parseInt(this.operation.value, 10);\n          if (isNaN(value)) {\n            throw VimError.fromCode(\n              ErrorCode.NumberRequiredAfterEqual,\n              `${option}-=${this.operation.value}`\n            );\n          }\n          configuration[option] = currentValue - value;\n        }\n        break;\n      }\n      default:\n        const guard: never = this.operation;\n        throw new Error('Got unexpected SetOperation.type');\n    }\n  }\n\n  private showOption(vimState: VimState, option: string, value: boolean | string | number) {\n    if (typeof value === 'boolean') {\n      StatusBar.setText(vimState, value ? option : `no${option}`);\n    } else {\n      StatusBar.setText(vimState, `${option}=${value}`);\n    }\n  }\n}\n","import { window } from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class ShCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    window.createTerminal().show();\n  }\n}\n","import { Position, Selection } from 'vscode';\n\nimport { optWhitespace, Parser, seq, string } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { Address, LineRange } from '../../vimscript/lineRange';\nimport { numberParser } from '../../vimscript/parserUtils';\nimport { PositionDiff } from '../../common/motion/position';\n\nexport type ShiftDirection = '>' | '<';\nexport type ShiftArgs = {\n  dir: '>' | '<';\n  depth: number;\n  numLines: number | undefined;\n};\n\nexport class ShiftCommand extends ExCommand {\n  public static readonly argParser = (dir: '>' | '<'): Parser<ShiftCommand> =>\n    optWhitespace\n      .then(\n        seq(\n          // `:>>>` indents 3 times `shiftwidth`\n          string(dir)\n            .many()\n            .map((shifts) => shifts.length + 1)\n            .skip(optWhitespace),\n          // `:> 2` indents 2 lines\n          numberParser.fallback(undefined)\n        )\n      )\n      .map(([depth, numLines]) => new ShiftCommand({ dir, depth, numLines }));\n\n  private args: ShiftArgs;\n  constructor(args: ShiftArgs) {\n    super();\n    this.args = args;\n  }\n\n  public async execute(vimState: VimState): Promise<void> {\n    this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  public override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    let { start, end } = range.resolve(vimState);\n    if (this.args.numLines !== undefined) {\n      start = end;\n      end = start + this.args.numLines;\n    }\n\n    vimState.editor.selection = new Selection(new Position(start, 0), new Position(end, 0));\n    for (let i = 0; i < this.args.depth; i++) {\n      if (this.args.dir === '>') {\n        vimState.recordedState.transformer.vscodeCommand('editor.action.indentLines');\n      } else if (this.args.dir === '<') {\n        vimState.recordedState.transformer.vscodeCommand('editor.action.outdentLines');\n      }\n    }\n\n    vimState.recordedState.transformer.moveCursor(PositionDiff.startOfLine());\n  }\n}\n","import * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { TextEditor } from '../../textEditor';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class SmileCommand extends ExCommand {\n  static readonly smileText: string = `\n                               oooo$$$$$$$$$$$$oooo\n                          oo$$$$$$$$$$$$$$$$$$$$$$$$o\n                       oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$\n     o $ oo          o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$\n    oo $ $ \"$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$\n    \"$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$\n      $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$\n      $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  \"\"\"$$$\n       \"$$$\"\"\"\"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$\n        $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     \"$$$o\n       o$$\"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o\n       $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\" \"$$$$$$ooooo$$$$o\n      o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$\n      $$$$$$$$\"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$\"\"\"\"\"\"\"\"\n     \"\"\"\"       $$$$    \"$$$$$$$$$$$$$$$$$$$$$$$$$$$$\"      o$$$\n                \"$$$o     \"\"\"$$$$$$$$$$$$$$$$$$\"$$\"         $$$\n                  $$$o          \"$$\"\"$$$$$$\"\"\"\"           o$$$\n                   $$$$o                                o$$$\"\n                    \"$$$$o      o$$$$$$o\"$$$$o        o$$$$\n                      \"$$$$$oo     \"\"$$$$o$$$$$o   o$$$$\"\"\n                         \"\"$$$$$oooo  \"$$$o$$$$$$$$$\"\"\"\n                            \"\"$$$$$$$oo $$$$$$$$$$\n                                    \"\"\"\"$$$$$$$$$$$\n                                        $$$$$$$$$$$$\n                                         $$$$$$$$$$\"\n                                          \"$$$\"\"\"\"`;\n\n  constructor() {\n    super();\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n    await TextEditor.insert(vscode.window.activeTextEditor!, SmileCommand.smileText);\n  }\n}\n","import { oneOf, optWhitespace, Parser, seq } from 'parsimmon';\nimport { NumericString, NumericStringRadix } from '../../common/number/numericString';\nimport * as vscode from 'vscode';\nimport { PositionDiff } from '../../common/motion/position';\n\nimport { isVisualMode } from '../../mode/mode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { bangParser } from '../../vimscript/parserUtils';\n\nexport interface ISortCommandArguments {\n  reverse: boolean;\n  ignoreCase: boolean;\n  unique: boolean;\n  numeric: boolean;\n  // TODO: support other flags\n  // TODO(#6676): support pattern\n}\n\nexport class SortCommand extends ExCommand {\n  public static readonly argParser: Parser<SortCommand> = seq(\n    bangParser,\n    optWhitespace.then(oneOf('bfilnorux').many())\n  ).map(\n    ([bang, flags]) =>\n      new SortCommand({\n        reverse: bang,\n        ignoreCase: flags.includes('i'),\n        unique: flags.includes('u'),\n        numeric: flags.includes('n'),\n      })\n  );\n\n  private readonly arguments: ISortCommandArguments;\n  constructor(args: ISortCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  public override neovimCapable(): boolean {\n    return true;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (isVisualMode(vimState.currentMode)) {\n      const { start, end } = vimState.editor.selection;\n      await this.sortLines(vimState, start.line, end.line);\n    } else {\n      await this.sortLines(vimState, 0, vimState.document.lineCount - 1);\n    }\n  }\n\n  async sortLines(vimState: VimState, startLine: number, endLine: number) {\n    let originalLines: string[] = [];\n\n    for (\n      let currentLine = startLine;\n      currentLine <= endLine && currentLine < vimState.document.lineCount;\n      currentLine++\n    ) {\n      originalLines.push(vimState.document.lineAt(currentLine).text);\n    }\n\n    const lastLineLength = originalLines[originalLines.length - 1].length;\n\n    if (this.arguments.unique) {\n      const seen = new Set<string>();\n      const uniqueLines: string[] = [];\n      for (const line of originalLines) {\n        const adjustedLine = this.arguments.ignoreCase ? line.toLowerCase() : line;\n        if (!seen.has(adjustedLine)) {\n          seen.add(adjustedLine);\n          uniqueLines.push(line);\n        }\n      }\n      originalLines = uniqueLines;\n    }\n\n    let sortedLines;\n    if (this.arguments.numeric) {\n      sortedLines = originalLines.sort(\n        (a: string, b: string) =>\n          (NumericString.parse(a, NumericStringRadix.Dec)?.num.value ?? Number.MAX_VALUE) -\n          (NumericString.parse(b, NumericStringRadix.Dec)?.num.value ?? Number.MAX_VALUE)\n      );\n    } else if (this.arguments.ignoreCase) {\n      sortedLines = originalLines.sort((a: string, b: string) => a.localeCompare(b));\n    } else {\n      sortedLines = originalLines.sort();\n    }\n\n    if (this.arguments.reverse) {\n      sortedLines.reverse();\n    }\n\n    const sortedContent = sortedLines.join('\\n');\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'replaceText',\n      range: new vscode.Range(startLine, 0, endLine, lastLineLength),\n      text: sortedContent,\n      diff: PositionDiff.exactPosition(\n        new vscode.Position(startLine, sortedLines[0].match(/\\S/)?.index ?? 0)\n      ),\n    });\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    const { start, end } = range.resolve(vimState);\n\n    await this.sortLines(vimState, start, end);\n  }\n}\n","import { CancellationTokenSource, DecorationOptions, Position, Range, window } from 'vscode';\nimport { Jump } from '../../jumps/jump';\nimport { SearchState } from '../../state/searchState';\nimport { SubstituteState } from '../../state/substituteState';\nimport { VimError, ErrorCode } from '../../error';\nimport { VimState } from '../../state/vimState';\nimport { configuration } from '../../configuration/configuration';\nimport { decoration } from '../../configuration/decoration';\nimport { globalState } from '../../state/globalState';\nimport { StatusBar } from '../../statusBar';\nimport { Address, LineRange } from '../../vimscript/lineRange';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { Pattern, PatternMatch, SearchDirection } from '../../vimscript/pattern';\nimport { alt, any, noneOf, oneOf, optWhitespace, Parser, regexp, seq, string } from 'parsimmon';\nimport { numberParser } from '../../vimscript/parserUtils';\nimport { PositionDiff } from '../../common/motion/position';\nimport { escapeCSSIcons } from '../../util/statusBarTextUtils';\nimport { SearchDecorations, ensureVisible, formatDecorationText } from '../../util/decorationUtils';\n\ntype ReplaceStringComponent =\n  | { type: 'string'; value: string }\n  | { type: 'capture_group'; group: number | '&' }\n  | { type: 'prev_replace_string' };\n\nexport class ReplaceString {\n  private components: ReplaceStringComponent[];\n  constructor(components: ReplaceStringComponent[]) {\n    this.components = components;\n  }\n\n  public toString(): string {\n    return this.components\n      .map((component) => {\n        if (component.type === 'string') {\n          return component.value;\n        } else if (component.type === 'capture_group') {\n          return component.group === '&' ? '&' : `\\\\${component.group}`;\n        } else if (component.type === 'prev_replace_string') {\n          return '~';\n        } else {\n          const guard: unknown = component;\n          return '';\n        }\n      })\n      .join('');\n  }\n\n  public resolve(matches: RegExpMatchArray): string {\n    return this.components\n      .map((component) => {\n        if (component.type === 'string') {\n          return component.value;\n        } else if (component.type === 'capture_group') {\n          const group: number = component.group === '&' ? 0 : component.group;\n          return matches?.[group] ?? '';\n        } else if (component.type === 'prev_replace_string') {\n          return globalState.substituteState?.replaceString.toString() ?? '';\n        } else {\n          const guard: unknown = component;\n          return '';\n        }\n      })\n      .join('');\n  }\n}\n\n/**\n * NOTE: for \"pattern\", undefined is different from an empty string.\n * when it's undefined, it means to repeat the previous REPLACEMENT and ignore \"replace\".\n * when it's an empty string, it means to use the previous SEARCH (not replacement) state,\n * and replace with whatever's set by \"replace\" (even an empty string).\n */\nexport interface ISubstituteCommandArguments {\n  pattern: Pattern | undefined;\n  replace: ReplaceString;\n  flags: SubstituteFlags;\n  count?: number;\n}\n\n/**\n * The flags that you can use for the substitute commands:\n * [&] Must be the first one: Keep the flags from the previous substitute command.\n * [c] Confirm each substitution.\n * [e] When the search pattern fails, do not issue an error message and, in\n *     particular, continue in maps as if no error occurred.\n * [g] Replace all occurrences in the line.  Without this argument, replacement\n *     occurs only for the first occurrence in each line.\n * [i] Ignore case for the pattern.\n * [I] Don't ignore case for the pattern.\n * [n] Report the number of matches, do not actually substitute.\n * [p] Print the line containing the last substitute.\n * [#] Like [p] and prepend the line number.\n * [l] Like [p] but print the text like |:list|.\n * [r] When the search pattern is empty, use the previously used search pattern\n *     instead of the search pattern from the last substitute or \":global\".\n */\nexport interface SubstituteFlags {\n  keepPreviousFlags?: true; // TODO: use this flag\n  confirmEach?: true;\n  suppressError?: true; // TODO: use this flag\n  replaceAll?: true;\n  ignoreCase?: true; // TODO: use this flag\n  noIgnoreCase?: true; // TODO: use this flag\n  printCount?: true;\n  // TODO: use the following flags:\n  printLastMatchedLine?: true;\n  printLastMatchedLineWithNumber?: true;\n  printLastMatchedLineWithList?: true;\n  usePreviousPattern?: true;\n}\n\n// TODO: `:help sub-replace-special`\n// TODO: `:help sub-replace-expression`\nconst replaceStringParser = (delimiter: string): Parser<ReplaceString> =>\n  alt<ReplaceStringComponent>(\n    string('\\\\').then(\n      any.fallback(undefined).map((escaped) => {\n        if (escaped === undefined || escaped === '\\\\') {\n          return { type: 'string' as const, value: '\\\\' };\n        } else if (escaped === '/') {\n          return { type: 'string' as const, value: '/' };\n        } else if (escaped === 'b') {\n          return { type: 'string' as const, value: '\\b' };\n        } else if (escaped === 'r') {\n          return { type: 'string' as const, value: '\\r' };\n        } else if (escaped === 'n') {\n          return { type: 'string' as const, value: '\\n' };\n        } else if (escaped === 't') {\n          return { type: 'string' as const, value: '\\t' };\n        } else if (escaped === '&') {\n          return { type: 'string' as const, value: '&' };\n        } else if (escaped === '~') {\n          return { type: 'string' as const, value: '~' };\n        } else if (/[0-9]/.test(escaped)) {\n          return { type: 'capture_group' as const, group: Number.parseInt(escaped, 10) };\n        } else {\n          return { type: 'string' as const, value: `\\\\${escaped}` };\n        }\n      })\n    ),\n    string('&').result({ type: 'capture_group' as const, group: '&' }),\n    string('~').result({ type: 'prev_replace_string' as const }),\n    noneOf(delimiter).map((value) => ({ type: 'string', value }))\n  )\n    .many()\n    .map((components) => new ReplaceString(components));\n\nconst substituteFlagsParser: Parser<SubstituteFlags> = seq(\n  string('&').fallback(undefined),\n  oneOf('cegiInp#lr').many()\n).map(([amp, flagChars]) => {\n  const flags: SubstituteFlags = {};\n  if (amp === '&') {\n    flags.keepPreviousFlags = true;\n  }\n  for (const flag of flagChars) {\n    switch (flag) {\n      case 'c':\n        flags.confirmEach = true;\n        break;\n      case 'e':\n        flags.suppressError = true;\n        break;\n      case 'g':\n        flags.replaceAll = true;\n        break;\n      case 'i':\n        flags.ignoreCase = true;\n        break;\n      case 'I':\n        flags.noIgnoreCase = true;\n        break;\n      case 'n':\n        flags.printCount = true;\n        break;\n      case 'p':\n        flags.printLastMatchedLine = true;\n        break;\n      case '#':\n        flags.printLastMatchedLineWithNumber = true;\n        break;\n      case 'l':\n        flags.printLastMatchedLineWithList = true;\n        break;\n      case 'r':\n        flags.usePreviousPattern = true;\n        break;\n    }\n  }\n  return flags;\n});\n\nconst countParser: Parser<number | undefined> = optWhitespace\n  .then(numberParser)\n  .fallback(undefined);\n\n/**\n * vim has a distinctly different state for previous search and for previous substitute.  However, in SOME\n * cases a substitution will also update the search state along with the substitute state.\n *\n * Also, the substitute command itself will sometimes use the search state, and other times it will use the\n * substitute state.\n *\n * These are the following cases and how vim handles them:\n * 1. :s/this/that\n *   - standard search/replace\n *   - update substitution state\n *   - update search state too!\n * 2. :s or :s [flags]\n *   - use previous SUBSTITUTION state, and repeat previous substitution pattern and replace.\n *   - do not touch search state!\n *   - changing substitution state is dont-care cause we're repeating it ;)\n * 3. :s/ or :s// or :s///\n *   - use previous SEARCH state (not substitution), and DELETE the string matching the pattern (replace with nothing)\n *   - update substitution state\n *   - updating search state is dont-care cause we're repeating it ;)\n * 4. :s/this or :s/this/ or :s/this//\n *   - input is pattern - replacement is empty (delete)\n *   - update replacement state\n *   - update search state too!\n */\nexport class SubstituteCommand extends ExCommand {\n  public static readonly argParser: Parser<SubstituteCommand> = optWhitespace.then(\n    alt(\n      // :s[ubstitute]/{pattern}/{string}/[flags] [count]\n      regexp(/[^\\w\\s\\\\|\"]{1}/).chain((delimiter) =>\n        seq(\n          Pattern.parser({ direction: SearchDirection.Forward, delimiter }),\n          replaceStringParser(delimiter),\n          string(delimiter).then(substituteFlagsParser).fallback({}),\n          countParser\n        ).map(\n          ([pattern, replace, flags, count]) =>\n            new SubstituteCommand({ pattern, replace, flags, count })\n        )\n      ),\n\n      // :s[ubstitute] [flags] [count]\n      seq(substituteFlagsParser, countParser).map(\n        ([flags, count]) =>\n          new SubstituteCommand({\n            pattern: undefined,\n            replace: new ReplaceString([]),\n            flags,\n            count,\n          })\n      )\n    )\n  );\n\n  public readonly arguments: ISubstituteCommandArguments;\n  protected abort: boolean;\n  private cSearchHighlights?: DecorationOptions[];\n  private confirmedSubstitutions?: DecorationOptions[];\n  constructor(args: ISubstituteCommandArguments) {\n    super();\n    this.arguments = args;\n    this.abort = false;\n  }\n\n  public override neovimCapable(): boolean {\n    // We need to use VSCode's quickpick capabilities to do confirmation\n    return !this.arguments.flags.confirmEach;\n  }\n\n  public getSubstitutionDecorations(\n    vimState: VimState,\n    lineRange = new LineRange(new Address({ type: 'current_line' }))\n  ): SearchDecorations {\n    const substitutionAppend: DecorationOptions[] = [];\n    const substitutionReplace: DecorationOptions[] = [];\n    const searchHighlight: DecorationOptions[] = [];\n\n    const subsArr: DecorationOptions[] =\n      configuration.inccommand === 'replace' ? substitutionReplace : substitutionAppend;\n\n    const { pattern, replace } = this.resolvePatterns(false);\n\n    const showReplacements = this.arguments.pattern?.closed && configuration.inccommand;\n\n    let matches: PatternMatch[] = [];\n    if (pattern?.patternString) {\n      matches = pattern.allMatches(vimState, { lineRange });\n    }\n\n    const global =\n      (configuration.gdefault || configuration.substituteGlobalFlag) !==\n      (this.arguments.flags.replaceAll ?? false);\n    const lines = new Set<number>();\n\n    for (const match of matches) {\n      if (!global && lines.has(match.range.start.line)) {\n        // If not global, only replace one match per line\n        continue;\n      }\n\n      lines.add(match.range.start.line);\n      if (showReplacements) {\n        const contentText = formatDecorationText(\n          replace.resolve(match.groups),\n          vimState.editor.options.tabSize as number\n        );\n\n        subsArr.push({\n          range: match.range,\n          renderOptions: {\n            [configuration.inccommand === 'append' ? 'after' : 'before']: { contentText },\n          },\n        });\n      } else {\n        searchHighlight.push(ensureVisible(match.range));\n      }\n    }\n    return { substitutionAppend, substitutionReplace, searchHighlight };\n  }\n\n  /**\n   * @returns If match, (# newlines added) - (# newlines removed)\n   *          Else, undefined\n   */\n  private async replaceMatchRange(\n    vimState: VimState,\n    match: PatternMatch\n  ): Promise<number | undefined> {\n    if (this.arguments.flags.printCount) {\n      return 0;\n    }\n\n    const replaceText = this.arguments.replace.resolve(match.groups);\n\n    if (this.arguments.flags.confirmEach) {\n      if (await this.confirmReplacement(vimState, match, replaceText)) {\n        vimState.recordedState.transformer.replace(match.range, replaceText);\n      } else {\n        return undefined;\n      }\n    } else {\n      vimState.recordedState.transformer.replace(match.range, replaceText);\n    }\n\n    const addedNewlines = replaceText.split('\\n').length - 1;\n    const removedNewlines = match.groups[0].split('\\n').length - 1;\n    return addedNewlines - removedNewlines;\n  }\n\n  private async confirmReplacement(\n    vimState: VimState,\n    match: PatternMatch,\n    replaceText: string\n  ): Promise<boolean> {\n    const cancellationToken = new CancellationTokenSource();\n    const validSelections: readonly string[] = ['y', 'n', 'a', 'q', 'l'];\n    let selection: string = '';\n    const prompt = escapeCSSIcons(\n      `Replace with ${formatDecorationText(\n        replaceText,\n        vimState.editor.options.tabSize as number,\n        '\\\\n'\n      )} (${validSelections.join('/')})?`\n    );\n\n    const newConfirmationSearchHighlights =\n      this.cSearchHighlights?.filter((d) => !d.range.isEqual(match.range)) ?? [];\n\n    vimState.editor.revealRange(new Range(match.range.start.line, 0, match.range.start.line, 0));\n    vimState.editor.setDecorations(decoration.searchHighlight, newConfirmationSearchHighlights);\n    vimState.editor.setDecorations(decoration.searchMatch, [ensureVisible(match.range)]);\n    vimState.editor.setDecorations(\n      decoration.confirmedSubstitution,\n      this.confirmedSubstitutions ?? []\n    );\n    await window.showInputBox(\n      {\n        ignoreFocusOut: true,\n        prompt,\n        placeHolder: validSelections.join('/'),\n        validateInput: (input: string): string => {\n          if (validSelections.includes(input)) {\n            selection = input;\n            cancellationToken.cancel();\n          }\n          return prompt;\n        },\n      },\n      cancellationToken.token\n    );\n\n    if (selection === 'q' || selection === 'l' || !selection) {\n      this.abort = true;\n    } else if (selection === 'a') {\n      this.arguments.flags.confirmEach = undefined;\n    }\n\n    if (selection === 'y' || selection === 'a' || selection === 'l') {\n      if (this.cSearchHighlights) {\n        this.cSearchHighlights = newConfirmationSearchHighlights;\n      }\n\n      this.confirmedSubstitutions?.push({\n        range: match.range,\n        renderOptions: {\n          before: {\n            contentText: formatDecorationText(\n              replaceText,\n              vimState.editor.options.tabSize as number\n            ),\n          },\n        },\n      });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns the concrete Pattern and ReplaceString to be used for this substitution.\n   * If throwErrors is true, errors will be thrown :)\n   */\n  private resolvePatterns(throwErrors: boolean): {\n    pattern: Pattern | undefined;\n    replace: ReplaceString;\n  } {\n    let { pattern, replace } = this.arguments;\n    if (pattern === undefined) {\n      // If no pattern is entered, use previous SUBSTITUTION state and don't update search state\n      // i.e. :s\n      const prevSubstituteState = globalState.substituteState;\n      if (\n        prevSubstituteState?.searchPattern === undefined ||\n        prevSubstituteState.searchPattern.patternString === ''\n      ) {\n        if (throwErrors) {\n          throw VimError.fromCode(ErrorCode.NoPreviousSubstituteRegularExpression);\n        }\n      } else {\n        pattern = prevSubstituteState.searchPattern;\n        replace = prevSubstituteState.replaceString;\n      }\n    } else {\n      if (pattern.patternString === '') {\n        // If an explicitly empty pattern is entered, use previous search state (including search with * and #) and update both states\n        // e.g :s/ or :s///\n        const prevSearchState = globalState.searchState;\n        if (prevSearchState === undefined || prevSearchState.searchString === '') {\n          if (throwErrors) {\n            throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n          }\n        } else {\n          pattern = prevSearchState.pattern;\n        }\n      }\n    }\n    return { pattern, replace };\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    await this.executeWithRange(vimState, new LineRange(new Address({ type: 'current_line' })));\n  }\n\n  override async executeWithRange(vimState: VimState, lineRange: LineRange): Promise<void> {\n    let { start, end } = lineRange.resolve(vimState);\n\n    if (this.arguments.count && this.arguments.count >= 0) {\n      start = end;\n      end = end + this.arguments.count - 1;\n    }\n\n    // TODO: this is all a bit gross\n    const { pattern, replace } = this.resolvePatterns(true);\n    this.arguments.replace = replace;\n\n    // `/g` flag inverts the default behavior (from `gdefault`)\n    const global =\n      (configuration.gdefault || configuration.substituteGlobalFlag) !==\n      (this.arguments.flags.replaceAll ?? false);\n\n    // TODO: `allMatches` lies for patterns with empty branches, which makes this wrong (not that anyone cares)\n    const allMatches =\n      pattern?.allMatches(vimState, {\n        // TODO: This method should probably take start/end lines as numbers\n        lineRange: new LineRange(\n          new Address({ type: 'number', num: start + 1 }),\n          ',',\n          new Address({ type: 'number', num: end + 1 })\n        ),\n      }) ?? [];\n\n    let replaceableMatches;\n    if (global) {\n      // every match is replaceable\n      replaceableMatches = allMatches;\n    } else {\n      // only the first match on a line is replaceable\n      const replaceableLines = new Set<number>();\n      replaceableMatches = allMatches.filter((match) => {\n        if (replaceableLines.has(match.range.start.line)) {\n          return false;\n        }\n        replaceableLines.add(match.range.start.line);\n        return true;\n      });\n    }\n\n    if (this.arguments.flags.confirmEach) {\n      vimState.editor.setDecorations(decoration.substitutionAppend, []);\n      vimState.editor.setDecorations(decoration.substitutionReplace, []);\n\n      if (configuration.inccommand) {\n        this.confirmedSubstitutions = [];\n      }\n      if (configuration.incsearch) {\n        this.cSearchHighlights = replaceableMatches.map((match) => ensureVisible(match.range));\n      }\n    }\n\n    const substitutionLines = new Set<number>();\n    let substitutions = 0;\n    let netNewLines = 0;\n\n    for (const match of replaceableMatches) {\n      if (this.abort) {\n        break;\n      }\n\n      const newLines = await this.replaceMatchRange(vimState, match);\n      if (newLines !== undefined) {\n        substitutions++;\n        substitutionLines.add(match.range.start.line);\n        netNewLines += newLines;\n      }\n    }\n\n    if (substitutions > 0) {\n      // if any substitutions were made, jump to latest one\n      const lastLine = Math.max(...substitutionLines.values()) + netNewLines;\n      const cursor = new Position(Math.max(0, lastLine), 0);\n      globalState.jumpTracker.recordJump(\n        new Jump({\n          document: vimState.document,\n          position: cursor,\n        }),\n        Jump.fromStateNow(vimState)\n      );\n      vimState.recordedState.transformer.moveCursor(PositionDiff.exactPosition(cursor), 0);\n    }\n\n    this.confirmedSubstitutions = undefined;\n    this.cSearchHighlights = undefined;\n    vimState.editor.setDecorations(decoration.confirmedSubstitution, []);\n\n    this.setStatusBarText(vimState, substitutions, substitutionLines.size);\n\n    if (this.arguments.pattern !== undefined) {\n      globalState.substituteState = new SubstituteState(pattern, replace);\n      globalState.searchState = new SearchState(\n        SearchDirection.Forward,\n        vimState.cursorStopPosition,\n        pattern?.patternString,\n        {}\n      );\n    }\n  }\n\n  private setStatusBarText(vimState: VimState, substitutions: number, lines: number) {\n    if (substitutions === 0) {\n      StatusBar.displayError(\n        vimState,\n        VimError.fromCode(ErrorCode.PatternNotFound, this.arguments.pattern?.patternString)\n      );\n    } else if (this.arguments.flags.printCount) {\n      StatusBar.setText(\n        vimState,\n        `${substitutions} match${substitutions > 1 ? 'es' : ''} on ${lines} line${\n          lines > 1 ? 's' : ''\n        }`\n      );\n    } else if (substitutions > configuration.report) {\n      StatusBar.setText(\n        vimState,\n        `${substitutions} substitution${substitutions > 1 ? 's' : ''} on ${lines} line${\n          lines > 1 ? 's' : ''\n        }`\n      );\n    }\n  }\n}\n","import { alt, optWhitespace, regexp, seq, string, whitespace } from 'parsimmon';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport {\n  bangParser,\n  FileCmd,\n  fileCmdParser,\n  FileOpt,\n  fileOptParser,\n  numberParser,\n} from '../../vimscript/parserUtils';\n\nexport enum TabCommandType {\n  Next,\n  Previous,\n  First,\n  Last,\n  Absolute,\n  New,\n  Close,\n  Only,\n  Move,\n}\n\n// TODO: many of these arguments aren't used\nexport type ITabCommandArguments =\n  | {\n    type: TabCommandType.Absolute;\n    count: number;\n  }\n  | {\n    type: TabCommandType.First | TabCommandType.Last;\n    cmd?: FileCmd;\n  }\n  | {\n    type: TabCommandType.Next | TabCommandType.Previous;\n    bang: boolean;\n    cmd?: FileCmd;\n    count?: number;\n  }\n  | {\n    type: TabCommandType.Close | TabCommandType.Only;\n    bang: boolean;\n    count?: number;\n  }\n  | {\n    type: TabCommandType.New;\n    opt: FileOpt;\n    cmd?: FileCmd;\n    file?: string;\n  }\n  | {\n    type: TabCommandType.Move;\n    direction?: 'left' | 'right';\n    count?: number;\n  };\n\n//\n//  Implements most buffer and tab ex commands\n//  http://vimdoc.sourceforge.net/htmldoc/tabpage.html\n//\nexport class TabCommand extends ExCommand {\n  // TODO: `count` is parsed as a number, which is incomplete\n  public static readonly argParsers = {\n    bfirst: whitespace\n      .then(fileCmdParser)\n      .fallback(undefined)\n      .map((cmd) => {\n        return new TabCommand({ type: TabCommandType.First, cmd });\n      }),\n    blast: whitespace\n      .then(fileCmdParser)\n      .fallback(undefined)\n      .map((cmd) => {\n        return new TabCommand({ type: TabCommandType.Last, cmd });\n      }),\n    bnext: seq(\n      bangParser,\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(numberParser).fallback(undefined)\n    ).map(([bang, cmd, count]) => {\n      return new TabCommand({ type: TabCommandType.Next, bang, cmd, count });\n    }),\n    bprev: seq(\n      bangParser,\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      optWhitespace.then(numberParser).fallback(undefined)\n    ).map(([bang, cmd, count]) => {\n      return new TabCommand({ type: TabCommandType.Previous, bang, cmd, count });\n    }),\n    tabclose: seq(bangParser, optWhitespace.then(numberParser).fallback(undefined)).map(\n      ([bang, count]) => {\n        return new TabCommand({ type: TabCommandType.Close, bang, count });\n      }\n    ),\n    tabonly: seq(bangParser, optWhitespace.then(numberParser).fallback(undefined)).map(\n      ([bang, count]) => {\n        return new TabCommand({ type: TabCommandType.Only, bang, count });\n      }\n    ),\n    tabnew: seq(\n      optWhitespace.then(fileOptParser).fallback([]),\n      optWhitespace.then(fileCmdParser).fallback(undefined),\n      regexp(/\\S+/).fallback(undefined)\n    ).map(([opt, cmd, file]) => {\n      return new TabCommand({\n        type: TabCommandType.New,\n        opt,\n        cmd,\n        file,\n      });\n    }),\n    tabmove: optWhitespace\n      .then(\n        seq(\n          alt<'right' | 'left'>(string('+').result('right'), string('-').result('left')).fallback(\n            undefined\n          ),\n          numberParser.fallback(undefined)\n        )\n      )\n      .map(([direction, count]) => new TabCommand({ type: TabCommandType.Move, direction, count })),\n  };\n\n  public readonly arguments: ITabCommandArguments;\n  constructor(args: ITabCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  private async executeCommandWithCount(count: number, command: string): Promise<void> {\n    for (let i = 0; i < count; i++) {\n      await vscode.commands.executeCommand(command);\n    }\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    switch (this.arguments.type) {\n      case TabCommandType.Absolute:\n        if (this.arguments.count !== undefined && this.arguments.count >= 0) {\n          await vscode.commands.executeCommand(\n            'workbench.action.openEditorAtIndex',\n            this.arguments.count\n          );\n        }\n        break;\n      case TabCommandType.Next:\n        if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n          break;\n        }\n\n        if (this.arguments.count) {\n\n          const tabGroup = vscode.window.tabGroups.activeTabGroup;\n          if (0 < this.arguments.count && this.arguments.count <= tabGroup.tabs.length) {\n            const tab = tabGroup.tabs[this.arguments.count - 1];\n            if ((tab.input as vscode.TextDocument).uri !== undefined) {\n              const uri = (tab.input as vscode.TextDocument).uri;\n              await vscode.commands.executeCommand('vscode.open', uri);\n            }\n          }\n        } else {\n          await vscode.commands.executeCommand('workbench.action.nextEditorInGroup');\n        }\n\n        break;\n      case TabCommandType.Previous:\n        if (this.arguments.count !== undefined && this.arguments.count <= 0) {\n          break;\n        }\n\n        await this.executeCommandWithCount(\n          this.arguments.count || 1,\n          'workbench.action.previousEditorInGroup'\n        );\n        break;\n      case TabCommandType.First:\n        await vscode.commands.executeCommand('workbench.action.openEditorAtIndex1');\n        break;\n      case TabCommandType.Last:\n        await vscode.commands.executeCommand('workbench.action.lastEditorInGroup');\n        break;\n      case TabCommandType.New: {\n        const hasFile = !(this.arguments.file === undefined || this.arguments.file === '');\n        if (hasFile) {\n          const isAbsolute = path.isAbsolute(this.arguments.file!);\n          const isInWorkspace =\n            vscode.workspace.workspaceFolders !== undefined &&\n            vscode.workspace.workspaceFolders.length > 0;\n          const currentFilePath = vscode.window.activeTextEditor!.document.uri.fsPath;\n\n          let toOpenPath: string;\n          if (isAbsolute) {\n            toOpenPath = this.arguments.file!;\n          } else if (isInWorkspace) {\n            const workspacePath = vscode.workspace.workspaceFolders![0].uri.path;\n            toOpenPath = path.join(workspacePath, this.arguments.file!);\n          } else {\n            toOpenPath = path.join(path.dirname(currentFilePath), this.arguments.file!);\n          }\n\n          if (toOpenPath !== currentFilePath) {\n            await vscode.commands.executeCommand('vscode.open', vscode.Uri.file(toOpenPath));\n          }\n        } else {\n          await vscode.commands.executeCommand('workbench.action.files.newUntitledFile');\n        }\n        break;\n      }\n      case TabCommandType.Close:\n        // Navigate the correct position\n        if (this.arguments.count === undefined) {\n          await vscode.commands.executeCommand('workbench.action.closeActiveEditor');\n          break;\n        }\n\n        if (this.arguments.count === 0) {\n          // Wrong paramter\n          break;\n        }\n\n        // TODO: Close Page {count}. Page count is one-based.\n        break;\n      case TabCommandType.Only:\n        await vscode.commands.executeCommand('workbench.action.closeOtherEditors');\n        break;\n      case TabCommandType.Move: {\n        const { count, direction } = this.arguments;\n        let args;\n        if (direction !== undefined) {\n          args = { to: direction, by: 'tab', value: count ?? 1 };\n        } else if (count === 0) {\n          args = { to: 'first' };\n        } else if (count === undefined) {\n          args = { to: 'last' };\n        } else {\n          args = { to: 'position', by: 'tab', value: count + 1 };\n        }\n        await vscode.commands.executeCommand('moveActiveEditor', args);\n        break;\n      }\n      default:\n        break;\n    }\n  }\n}\n","import { Parser, succeed } from 'parsimmon';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\n\nexport class TerminalCommand extends ExCommand {\n  public static readonly argParser: Parser<TerminalCommand> = succeed(new TerminalCommand());\n\n  async execute(vimState: VimState): Promise<void> {\n    await vscode.commands.executeCommand('workbench.action.createTerminalEditor');\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { CommandUndo } from '../../actions/commands/actions';\nimport { Position } from 'vscode';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { optWhitespace, Parser } from 'parsimmon';\nimport { numberParser } from '../../vimscript/parserUtils';\n\n//\n//  Implements :u[ndo]\n//  http://vimdoc.sourceforge.net/htmldoc/undo.html\n//\nexport class UndoCommand extends ExCommand {\n  public static readonly argParser: Parser<UndoCommand> = optWhitespace\n    .then(numberParser)\n    .fallback(undefined)\n    .map((count) => new UndoCommand(count));\n\n  private count?: number;\n  private constructor(count?: number) {\n    super();\n    this.count = count;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO: Use `this.count`\n    await new CommandUndo().exec(new Position(0, 0), vimState);\n  }\n}\n","import { ErrorCode, VimError } from '../../error';\nimport { StatusBar } from '../../statusBar';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { all, Parser, whitespace } from 'parsimmon';\n\nexport class VsCodeCommand extends ExCommand {\n  public static readonly argParser: Parser<VsCodeCommand> = whitespace\n    .then(all)\n    .map((command) => new VsCodeCommand(command));\n\n  private command?: string;\n  private constructor(command?: string) {\n    super();\n    this.command = command;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    if (!this.command) {\n      StatusBar.displayError(vimState, VimError.fromCode(ErrorCode.ArgumentRequired));\n      return;\n    }\n    await vscode.commands.executeCommand(this.command);\n  }\n}\n","import { Parser } from 'parsimmon';\nimport * as vscode from 'vscode';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser } from '../../vimscript/parserUtils';\n\n//\n//  Implements :wall (write all)\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:wall\n//\nexport class WallCommand extends ExCommand {\n  public static readonly argParser: Parser<WallCommand> = bangParser.map(\n    (bang) => new WallCommand(bang)\n  );\n\n  private readonly bang: boolean;\n  constructor(bang?: boolean) {\n    super();\n    this.bang = bang ?? false;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO : overwrite readonly files when bang? == true\n    await vscode.workspace.saveAll(false);\n  }\n}\n","import * as fs from 'platform/fs';\nimport * as path from 'path';\nimport * as vscode from 'vscode';\nimport { Logger } from '../../util/logger';\nimport { StatusBar } from '../../statusBar';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { all, alt, optWhitespace, Parser, regexp, seq, string } from 'parsimmon';\nimport { bangParser, fileNameParser, FileOpt, fileOptParser } from '../../vimscript/parserUtils';\n\nexport type IWriteCommandArguments =\n  | {\n      bang: boolean;\n      opt: FileOpt;\n      bgWrite: boolean;\n    } & ({ cmd: string } | { file: string } | {});\n\n//\n//  Implements :write\n//  http://vimdoc.sourceforge.net/htmldoc/editing.html#:write\n//\nexport class WriteCommand extends ExCommand {\n  public static readonly argParser: Parser<WriteCommand> = seq(\n    bangParser.skip(optWhitespace),\n    fileOptParser.skip(optWhitespace),\n    alt<{ cmd: string } | { file: string }>(\n      string('!')\n        .then(all)\n        .map((cmd) => {\n          return { cmd };\n        }),\n      fileNameParser.map((file) => {\n        return { file };\n      })\n      // TODO: Support `:help :w_a` ('>>')\n    ).fallback({})\n  ).map(([bang, opt, other]) => new WriteCommand({ bang, opt, bgWrite: true, ...other }));\n\n  public override isRepeatableWithDot = false;\n\n  public readonly arguments: IWriteCommandArguments;\n  private readonly logger = Logger.get('Write');\n\n  constructor(args: IWriteCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    // TODO: Use arguments: opt, file, cmd\n\n    // If the file isn't on disk because it's brand new or on a remote file system, let VS Code handle it\n    if (vimState.document.isUntitled || vimState.document.uri.scheme !== 'file') {\n      await this.background(vscode.commands.executeCommand('workbench.action.files.save'));\n      return;\n    }\n\n    try {\n      await fs.accessAsync(vimState.document.fileName, fs.constants.W_OK);\n      await this.save(vimState);\n    } catch (accessErr) {\n      if (this.arguments.bang) {\n        try {\n          const mode = await fs.getMode(vimState.document.fileName);\n          await fs.chmodAsync(vimState.document.fileName, 0o666);\n          // We must do a foreground write so we can await the save\n          // and chmod the file back to its original state\n          this.arguments.bgWrite = false;\n          await this.save(vimState);\n          await fs.chmodAsync(vimState.document.fileName, mode);\n        } catch (e) {\n          StatusBar.setText(vimState, e.message);\n        }\n      } else {\n        StatusBar.setText(vimState, accessErr.message);\n      }\n    }\n  }\n\n  private async save(vimState: VimState): Promise<void> {\n    await this.background(\n      vimState.document.save().then((success) => {\n        if (success) {\n          StatusBar.setText(\n            vimState,\n            `\"${path.basename(vimState.document.fileName)}\" ${vimState.document.lineCount}L ${\n              vimState.document.getText().length\n            }C written`\n          );\n        } else {\n          this.logger.warn(':w failed');\n          // TODO: What's the right thing to do here?\n        }\n      })\n    );\n  }\n\n  private async background<T>(fn: Thenable<T>): Promise<void> {\n    if (!this.arguments.bgWrite) {\n      await fn;\n    }\n  }\n}\n","import { optWhitespace, Parser, regexp, seq } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser, fileNameParser, FileOpt, fileOptParser } from '../../vimscript/parserUtils';\nimport { QuitCommand } from './quit';\nimport { WriteCommand } from './write';\n\n//\n// Implements :writequit\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#write-quit\n//\nexport interface IWriteQuitCommandArguments {\n  bang: boolean;\n  opt: FileOpt;\n  file?: string;\n}\n\nexport class WriteQuitCommand extends ExCommand {\n  public static readonly argParser: Parser<WriteQuitCommand> = seq(\n    bangParser.skip(optWhitespace),\n    fileOptParser.skip(optWhitespace),\n    fileNameParser.fallback(undefined)\n  ).map(([bang, opt, file]) => new WriteQuitCommand(file ? { bang, opt, file } : { bang, opt }));\n\n  public override isRepeatableWithDot = false;\n\n  private readonly args: IWriteQuitCommandArguments;\n  constructor(args: IWriteQuitCommandArguments) {\n    super();\n    this.args = args;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    await new WriteCommand({ bgWrite: false, ...this.args }).execute(vimState);\n\n    await new QuitCommand({\n      // wq! fails when no file name is provided\n      bang: false,\n    }).execute(vimState);\n  }\n}\n","import { Parser, seq, whitespace } from 'parsimmon';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { bangParser, FileOpt, fileOptParser } from '../../vimscript/parserUtils';\nimport * as wall from '../commands/wall';\nimport * as quit from './quit';\n\n//\n// Implements :writequitall\n// http://vimdoc.sourceforge.net/htmldoc/editing.html#:wqall\n//\nexport interface IWriteQuitAllCommandArguments {\n  bang: boolean;\n  fileOpt: FileOpt;\n}\n\nexport class WriteQuitAllCommand extends ExCommand {\n  public static readonly argParser: Parser<WriteQuitAllCommand> = seq(\n    bangParser,\n    whitespace.then(fileOptParser).fallback([])\n  ).map(([bang, fileOpt]) => new WriteQuitAllCommand({ bang, fileOpt }));\n\n  public override isRepeatableWithDot = false;\n\n  private readonly arguments: IWriteQuitAllCommandArguments;\n  constructor(args: IWriteQuitAllCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  // Writing command. Taken as a basis from the \"write.ts\" file.\n  async execute(vimState: VimState): Promise<void> {\n    const quitArgs: quit.IQuitCommandArguments = {\n      // wq! fails when no file name is provided\n      bang: false,\n    };\n\n    const wallCmd = new wall.WallCommand(this.arguments.bang);\n    await wallCmd.execute(vimState);\n\n    // TODO: fileOpt is not used\n\n    quitArgs.quitAll = true;\n    const quitCmd = new quit.QuitCommand(quitArgs);\n    await quitCmd.execute(vimState);\n  }\n}\n","import { alt, any, optWhitespace, Parser, seq, succeed, whitespace } from 'parsimmon';\nimport { Position } from 'vscode';\nimport { YankOperator } from '../../actions/operator';\nimport { RegisterMode } from '../../register/register';\nimport { VimState } from '../../state/vimState';\nimport { ExCommand } from '../../vimscript/exCommand';\nimport { LineRange } from '../../vimscript/lineRange';\nimport { numberParser } from '../../vimscript/parserUtils';\n\nexport interface YankCommandArguments {\n  register?: string;\n  count?: number;\n}\n\nexport class YankCommand extends ExCommand {\n  public static readonly argParser: Parser<YankCommand> = optWhitespace.then(\n    alt(\n      numberParser.map((count) => {\n        return { register: undefined, count };\n      }),\n      seq(any.fallback(undefined), whitespace.then(numberParser).fallback(undefined)).map(\n        ([register, count]) => {\n          return { register, count };\n        }\n      )\n    ).map(\n      ({ register, count }) =>\n        new YankCommand({\n          register,\n          count,\n        })\n    )\n  );\n\n  private readonly arguments: YankCommandArguments;\n  constructor(args: YankCommandArguments) {\n    super();\n    this.arguments = args;\n  }\n\n  private async yank(vimState: VimState, start: Position, end: Position) {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n    if (this.arguments.register) {\n      vimState.recordedState.registerName = this.arguments.register;\n    }\n\n    const cursorPosition = vimState.cursorStopPosition;\n\n    await new YankOperator().run(vimState, start.getLineBegin(), end.getLineEnd());\n\n    // YankOperator moves the cursor - undo that\n    vimState.cursorStopPosition = cursorPosition;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    const linesToYank = this.arguments.count ?? 1;\n    const startPosition = vimState.cursorStartPosition;\n    const endPosition = linesToYank\n      ? startPosition.getDown(linesToYank - 1).getLineEnd()\n      : vimState.cursorStopPosition;\n    await this.yank(vimState, startPosition, endPosition);\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    /**\n     * If a [cnt] and [range] is specified (e.g. :.+2y3), :yank [cnt] is called from\n     * the end of the [range].\n     * Ex. if two lines are VisualLine highlighted, :<,>y3 will :y3\n     * from the end of the selected lines.\n     */\n    const { start, end } = range.resolve(vimState);\n    if (this.arguments.count) {\n      vimState.cursorStartPosition = new Position(end, 0);\n      await this.execute(vimState);\n      return;\n    }\n\n    await this.yank(vimState, new Position(start, 0), new Position(end, 0));\n  }\n}\n","import { VimState } from '../../state/vimState';\nimport { Position } from 'vscode';\nimport { configuration } from '../../configuration/configuration';\n\nexport type Pairing = {\n  match: string;\n  isNextMatchForward: boolean;\n  directionless?: boolean;\n};\n\n/**\n * PairMatcher finds the position matching the given character, respecting nested\n * instances of the pair.\n */\nexport class PairMatcher {\n  static pairings: {\n    [key: string]: Pairing;\n  } = {\n    '(': { match: ')', isNextMatchForward: true },\n    '{': { match: '}', isNextMatchForward: true },\n    '[': { match: ']', isNextMatchForward: true },\n    ')': { match: '(', isNextMatchForward: false },\n    '}': { match: '{', isNextMatchForward: false },\n    ']': { match: '[', isNextMatchForward: false },\n\n    // These characters can't be used for \"%\"-based matching, but are still\n    // useful for text objects.\n    // matchesWithPercentageMotion can be overwritten with configuration.matchpairs\n    '<': { match: '>', isNextMatchForward: true },\n    '>': { match: '<', isNextMatchForward: false },\n    // These are useful for deleting closing and opening quotes, but don't seem to negatively\n    // affect how text objects such as `ci\"` work, which was my worry.\n    '\"': { match: '\"', isNextMatchForward: false, directionless: true },\n    \"'\": { match: \"'\", isNextMatchForward: false, directionless: true },\n    '`': { match: '`', isNextMatchForward: false, directionless: true },\n  };\n\n  private static findPairedChar(\n    position: Position,\n    charToFind: string,\n    charToStack: string,\n    stackHeight: number,\n    isNextMatchForward: boolean,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    let lineNumber = position.line;\n    const linePosition = position.character;\n    const lineCount = vimState.document.lineCount;\n    const cursorChar = vimState.document.lineAt(position).text[position.character];\n    if (\n      allowCurrentPosition &&\n      vimState.cursorStartPosition.isEqual(vimState.cursorStopPosition) &&\n      cursorChar === charToFind\n    ) {\n      return position;\n    }\n\n    while (PairMatcher.keepSearching(lineNumber, lineCount, isNextMatchForward)) {\n      let lineText = vimState.document.lineAt(lineNumber).text.split('');\n      const originalLineLength = lineText.length;\n      if (lineNumber === position.line) {\n        if (isNextMatchForward) {\n          lineText = lineText.slice(linePosition + 1, originalLineLength);\n        } else {\n          lineText = lineText.slice(0, linePosition);\n        }\n      }\n\n      while (true) {\n        if (lineText.length <= 0 || stackHeight <= -1) {\n          break;\n        }\n\n        let nextChar: string | undefined;\n        if (isNextMatchForward) {\n          nextChar = lineText.shift();\n        } else {\n          nextChar = lineText.pop();\n        }\n\n        if (nextChar === charToStack) {\n          stackHeight++;\n        } else if (nextChar === charToFind) {\n          stackHeight--;\n        } else {\n          continue;\n        }\n      }\n\n      if (stackHeight <= -1) {\n        let pairMemberChar: number;\n        if (isNextMatchForward) {\n          pairMemberChar = Math.max(0, originalLineLength - lineText.length - 1);\n        } else {\n          pairMemberChar = lineText.length;\n        }\n        return new Position(lineNumber, pairMemberChar);\n      }\n\n      if (isNextMatchForward) {\n        lineNumber++;\n      } else {\n        lineNumber--;\n      }\n    }\n    return undefined;\n  }\n\n  private static keepSearching(lineNumber: number, lineCount: number, isNextMatchForward: boolean) {\n    if (isNextMatchForward) {\n      return lineNumber <= lineCount - 1;\n    } else {\n      return lineNumber >= 0;\n    }\n  }\n\n  static getPercentPairing(char: string): Pairing | undefined {\n    for (const pairing of configuration.matchpairs.split(',')) {\n      const components = pairing.split(':');\n      if (components.length === 2) {\n        if (components[0] === char) {\n          return {\n            match: components[1],\n            isNextMatchForward: true,\n          };\n        } else if (components[1] === char) {\n          return {\n            match: components[0],\n            isNextMatchForward: false,\n          };\n        }\n      }\n    }\n    return undefined;\n  }\n\n  static nextPairedChar(\n    position: Position,\n    charToMatch: string,\n    vimState: VimState,\n    allowCurrentPosition: boolean\n  ): Position | undefined {\n    /**\n     * We do a fairly basic implementation that only tracks the state of the type of\n     * character you're over and its pair (e.g. \"[\" and \"]\"). This is similar to\n     * what Vim does.\n     *\n     * It can't handle strings very well - something like \"|( ')' )\" where | is the\n     * cursor will cause it to go to the ) in the quotes, even though it should skip over it.\n     *\n     * PRs welcomed! (TODO)\n     * Though ideally VSC implements https://github.com/Microsoft/vscode/issues/7177\n     */\n    const pairing = this.pairings[charToMatch];\n\n    if (pairing === undefined || pairing.directionless) {\n      return undefined;\n    }\n\n    const stackHeight = 0;\n    const charToFind = pairing.match;\n    const charToStack = charToMatch;\n\n    return PairMatcher.findPairedChar(\n      position,\n      charToFind,\n      charToStack,\n      stackHeight,\n      pairing.isNextMatchForward,\n      vimState,\n      allowCurrentPosition\n    );\n  }\n}\n","enum QuoteMatch {\n  Opening,\n  Closing,\n}\n\n/**\n * QuoteMatcher matches quoted strings, respecting escaped quotes (\\\") and friends\n */\nexport class QuoteMatcher {\n  static readonly escapeChar = '\\\\';\n\n  private readonly quoteMap: QuoteMatch[] = [];\n\n  constructor(quote: '\"' | \"'\" | '`', corpus: string) {\n    let openingQuote = true;\n    // Loop over corpus, marking quotes and respecting escape characters.\n    for (let i = 0; i < corpus.length; i++) {\n      if (corpus[i] === QuoteMatcher.escapeChar) {\n        i += 1;\n        continue;\n      }\n      if (corpus[i] === quote) {\n        this.quoteMap[i] = openingQuote ? QuoteMatch.Opening : QuoteMatch.Closing;\n        openingQuote = !openingQuote;\n      }\n    }\n  }\n\n  public surroundingQuotes(cursorIndex: number): [number, number] | undefined {\n    const cursorQuoteType = this.quoteMap[cursorIndex];\n    if (cursorQuoteType === QuoteMatch.Opening) {\n      const closing = this.getNextQuote(cursorIndex);\n      return closing !== undefined ? [cursorIndex, closing] : undefined;\n    } else if (cursorQuoteType === QuoteMatch.Closing) {\n      return [this.getPrevQuote(cursorIndex)!, cursorIndex];\n    } else {\n      const opening = this.getPrevQuote(cursorIndex) ?? this.getNextQuote(cursorIndex);\n\n      if (opening !== undefined) {\n        const closing = this.getNextQuote(opening);\n        if (closing !== undefined) {\n          return [opening, closing];\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private getNextQuote(start: number): number | undefined {\n    for (let i = start + 1; i < this.quoteMap.length; i++) {\n      if (this.quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  private getPrevQuote(start: number): number | undefined {\n    for (let i = start - 1; i >= 0; i--) {\n      if (this.quoteMap[i] !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n}\n","import { TextEditor } from '../../textEditor';\nimport { VimState } from '../../state/vimState';\n\ntype Tag = { name: string; type: 'close' | 'open'; startPos: number; endPos: number };\ntype MatchedTag = {\n  tag: string;\n  openingTagStart: number;\n  openingTagEnd: number;\n  closingTagStart: number;\n  closingTagEnd: number;\n};\n\nexport class TagMatcher {\n  // see regexr.com/3t585\n  static TAG_REGEX = /\\<(\\/)?([^\\>\\<\\s\\/]+)(?:[^\\>\\<]*?)(\\/)?\\>/g;\n  static OPEN_FORWARD_SLASH = 1;\n  static TAG_NAME = 2;\n  static CLOSE_FORWARD_SLASH = 3;\n\n  openStart: number | undefined;\n  openEnd: number | undefined;\n  closeStart: number | undefined;\n  closeEnd: number | undefined;\n\n  constructor(corpus: string, position: number, vimState: VimState) {\n    let match = TagMatcher.TAG_REGEX.exec(corpus);\n    const tags: Tag[] = [];\n\n    // Gather all the existing tags.\n    while (match) {\n      // Node is a self closing tag, skip.\n      if (match[TagMatcher.CLOSE_FORWARD_SLASH]) {\n        match = TagMatcher.TAG_REGEX.exec(corpus);\n        continue;\n      }\n\n      tags.push({\n        name: match[TagMatcher.TAG_NAME],\n        type: match[TagMatcher.OPEN_FORWARD_SLASH] ? 'close' : 'open',\n        startPos: match.index,\n        endPos: TagMatcher.TAG_REGEX.lastIndex,\n      });\n\n      match = TagMatcher.TAG_REGEX.exec(corpus);\n    }\n\n    const stack: Tag[] = [];\n    const matchedTags: MatchedTag[] = [];\n\n    for (const tag of tags) {\n      // We have to push on the stack\n      // if it is an open tag.\n      if (tag.type === 'open') {\n        stack.push(tag);\n      } else {\n        // We have an unmatched closing tag,\n        // so try and match it with any existing tag.\n        for (let i = stack.length - 1; i >= 0; i--) {\n          const openNode = stack[i];\n\n          if (openNode.type === 'open' && openNode.name === tag.name) {\n            // A matching tag was found, ignore\n            // any tags that were in between.\n            matchedTags.push({\n              tag: openNode.name,\n              openingTagStart: openNode.startPos,\n              openingTagEnd: openNode.endPos,\n              closingTagStart: tag.startPos,\n              closingTagEnd: tag.endPos,\n            });\n\n            stack.splice(i);\n            break;\n          }\n        }\n      }\n    }\n\n    const firstNonWhitespacePositionOnLine = TextEditor.getFirstNonWhitespaceCharOnLine(\n      vimState.document,\n      vimState.cursorStartPosition.line\n    );\n\n    /**\n     * This adjustment fixes the following situation:\n     * <foo>\n     * |  <bar>\n     *    test\n     *    </bar>\n     * </foo>\n     * Now in tag matching situations, the tag opening on the cursor line is considered as well\n     * (if there is only whitespace before the tag and the cursor is standing on these whitespaces)\n     */\n    const startPos =\n      vimState.cursorStartPosition.character < firstNonWhitespacePositionOnLine.character\n        ? firstNonWhitespacePositionOnLine\n        : vimState.cursorStartPosition;\n\n    const startPosOffset = vimState.document.offsetAt(startPos);\n    const endPosOffset = position;\n    const tagsSurrounding = matchedTags.filter((n) => {\n      return startPosOffset >= n.openingTagStart && endPosOffset < n.closingTagEnd;\n    });\n\n    if (!tagsSurrounding.length) {\n      return;\n    }\n\n    const nodeSurrounding = this.determineRelevantTag(\n      tagsSurrounding,\n      startPosOffset,\n      vimState.cursorStartPosition.compareTo(vimState.cursorStopPosition) !== 0\n    );\n\n    if (!nodeSurrounding) {\n      return;\n    }\n\n    this.openStart = nodeSurrounding.openingTagStart;\n    this.closeEnd = nodeSurrounding.closingTagEnd;\n    // if the inner tag content is already selected, expand to enclose tags with 'it' as in vim\n    if (\n      startPosOffset === nodeSurrounding.openingTagEnd &&\n      endPosOffset + 1 === nodeSurrounding.closingTagStart\n    ) {\n      this.openEnd = this.openStart;\n      this.closeStart = this.closeEnd;\n    } else {\n      this.openEnd = nodeSurrounding.openingTagEnd;\n      this.closeStart = nodeSurrounding.closingTagStart;\n    }\n  }\n\n  /**\n   * Most of the time the relevant tag is the innermost tag, but when Visual mode is active,\n   * the rules are different.\n   * When the cursorStart is standing on the < character of the inner tag, with \"at\" we must\n   * jump to the outer tag.\n   */\n  determineRelevantTag(\n    tagsSurrounding: MatchedTag[],\n    adjustedStartPosOffset: number,\n    selectionActive: boolean\n  ): MatchedTag | undefined {\n    const relevantTag = tagsSurrounding[0];\n\n    if (selectionActive && adjustedStartPosOffset === relevantTag.openingTagStart) {\n      // we adjusted so we have to return the outer tag\n      return tagsSurrounding[1];\n    } else {\n      return relevantTag;\n    }\n  }\n\n  findOpening(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.openStart;\n    }\n    return this.openEnd;\n  }\n\n  findClosing(inclusive: boolean): number | undefined {\n    if (inclusive) {\n      return this.closeEnd;\n    }\n    return this.closeStart;\n  }\n}\n","import { Position, Selection, TextEditor } from 'vscode';\n\nexport class Cursor {\n  public readonly start: Position;\n  public readonly stop: Position;\n\n  constructor(start: Position, stop: Position) {\n    this.start = start;\n    this.stop = stop;\n  }\n\n  public isValid(textEditor: TextEditor) {\n    return this.start.isValid(textEditor) && this.stop.isValid(textEditor);\n  }\n\n  /**\n   * Create a Cursor from a VSCode selection.\n   */\n  public static FromVSCodeSelection(sel: Selection): Cursor {\n    return new Cursor(sel.start, sel.end);\n  }\n\n  public equals(other: Cursor): boolean {\n    return this.start.isEqual(other.start) && this.stop.isEqual(other.stop);\n  }\n\n  /**\n   * Returns a new Cursor which is the same as this Cursor, but with the provided stop value.\n   */\n  public withNewStop(stop: Position): Cursor {\n    return new Cursor(this.start, stop);\n  }\n\n  /**\n   * Returns a new Cursor which is the same as this Cursor, but with the provided start value.\n   */\n  public withNewStart(start: Position): Cursor {\n    return new Cursor(start, this.stop);\n  }\n\n  public toString(): string {\n    return `[${this.start.toString()} | ${this.stop.toString()}]`;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { configuration } from './../../configuration/configuration';\nimport { TextEditor } from './../../textEditor';\nimport { clamp } from '../../util/util';\nimport { getSentenceBegin, getSentenceEnd } from '../../textobject/sentence';\nimport {\n  WordType,\n  nextWordEnd,\n  prevWordEnd,\n  prevWordStart,\n  nextWordStart,\n} from '../../textobject/word';\nimport { Position } from 'vscode';\n\n/**\n * Controls how a PositionDiff affects the Position it's applied to.\n */\nenum PositionDiffType {\n  /** Sets both the line and character exactly */\n  ExactPosition,\n  /** Offsets both the line and character */\n  Offset,\n  /** Offsets the line and sets the column exactly */\n  ExactCharacter,\n  /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n  ObeyStartOfLine,\n  /** Brings the Position to the end of the line */\n  EndOfLine,\n}\n\n/**\n * Represents a difference between two Positions.\n * Add it to a Position to get another Position.\n */\nexport class PositionDiff {\n  public readonly line: number;\n  public readonly character: number;\n  public readonly type: PositionDiffType;\n\n  private constructor(type: PositionDiffType, line: number, character: number) {\n    this.type = type;\n    this.line = line;\n    this.character = character;\n  }\n\n  /** Has no effect */\n  public static identity(): PositionDiff {\n    return PositionDiff.offset({ line: 0, character: 0 });\n  }\n\n  /** Offsets both the Position's line and character */\n  public static offset({ line = 0, character = 0 }): PositionDiff {\n    return new PositionDiff(PositionDiffType.Offset, line, character);\n  }\n\n  /** Sets the Position's line and character exactly */\n  public static exactPosition(position: Position): PositionDiff {\n    return new PositionDiff(PositionDiffType.ExactPosition, position.line, position.character);\n  }\n\n  /** Brings the Position to the beginning of the line if `vim.startofline` is true */\n  public static startOfLine(): PositionDiff {\n    return new PositionDiff(PositionDiffType.ObeyStartOfLine, 0, 0);\n  }\n\n  /** Brings the Position to the end of the line */\n  public static endOfLine(): PositionDiff {\n    return new PositionDiff(PositionDiffType.EndOfLine, 0, 0);\n  }\n\n  /** Offsets the Position's line and sets its character exactly */\n  public static exactCharacter({\n    lineOffset,\n    character,\n  }: {\n    lineOffset?: number;\n    character: number;\n  }): PositionDiff {\n    return new PositionDiff(PositionDiffType.ExactCharacter, lineOffset ?? 0, character);\n  }\n\n  public toString(): string {\n    switch (this.type) {\n      case PositionDiffType.Offset:\n        return `[ Diff: Offset ${this.line} ${this.character} ]`;\n      case PositionDiffType.ExactCharacter:\n        return `[ Diff: ExactCharacter ${this.line} ${this.character} ]`;\n      case PositionDiffType.ExactPosition:\n        return `[ Diff: ExactPosition ${this.line} ${this.character} ]`;\n      case PositionDiffType.ObeyStartOfLine:\n        return `[ Diff: ObeyStartOfLine ${this.line} ]`;\n      case PositionDiffType.EndOfLine:\n        return `[ Diff: EndOfLine ${this.line} ]`;\n      default:\n        const guard: never = this.type;\n        throw new Error(`Unknown PositionDiffType: ${this.type}`);\n    }\n  }\n}\n\n/**\n * @returns the Position of the 2 provided which comes earlier in the document.\n */\nexport function earlierOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p1 : p2;\n}\n\n/**\n * @returns the Position of the 2 provided which comes later in the document.\n */\nexport function laterOf(p1: Position, p2: Position): Position {\n  return p1.isBefore(p2) ? p2 : p1;\n}\n\n/**\n * @returns the given Positions in the order they appear in the document.\n */\nexport function sorted(p1: Position, p2: Position): [Position, Position] {\n  return p1.isBefore(p2) ? [p1, p2] : [p2, p1];\n}\n\ndeclare module 'vscode' {\n  interface Position {\n    toString(): string;\n\n    add(document: vscode.TextDocument, diff: PositionDiff, boundsCheck?: boolean): Position;\n    subtract(other: Position): PositionDiff;\n\n    /**\n     * @returns a new Position with the same line and the given character.\n     * Does bounds-checking to make sure the result is valid.\n     * @deprecated use `Position.with` instead\n     */\n    withColumn(column: number): Position;\n\n    /**\n     * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n     */\n    getLeft(count?: number): Position;\n    /**\n     * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n     */\n    getRight(count?: number): Position;\n    /**\n     * @returns the Position `count` lines down from this Position\n     */\n    getDown(count?: number): Position;\n    /**\n     * @returns the Position `count` lines up from this Position\n     */\n    getUp(count?: number): Position;\n\n    getLeftThroughLineBreaks(includeEol?: boolean): Position;\n    getRightThroughLineBreaks(includeEol?: boolean): Position;\n    getOffsetThroughLineBreaks(offset: number): Position;\n\n    /**\n     * @returns the start of the first word to the left of the current position, like `b`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the start of a word\n     */\n    prevWordStart(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    /**\n     * @returns the start of the first word to the right of the current position, like `w`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the start of a word\n     */\n    nextWordStart(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    /**\n     * @returns the end of the first word to the left of the current position, like `ge`\n     *\n     * @param wordType how word boundaries are determined\n     */\n    prevWordEnd(document: vscode.TextDocument, args?: { wordType?: WordType }): Position;\n\n    /**\n     * @returns the end of the first word to the right of the current position, like `e`\n     *\n     * @param wordType how word boundaries are determined\n     * @param inclusive if true, returns the current position if it's at the end of a word\n     */\n    nextWordEnd(\n      document: vscode.TextDocument,\n      args?: { wordType?: WordType; inclusive?: boolean }\n    ): Position;\n\n    getSentenceBegin(args: { forward: boolean }): Position;\n    getSentenceEnd(): Position;\n\n    getLineBegin(): Position;\n\n    /**\n     * @returns the beginning of the line, excluding preceeding whitespace.\n     * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n     */\n    getLineBeginRespectingIndent(document: vscode.TextDocument): Position;\n\n    /**\n     * @returns a new Position at the end of this position's line.\n     */\n    getLineEnd(): Position;\n\n    /**\n     * @returns a new Position at the end of this Position's line, including the invisible newline character.\n     */\n    getLineEndIncludingEOL(): Position;\n\n    /**\n     * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n     */\n    getLeftIfEOL(): Position;\n\n    /**\n     * @returns the position that the cursor would be at if you pasted *text* at the current position.\n     */\n    advancePositionByText(text: string): Position;\n\n    /**\n     * Is this position at the beginning of the line?\n     */\n    isLineBeginning(): boolean;\n\n    /**\n     * Is this position at the end of the line?\n     */\n    isLineEnd(): boolean;\n\n    isFirstWordOfLine(document: vscode.TextDocument): boolean;\n\n    isAtDocumentBegin(): boolean;\n\n    isAtDocumentEnd(): boolean;\n\n    /**\n     * Returns whether the current position is in the leading whitespace of a line\n     */\n    isInLeadingWhitespace(document: vscode.TextDocument): boolean;\n\n    /**\n     * If `vim.startofline` is set, get first non-blank character's position.\n     */\n    obeyStartOfLine(document: vscode.TextDocument): Position;\n\n    isValid(textEditor: vscode.TextEditor): boolean;\n  }\n}\n\nPosition.prototype.toString = function (this: Position) {\n  return `[${this.line}, ${this.character}]`;\n};\n\nPosition.prototype.add = function (\n  this: Position,\n  document: vscode.TextDocument,\n  diff: PositionDiff,\n  boundsCheck = true\n): Position {\n  if (diff.type === PositionDiffType.ExactPosition) {\n    return new Position(diff.line, diff.character);\n  }\n\n  const resultLine = clamp(this.line + diff.line, 0, document.lineCount - 1);\n\n  let resultChar: number;\n  if (diff.type === PositionDiffType.Offset) {\n    resultChar = this.character + diff.character;\n  } else if (diff.type === PositionDiffType.ExactCharacter) {\n    resultChar = diff.character;\n  } else if (diff.type === PositionDiffType.ObeyStartOfLine) {\n    resultChar = this.obeyStartOfLine(document).character;\n  } else if (diff.type === PositionDiffType.EndOfLine) {\n    resultChar = this.getLineEnd().character;\n  } else {\n    throw new Error(`Unknown PositionDiffType: ${diff.type}`);\n  }\n\n  const pos = new Position(resultLine, Math.max(resultChar, 0));\n  return boundsCheck ? document.validatePosition(pos) : pos;\n};\n\nPosition.prototype.subtract = function (this: Position, other: Position): PositionDiff {\n  return PositionDiff.offset({\n    line: this.line - other.line,\n    character: this.character - other.character,\n  });\n};\n\n/**\n * @returns a new Position with the same line and the given character.\n * Does bounds-checking to make sure the result is valid.\n */\nPosition.prototype.withColumn = function (this: Position, column: number): Position {\n  column = clamp(column, 0, TextEditor.getLineLength(this.line));\n  return new Position(this.line, column);\n};\n\n/**\n * @returns the Position `count` characters to the left of this Position. Does not go over line breaks.\n */\nPosition.prototype.getLeft = function (this: Position, count = 1): Position {\n  return new Position(this.line, Math.max(this.character - count, 0));\n};\n\n/**\n * @returns the Position `count` characters to the right of this Position. Does not go over line breaks.\n */\nPosition.prototype.getRight = function (this: Position, count = 1): Position {\n  return new Position(\n    this.line,\n    Math.min(this.character + count, TextEditor.getLineLength(this.line))\n  );\n};\n\n/**\n * @returns the Position `count` lines down from this Position\n */\nPosition.prototype.getDown = function (this: Position, count = 1): Position {\n  if (vscode.window.activeTextEditor) {\n    const line = Math.min(this.line + count, TextEditor.getLineCount() - 1);\n    return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n  } else {\n    return this.translate({ lineDelta: count });\n  }\n};\n\n/**\n * @returns the Position `count` lines up from this Position\n */\nPosition.prototype.getUp = function (this: Position, count = 1): Position {\n  const line = Math.max(this.line - count, 0);\n  return new Position(line, Math.min(this.character, TextEditor.getLineLength(line)));\n};\n\n/**\n * Same as getLeft, but goes up to the previous line on line breaks.\n * Equivalent to left arrow (in a non-vim editor!)\n */\nPosition.prototype.getLeftThroughLineBreaks = function (\n  this: Position,\n  includeEol = true\n): Position {\n  if (!this.isLineBeginning()) {\n    return this.getLeft();\n  }\n\n  // First char on first line, can not go left any more\n  if (this.line === 0) {\n    return this;\n  }\n\n  if (includeEol) {\n    return this.getUp().getLineEnd();\n  } else {\n    return this.getUp().getLineEnd().getLeft();\n  }\n};\n\nPosition.prototype.getRightThroughLineBreaks = function (\n  this: Position,\n  includeEol = false\n): Position {\n  if (this.isAtDocumentEnd()) {\n    return this;\n  }\n\n  if (this.line < TextEditor.getLineCount() - 1) {\n    const pos = includeEol ? this : this.getRight();\n    if (pos.isLineEnd()) {\n      return this.with({ character: 0 }).getDown();\n    }\n  } else if (!includeEol && this.character === TextEditor.getLineLength(this.line) - 1) {\n    // Last character of document, don't go on to non-existent EOL\n    return this;\n  }\n\n  return this.getRight();\n};\n\nPosition.prototype.getOffsetThroughLineBreaks = function (\n  this: Position,\n  offset: number\n): Position {\n  let pos = new Position(this.line, this.character);\n\n  if (offset < 0) {\n    for (let i = 0; i < -offset; i++) {\n      pos = pos.getLeftThroughLineBreaks();\n    }\n  } else {\n    for (let i = 0; i < offset; i++) {\n      pos = pos.getRightThroughLineBreaks();\n    }\n  }\n\n  return pos;\n};\n\nPosition.prototype.prevWordStart = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return prevWordStart(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.nextWordStart = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return nextWordStart(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.prevWordEnd = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType }\n): Position {\n  return prevWordEnd(document, this, args?.wordType ?? WordType.Normal);\n};\n\nPosition.prototype.nextWordEnd = function (\n  this: Position,\n  document: vscode.TextDocument,\n  args?: { wordType?: WordType; inclusive?: boolean }\n): Position {\n  return nextWordEnd(document, this, args?.wordType ?? WordType.Normal, args?.inclusive ?? false);\n};\n\nPosition.prototype.getSentenceBegin = function (\n  this: Position,\n  args: { forward: boolean }\n): Position {\n  return getSentenceBegin(this, args);\n};\n\nPosition.prototype.getSentenceEnd = function (this: Position): Position {\n  return getSentenceEnd(this);\n};\n\n/**\n * @returns a new Position at the beginning of the current line.\n */\nPosition.prototype.getLineBegin = function (this: Position): Position {\n  return new Position(this.line, 0);\n};\n\n/**\n * @returns the beginning of the line, excluding preceeding whitespace.\n * This respects the `autoindent` setting, and returns `getLineBegin()` if auto-indent is disabled.\n */\nPosition.prototype.getLineBeginRespectingIndent = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  if (!configuration.autoindent) {\n    return this.getLineBegin();\n  }\n  return TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line);\n};\n\n/**\n * @returns a new Position at the end of this position's line.\n */\nPosition.prototype.getLineEnd = function (this: Position): Position {\n  return new Position(this.line, TextEditor.getLineLength(this.line));\n};\n\n/**\n * @returns a new Position at the end of this Position's line, including the invisible newline character.\n */\nPosition.prototype.getLineEndIncludingEOL = function (this: Position): Position {\n  // TODO: isn't this one too far?\n  return new Position(this.line, TextEditor.getLineLength(this.line) + 1);\n};\n\n/**\n * @returns a new Position one to the left if this Position is on the EOL. Otherwise, returns this position.\n */\nPosition.prototype.getLeftIfEOL = function (this: Position): Position {\n  return this.character === TextEditor.getLineLength(this.line) ? this.getLeft() : this;\n};\n\n/**\n * @returns the position that the cursor would be at if you pasted *text* at the current position.\n */\nPosition.prototype.advancePositionByText = function (this: Position, text: string): Position {\n  const newlines: number[] = [];\n  let idx = text.indexOf('\\n', 0);\n  while (idx >= 0) {\n    newlines.push(idx);\n    idx = text.indexOf('\\n', idx + 1);\n  }\n\n  if (newlines.length === 0) {\n    return new Position(this.line, this.character + text.length);\n  } else {\n    return new Position(\n      this.line + newlines.length,\n      text.length - (newlines[newlines.length - 1] + 1)\n    );\n  }\n};\n\n/**\n * Is this position at the beginning of the line?\n */\nPosition.prototype.isLineBeginning = function (this: Position): boolean {\n  return this.character === 0;\n};\n\n/**\n * Is this position at the end of the line?\n */\nPosition.prototype.isLineEnd = function (this: Position): boolean {\n  return this.character >= TextEditor.getLineLength(this.line);\n};\n\nPosition.prototype.isFirstWordOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return (\n    TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line).character === this.character\n  );\n};\n\nPosition.prototype.isAtDocumentBegin = function (this: Position): boolean {\n  return this.line === 0 && this.isLineBeginning();\n};\n\nPosition.prototype.isAtDocumentEnd = function (this: Position): boolean {\n  return this.line === TextEditor.getLineCount() - 1 && this.isLineEnd();\n};\n\n/**\n * Returns whether the current position is in the leading whitespace of a line\n * @param allowEmpty : Use true if \"\" is valid\n */\nPosition.prototype.isInLeadingWhitespace = function (\n  this: Position,\n  document: vscode.TextDocument\n): boolean {\n  return /^\\s+$/.test(document.getText(new vscode.Range(this.getLineBegin(), this)));\n};\n\n/**\n * If `vim.startofline` is set, get first non-blank character's position.\n */\nPosition.prototype.obeyStartOfLine = function (\n  this: Position,\n  document: vscode.TextDocument\n): Position {\n  return configuration.startofline\n    ? TextEditor.getFirstNonWhitespaceCharOnLine(document, this.line)\n    : this;\n};\n\nPosition.prototype.isValid = function (this: Position, textEditor: vscode.TextEditor): boolean {\n  try {\n    // line\n    // TODO: this `|| 1` seems dubious...\n    const lineCount = TextEditor.getLineCount(textEditor) || 1;\n    if (this.line >= lineCount) {\n      return false;\n    }\n\n    // char\n    const charCount = TextEditor.getLineLength(this.line);\n    if (this.character > charCount + 1) {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n","/**\n *      aaaa0x111bbbbbb\n *      |-------------| => NumericString\n *      |--|            => prefix\n *          |---|       => core\n *               |----| => suffix\n *          ||          => numPrefix\n *            |-|       => num\n *\n * Greedy matching, leftmost match wins.\n * If multiple matches begin at the same position, the match with the biggest\n *   span wins.\n * If multiple matches have the same begin position and span (This usually\n *   happens on octal and decimal), following priority sequence is used:\n *   (decimal => octal => hexadecimal)\n *\n * Example:\n *                    |  core  |     What we got      |     Rather than     |\n *  ------------------|--------|----------------------|---------------------|\n *  Leftmost rule:    | 010xff |    (010)xff [octal]  |    01(0xff) [hex]   |\n *  Biggest span rule:| 0xff   |     (0xff) [hex]     |   (0)xff [decimal]  |\n *  Priority rule:    | 00007  |    (00007) [octal]   |  (00007) [decimal]  |\n *\n * Side Effect:\n *  -0xf  Will be parsed as (-0)xf rather than -(0xf), current workaround is\n *          capturing '-' in hexadecimal regex but not consider '-' as a part\n *          of the number. This is achieved by using `negative` boolean value\n *          in `NumericString`.\n */\nexport enum NumericStringRadix {\n  Oct = 8,\n  Dec = 10,\n  Hex = 16,\n}\n\nexport class NumericString {\n  radix: NumericStringRadix;\n  value: number;\n  numLength: number;\n  prefix: string;\n  suffix: string;\n  // If a negative sign should be manually added when converting to string.\n  negative: boolean;\n  isCapital: boolean;\n\n  // Map radix to number prefix\n  private static numPrefix = {\n    [NumericStringRadix.Oct]: '0',\n    [NumericStringRadix.Dec]: '',\n    [NumericStringRadix.Hex]: '0x',\n  };\n\n  // Keep octal at the top of decimal to avoid regarding 0000007 as decimal.\n  // '000009' matches decimal.\n  // '000007' matches octal.\n  // '-0xf' matches hex rather than decimal '-0'\n  private static matchings: Array<{ regex: RegExp; radix: NumericStringRadix }> = [\n    { regex: /(-)?0[0-7]+/, radix: NumericStringRadix.Oct },\n    { regex: /(-)?\\d+/, radix: NumericStringRadix.Dec },\n    { regex: /(-)?0x[\\da-fA-F]+/, radix: NumericStringRadix.Hex },\n  ];\n\n  // Return parse result and offset of suffix\n  public static parse(\n    input: string,\n    targetRadix?: NumericStringRadix\n  ): { num: NumericString; suffixOffset: number } | undefined {\n    const filteredMatchings =\n      targetRadix !== undefined\n        ? NumericString.matchings.filter(matching => matching.radix === targetRadix)\n        : NumericString.matchings;\n\n    // Find core numeric part of input\n    let coreBegin = -1;\n    let coreLength = -1;\n    let coreRadix = -1;\n    let coreSign = false;\n    for (const { regex, radix } of filteredMatchings) {\n      const match = regex.exec(input);\n      if (match != null) {\n        // Get the leftmost and largest match\n        if (\n          coreRadix < 0 ||\n          match.index < coreBegin ||\n          (match.index === coreBegin && match[0].length > coreLength)\n        ) {\n          coreBegin = match.index;\n          coreLength = match[0].length;\n          coreRadix = radix;\n          coreSign = match[1] === '-';\n        }\n      }\n    }\n\n    if (coreRadix < 0) {\n      return undefined;\n    }\n\n    const coreEnd = coreBegin + coreLength;\n\n    const prefix = input.slice(0, coreBegin);\n    const core = input.slice(coreBegin, coreEnd);\n    const suffix = input.slice(coreEnd, input.length);\n\n    let value = parseInt(core, coreRadix);\n\n    // 0x00ff:  numLength = 4\n    // 077:     numLength = 2\n    // -0999:   numLength = 3\n    // The numLength is only useful for parsing non-decimal. Decimal with\n    // leading zero will be trimmed in `toString()`. If value is negative,\n    // remove the width of negative sign.\n    const numLength = coreLength - NumericString.numPrefix[coreRadix].length - (coreSign ? 1 : 0);\n\n    // According to original vim's behavior, for hex and octal, the leading\n    // '-' *should* be captured and preserved but *should not* be regarded as\n    // part of number, which means with <C-a>, `-0xf` turns into `-0x10`. So\n    // for hex and octal, we make the value absolute and set the negative\n    // sign flag.\n    let negative = false;\n    if (coreRadix !== 10 && coreSign) {\n      value = -value;\n      negative = true;\n    }\n\n    let isCapital = false;\n    if (coreRadix === 16) {\n      for (const c of Array.from(input).reverse()) {\n        if ('A' <= c && c <= 'F') {\n          isCapital = true;\n          break;\n        } else if ('a' <= c && c <= 'f') {\n          isCapital = false;\n          break;\n        }\n      }\n    }\n\n    return {\n      num: new NumericString(value, coreRadix, numLength, prefix, suffix, negative, isCapital),\n      suffixOffset: coreEnd,\n    };\n  }\n\n  private constructor(\n    value: number,\n    radix: NumericStringRadix,\n    numLength: number,\n    prefix: string,\n    suffix: string,\n    negative: boolean,\n    isCapital: boolean\n  ) {\n    this.value = value;\n    this.radix = radix;\n    this.numLength = numLength;\n    this.prefix = prefix;\n    this.suffix = suffix;\n    this.negative = negative;\n    this.isCapital = isCapital;\n  }\n\n  public toString(): string {\n    // For decreased octal and hexadecimal\n    if (this.radix !== 10) {\n      const max = 0xffffffff;\n      while (this.value < 0) {\n        this.value = max + this.value + 1;\n      }\n    }\n\n    // Gen num part\n    const absValue = Math.abs(this.value);\n    let num = absValue.toString(this.radix);\n    if (this.isCapital) {\n      num = num.toUpperCase();\n    }\n    // numLength of decimal *should not* be preserved.\n    if (this.radix !== 10) {\n      const diff = this.numLength - num.length;\n      if (diff > 0) {\n        // Preserve num length if it's narrower.\n        num = '0'.repeat(diff) + num;\n      }\n    }\n\n    const sign = this.negative || this.value < 0 ? '-' : '';\n    const core = sign + NumericString.numPrefix[this.radix] + num;\n    return this.prefix + core + this.suffix;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { TextEditor } from './../textEditor';\nimport { VimState } from '../state/vimState';\nimport { Position } from 'vscode';\n\n/**\n * Return open text documents, with a given file at the top of the list.\n * @param startingFileName File that will be first in the array, typically current file\n */\nconst documentsStartingWith = (startingFileName: string) => {\n  return [...vscode.workspace.textDocuments].sort((a, b) => {\n    if (a.fileName === startingFileName) {\n      return -1;\n    } else if (b.fileName === startingFileName) {\n      return 1;\n    }\n    return 0;\n  });\n};\n\n/**\n * Get lines, with leading tabs or whitespace stripped.\n * @param document Document to get lines from.\n * @param lineToStartScanFrom Where to start looking for matches first. Closest matches are sorted first.\n * @param scanAboveFirst Whether to start scan above or below cursor. Other direction is scanned last.\n * @returns\n */\nconst linesWithoutIndentation = (\n  document: vscode.TextDocument,\n  lineToStartScanFrom: number,\n  scanAboveFirst: boolean\n): Array<{ sortPriority: number; text: string }> => {\n  const distanceFromStartLine = (line: number) => {\n    let sortPriority = scanAboveFirst ? lineToStartScanFrom - line : line - lineToStartScanFrom;\n    if (sortPriority < 0) {\n      // We prioritized any items in the main direction searched,\n      // but now find closest items in opposite direction.\n      sortPriority = lineToStartScanFrom + Math.abs(sortPriority);\n    }\n\n    return sortPriority;\n  };\n\n  return document\n    .getText()\n    .split('\\n')\n    .map((text, line) => ({\n      sortPriority: distanceFromStartLine(line),\n      text: text.replace(/^[ \\t]*/, ''),\n    }))\n    .sort((a, b) => (a.sortPriority > b.sortPriority ? 1 : -1));\n};\n\n/**\n * Get all completions that match given text within open documents.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param text Text to partially match. Indentation is stripped.\n * @param currentFileName Current file, which is prioritized in sorting.\n * @param currentPosition Current position, which is prioritized when sorting for current file.\n */\nconst getCompletionsForText = (\n  text: string,\n  currentFileName: string,\n  currentPosition: Position\n): string[] | null => {\n  const matchedLines: string[] = [];\n\n  for (const document of documentsStartingWith(currentFileName)) {\n    let lineToStartScanFrom = 0;\n    let scanAboveFirst = false;\n\n    if (document.fileName === currentFileName) {\n      lineToStartScanFrom = currentPosition.line;\n      scanAboveFirst = true;\n    }\n\n    for (const line of linesWithoutIndentation(document, lineToStartScanFrom, scanAboveFirst)) {\n      if (\n        !matchedLines.includes(line.text) &&\n        line.text &&\n        line.text.startsWith(text) &&\n        line.text !== text\n      ) {\n        matchedLines.push(line.text);\n      }\n    }\n  }\n\n  return matchedLines;\n};\n\n/**\n * Get all completions that match given text within open documents.\n * Results are sorted in a few ways:\n * 1) The current document is prioritized over other open documents.\n * 2) For the current document, lines above the current cursor are always prioritized over lines below it.\n * 3) For the current document, lines are also prioritized based on distance from cursor.\n * 4) For other documents, lines are prioritized based on distance from the top.\n * @example\n * a1\n * a2\n * a| // <--- Perform line completion here\n * a3\n * a4\n * // Returns: ['a2', 'a1', 'a3', 'a4']\n * @param position Position to start scan from\n * @param document Document to start scanning from, starting at the position (other open documents are scanned from top)\n */\nexport const getCompletionsForCurrentLine = (\n  position: Position,\n  document: vscode.TextDocument\n): string[] | null => {\n  const currentLineText = document.getText(\n    new vscode.Range(TextEditor.getFirstNonWhitespaceCharOnLine(document, position.line), position)\n  );\n\n  return getCompletionsForText(currentLineText, document.fileName, position);\n};\n\nexport const lineCompletionProvider = {\n  /**\n   * Get all completions that match given text within open documents.\n   * Results are sorted by priority.\n   * @see getCompletionsForCurrentLine\n   *\n   * Any trailing characters are stripped. Trailing characters are often\n   * from auto-close, such as when importing in JavaScript ES6 and typing a\n   * curly brace. So the trailing characters are removed on purpose.\n   *\n   * Modifies vimState, adding transformations that replaces the\n   * current line's text with the chosen completion, with proper indentation.\n   *\n   * Here we use Quick Pick, instead of registerCompletionItemProvider\n   * Originally I looked at using a standard completion dropdown using that method,\n   * but it doesn't allow you to limit completions, and it became overwhelming\n   * when e.g. trying to do a line completion when the cursor is positioned after\n   * a space character (such that it shows almost any symbol in the list).\n   * Quick Pick also allows for searching, which is a nice bonus.\n   */\n  showLineCompletionsQuickPick: async (position: Position, vimState: VimState): Promise<void> => {\n    const completions = getCompletionsForCurrentLine(position, vimState.document);\n\n    if (!completions) {\n      return;\n    }\n\n    const selectedCompletion = await vscode.window.showQuickPick(completions);\n\n    if (!selectedCompletion) {\n      return;\n    }\n\n    vimState.recordedState.transformer.delete(\n      new vscode.Range(\n        TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, position.line),\n        position.getLineEnd()\n      )\n    );\n\n    vimState.recordedState.transformer.addTransformation({\n      type: 'insertTextVSCode',\n      text: selectedCompletion,\n    });\n  },\n};\n","import * as vscode from 'vscode';\nimport { Globals } from '../globals';\nimport { Notation } from './notation';\nimport { ValidatorResults } from './iconfigurationValidator';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { configurationValidator } from './configurationValidator';\nimport { decoration } from './decoration';\nimport * as process from 'process';\n\nimport {\n  IConfiguration,\n  IKeyRemapping,\n  IModeSpecificStrings,\n  IAutoSwitchInputMethod,\n  IDebugConfiguration,\n  IHighlightedYankConfiguration,\n  ICamelCaseMotionConfiguration,\n  ITargetsConfiguration,\n} from './iconfiguration';\n\nimport * as packagejson from '../../package.json';\nimport { SUPPORT_VIMRC } from 'platform/constants';\n\n// https://stackovrflow.com/questions/51465182/how-to-remove-index-signature-using-mapped-types/51956054#51956054\ntype RemoveIndex<T> = {\n  [P in keyof T as string extends P ? never : number extends P ? never : P]: T[P];\n};\n\nexport const extensionVersion = packagejson.version;\n\n/**\n * Most options supported by Vim have a short alias. They are provided here.\n * Please keep this list up to date and sorted alphabetically.\n */\nexport const optionAliases: ReadonlyMap<string, string> = new Map<string, string>([\n  ['ai', 'autoindent'],\n  ['et', 'expandtab'],\n  ['gd', 'gdefault'],\n  ['hi', 'history'],\n  ['hls', 'hlsearch'],\n  ['ic', 'ignorecase'],\n  ['icm', 'inccommand'],\n  ['is', 'incsearch'],\n  ['isk', 'iskeyword'],\n  ['js', 'joinspaces'],\n  ['mmd', 'maxmapdepth'],\n  ['mps', 'matchpairs'],\n  ['nu', 'number'],\n  ['rnu', 'relativenumber'],\n  ['sc', 'showcmd'],\n  ['scr', 'scroll'],\n  ['so', 'scrolloff'],\n  ['scs', 'smartcase'],\n  ['smd', 'showmode'],\n  ['sol', 'startofline'],\n  ['to', 'timeout'],\n  ['ts', 'tabstop'],\n  ['tw', 'textwidth'],\n  ['ws', 'wrapscan'],\n  ['ww', 'whichwrap'],\n]);\n\ntype OptionValue = number | string | boolean;\n\ninterface VSCodeKeybinding {\n  key: string;\n  mac?: string;\n  linux?: string;\n  command: string;\n  when: string;\n}\n\ninterface IHandleKeys {\n  [key: string]: boolean;\n}\n\ninterface IKeyBinding {\n  key: string;\n  command: string;\n}\n\n/**\n * Every Vim option we support should\n * 1. Be added to contribution section of `package.json`.\n * 2. Named as `vim.{optionName}`, `optionName` is the name we use in Vim.\n * 3. Define a public property in `Configuration` with the same name and a default value.\n *    Or define a private property and define customized Getter/Setter accessors for it.\n *    Always remember to decorate Getter accessor as @enumerable()\n * 4. If user doesn't set the option explicitly\n *    a. we don't have a similar setting in Code, initialize the option as default value.\n *    b. we have a similar setting in Code, use Code's setting.\n *\n * Vim option override sequence.\n * 1. `:set {option}` on the fly\n * 2. `vim.{option}`\n * 3. VS Code configuration\n * 4. VSCodeVim configuration default values\n *\n */\nclass Configuration implements IConfiguration {\n  private readonly leaderDefault = '\\\\';\n  private readonly cursorTypeMap = {\n    line: vscode.TextEditorCursorStyle.Line,\n    block: vscode.TextEditorCursorStyle.Block,\n    underline: vscode.TextEditorCursorStyle.Underline,\n    'line-thin': vscode.TextEditorCursorStyle.LineThin,\n    'block-outline': vscode.TextEditorCursorStyle.BlockOutline,\n    'underline-thin': vscode.TextEditorCursorStyle.UnderlineThin,\n  };\n\n  public async load(): Promise<ValidatorResults> {\n    const vimConfigs: { [key: string]: any } = Globals.isTesting\n      ? Globals.mockConfiguration\n      : this.getConfiguration('vim');\n\n    // tslint:disable-next-line: forin\n    for (const option in this) {\n      let val = vimConfigs[option];\n      if (val !== null && val !== undefined) {\n        if (val.constructor.name === Object.name) {\n          val = Configuration.unproxify(val);\n        }\n        this[option] = val;\n      }\n    }\n\n    if (SUPPORT_VIMRC && this.vimrc.enable) {\n      await import('./vimrc').then((vimrcModel) => {\n        return vimrcModel.vimrc.load(this);\n      });\n    }\n\n    this.leader = Notation.NormalizeKey(this.leader, this.leaderDefault);\n\n    this.clearKeyBindingsMaps();\n\n    const validatorResults = await configurationValidator.validate(configuration);\n\n    // read package.json for bound keys\n    // enable/disable certain key combinations\n    this.boundKeyCombinations = [];\n    for (const keybinding of packagejson.contributes.keybindings) {\n      if (keybinding.when.includes('listFocus')) {\n        continue;\n      }\n\n      if (keybinding.command.startsWith('notebook')) {\n        continue;\n      }\n\n      let key = keybinding.key;\n      if (process.platform === 'darwin') {\n        key = keybinding.mac || key;\n      } else if (process.platform === 'linux') {\n        key = keybinding.linux || key;\n      }\n\n      this.boundKeyCombinations.push({\n        key: Notation.NormalizeKey(key, this.leader),\n        command: keybinding.command,\n      });\n    }\n\n    // decorations\n    decoration.load(this);\n\n    for (const boundKey of this.boundKeyCombinations) {\n      // By default, all key combinations are used\n      let useKey = true;\n\n      const handleKey = this.handleKeys[boundKey.key];\n      if (handleKey !== undefined) {\n        // enabled/disabled through `vim.handleKeys`\n        useKey = handleKey;\n      } else if (!this.useCtrlKeys && boundKey.key.slice(1, 3) === 'C-') {\n        // user has disabled CtrlKeys and the current key is a CtrlKey\n        // <C-c>, still needs to be captured to overrideCopy\n        if (boundKey.key === '<C-c>' && this.overrideCopy) {\n          useKey = true;\n        } else {\n          useKey = false;\n        }\n      }\n\n      VSCodeContext.set(`vim.use${boundKey.key}`, useKey);\n    }\n\n    VSCodeContext.set('vim.overrideCopy', this.overrideCopy);\n    VSCodeContext.set('vim.overrideCtrlC', this.overrideCopy || this.useCtrlKeys);\n\n    return validatorResults;\n  }\n\n  getConfiguration(section: string = ''): RemoveIndex<vscode.WorkspaceConfiguration> {\n    const document = vscode.window.activeTextEditor?.document;\n    const resource = document ? { uri: document.uri, languageId: document.languageId } : undefined;\n    return vscode.workspace.getConfiguration(section, resource);\n  }\n\n  cursorStyleFromString(cursorStyle: string): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorTypeMap[cursorStyle];\n  }\n\n  clearKeyBindingsMaps() {\n    // Clear the KeyBindingsMaps so that the previous configuration maps don't leak to this one\n    this.normalModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.insertModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.visualModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.commandLineModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n    this.operatorPendingModeKeyBindingsMap = new Map<string, IKeyRemapping>();\n  }\n\n  handleKeys: IHandleKeys = {};\n\n  useSystemClipboard = false;\n\n  shell = '';\n\n  useCtrlKeys = false;\n\n  overrideCopy = true;\n\n  hlsearch = false;\n\n  ignorecase = true;\n\n  smartcase = true;\n\n  autoindent = true;\n\n  matchpairs = '(:),{:},[:]';\n\n  joinspaces = true;\n\n  camelCaseMotion: ICamelCaseMotionConfiguration = {\n    enable: true,\n  };\n\n  replaceWithRegister = false;\n\n  smartRelativeLine = false;\n\n  sneak = false;\n  sneakUseIgnorecaseAndSmartcase = false;\n  sneakReplacesF = false;\n\n  surround = true;\n\n  argumentObjectSeparators = [','];\n  argumentObjectOpeningDelimiters = ['(', '['];\n  argumentObjectClosingDelimiters = [')', ']'];\n\n  easymotion = false;\n  easymotionMarkerBackgroundColor = '#0000';\n  easymotionMarkerForegroundColorOneChar = '#ff0000';\n  easymotionMarkerForegroundColorTwoCharFirst = '#ffb400';\n  easymotionMarkerForegroundColorTwoCharSecond = '#b98300';\n  easymotionIncSearchForegroundColor = '#7fbf00';\n  easymotionDimColor = '#777777';\n  easymotionDimBackground = true;\n  easymotionMarkerFontWeight = 'bold';\n  easymotionKeys = 'hklyuiopnm,qwertzxcvbasdgjf;';\n  easymotionJumpToAnywhereRegex = '\\\\b[A-Za-z0-9]|[A-Za-z0-9]\\\\b|_.|#.|[a-z][A-Z]';\n\n  targets: ITargetsConfiguration = {\n    enable: false,\n\n    bracketObjects: {\n      enable: true,\n    },\n\n    smartQuotes: {\n      enable: false,\n      breakThroughLines: false,\n      aIncludesSurroundingSpaces: true,\n    },\n  };\n\n  autoSwitchInputMethod: IAutoSwitchInputMethod = {\n    enable: false,\n    defaultIM: '',\n    obtainIMCmd: '',\n    switchIMCmd: '',\n  };\n\n  timeout = 1000;\n\n  maxmapdepth = 1000;\n\n  showcmd = true;\n\n  showmodename = true;\n\n  leader = this.leaderDefault;\n\n  history = 50;\n\n  inccommand: '' | 'append' | 'replace' = '';\n\n  incsearch = true;\n\n  startInInsertMode = false;\n\n  statusBarColorControl = false;\n\n  statusBarColors: IModeSpecificStrings<string | string[]> = {\n    normal: '#005f5f',\n    insert: '#5f0000',\n    visual: '#5f00af',\n    visualline: '#005f87',\n    visualblock: '#86592d',\n    replace: '#000000',\n  };\n\n  debug: IDebugConfiguration = {\n    silent: false,\n    loggingLevelForAlert: 'error',\n    loggingLevelForConsole: 'error',\n  };\n\n  searchHighlightColor = '';\n  searchHighlightTextColor = '';\n\n  searchMatchColor = '';\n  searchMatchTextColor = '';\n\n  substitutionColor = '#50f01080';\n  substitutionTextColor = '';\n\n  highlightedyank: IHighlightedYankConfiguration = {\n    enable: false,\n    color: 'rgba(250, 240, 170, 0.5)',\n    textColor: '',\n    duration: 200,\n  };\n\n  @overlapSetting({ settingName: 'tabSize', defaultValue: 8 })\n  tabstop!: number;\n\n  @overlapSetting({ settingName: 'cursorStyle', defaultValue: 'line' })\n  private editorCursorStyleRaw!: string;\n\n  get editorCursorStyle(): vscode.TextEditorCursorStyle | undefined {\n    return this.cursorStyleFromString(this.editorCursorStyleRaw);\n  }\n  set editorCursorStyle(val: vscode.TextEditorCursorStyle | undefined) {\n    // nop\n  }\n\n  @overlapSetting({ settingName: 'insertSpaces', defaultValue: false })\n  expandtab!: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: true,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['relative', false],\n      ['interval', false],\n    ]),\n  })\n  number!: boolean;\n\n  @overlapSetting({\n    settingName: 'lineNumbers',\n    defaultValue: false,\n    map: new Map([\n      ['on', false],\n      ['off', false],\n      ['relative', true],\n      ['interval', false],\n    ]),\n  })\n  relativenumber!: boolean;\n\n  @overlapSetting({\n    settingName: 'wordSeparators',\n    defaultValue: '/\\\\()\"\\':,.;<>~!@#$%^&*|+=[]{}`?-',\n  })\n  iskeyword!: string;\n\n  @overlapSetting({\n    settingName: 'wordWrap',\n    defaultValue: false,\n    map: new Map([\n      ['on', true],\n      ['off', false],\n      ['wordWrapColumn', true],\n      ['bounded', true],\n    ]),\n  })\n  wrap!: boolean;\n\n  @overlapSetting({\n    settingName: 'cursorSurroundingLines',\n    defaultValue: 0,\n  })\n  scrolloff!: number;\n\n  boundKeyCombinations: IKeyBinding[] = [];\n\n  visualstar = false;\n\n  mouseSelectionGoesIntoVisualMode = true;\n\n  changeWordIncludesWhitespace = false;\n\n  foldfix = false;\n\n  disableExtension: boolean = false;\n\n  enableNeovim = false;\n  neovimPath = '';\n  neovimUseConfigFile = false;\n  neovimConfigPath = '';\n\n  vimrc = {\n    enable: false,\n    path: '',\n  };\n\n  digraphs = {};\n\n  gdefault = false;\n  substituteGlobalFlag = false; // Deprecated in favor of gdefault\n\n  whichwrap = 'b,s';\n\n  startofline = true;\n\n  showMarksInGutter = false;\n\n  report = 2;\n  wrapscan = true;\n\n  scroll = 0;\n  getScrollLines(visibleRanges: vscode.Range[]): number {\n    return this.scroll === 0\n      ? Math.ceil((visibleRanges[0].end.line - visibleRanges[0].start.line) / 2)\n      : this.scroll;\n  }\n\n  cursorStylePerMode: IModeSpecificStrings<string> = {\n    normal: undefined,\n    insert: undefined,\n    visual: undefined,\n    visualline: undefined,\n    visualblock: undefined,\n    replace: undefined,\n  };\n\n  getCursorStyleForMode(modeName: string): vscode.TextEditorCursorStyle | undefined {\n    const cursorStyle = this.cursorStylePerMode[modeName.toLowerCase()];\n    if (cursorStyle) {\n      return this.cursorStyleFromString(cursorStyle);\n    }\n\n    return;\n  }\n\n  // remappings\n  insertModeKeyBindings: IKeyRemapping[] = [];\n  insertModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  normalModeKeyBindings: IKeyRemapping[] = [];\n  normalModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindings: IKeyRemapping[] = [];\n  operatorPendingModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  visualModeKeyBindings: IKeyRemapping[] = [];\n  visualModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n  commandLineModeKeyBindings: IKeyRemapping[] = [];\n  commandLineModeKeyBindingsNonRecursive: IKeyRemapping[] = [];\n\n  insertModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  normalModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  operatorPendingModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  visualModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n  commandLineModeKeyBindingsMap: Map<string, IKeyRemapping> = new Map();\n\n  get textwidth(): number {\n    const textwidth = this.getConfiguration('vim').get('textwidth', 80);\n\n    if (typeof textwidth !== 'number') {\n      return 80;\n    }\n\n    return textwidth;\n  }\n\n  private static unproxify(obj: object): object {\n    const result = {};\n    // tslint:disable-next-line: forin\n    for (const key in obj) {\n      const val = obj[key] as any;\n      if (val !== null && val !== undefined) {\n        result[key] = val;\n      }\n    }\n    return result;\n  }\n}\n\n// handle mapped settings between vscode to vim\nfunction overlapSetting(args: {\n  settingName: string;\n  defaultValue: OptionValue;\n  map?: Map<string | number | boolean, string | number | boolean>;\n}) {\n  return (target: any, propertyKey: string) => {\n    Object.defineProperty(target, propertyKey, {\n      get() {\n        // retrieve value from vim configuration\n        // if the value is not defined or empty\n        // look at the equivalent `editor` setting\n        // if that is not defined then defer to the default value\n        let val = this['_' + propertyKey];\n        if (val !== undefined && val !== '') {\n          return val;\n        }\n\n        val = this.getConfiguration('editor').get(args.settingName, args.defaultValue);\n        if (args.map && val !== undefined) {\n          val = args.map.get(val);\n        }\n\n        return val;\n      },\n      set(value) {\n        // synchronize the vim setting with the `editor` equivalent\n        this['_' + propertyKey] = value;\n\n        if (value === undefined || value === '' || Globals.isTesting) {\n          return;\n        }\n\n        if (args.map) {\n          for (const [vscodeSetting, vimSetting] of args.map.entries()) {\n            if (value === vimSetting) {\n              value = vscodeSetting;\n              break;\n            }\n          }\n        }\n\n        // update configuration asynchronously\n        this.getConfiguration('editor').update(\n          args.settingName,\n          value,\n          vscode.ConfigurationTarget.Global\n        );\n      },\n      enumerable: true,\n      configurable: true,\n    });\n  };\n}\n\nexport const configuration = new Configuration();\n","import { IConfiguration } from './iconfiguration';\nimport { IConfigurationValidator, ValidatorResults } from './iconfigurationValidator';\n\nclass ConfigurationValidator {\n  private readonly validators: IConfigurationValidator[];\n\n  constructor() {\n    this.validators = [];\n  }\n\n  public registerValidator(validator: IConfigurationValidator) {\n    this.validators.push(validator);\n  }\n\n  public async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const results = new ValidatorResults();\n\n    for (const validator of this.validators) {\n      const validatorResults = await validator.validate(config);\n      if (validatorResults.hasError) {\n        // errors found in configuration, disable feature\n        validator.disable(config);\n      }\n\n      results.concat(validatorResults);\n    }\n\n    return results;\n  }\n}\n\nexport const configurationValidator = new ConfigurationValidator();\n","import * as vscode from 'vscode';\nimport { IConfiguration } from './iconfiguration';\n\nclass DecorationImpl {\n  private _default!: vscode.TextEditorDecorationType;\n  private _searchHighlight!: vscode.TextEditorDecorationType;\n  private _searchMatch!: vscode.TextEditorDecorationType;\n  private _substitutionAppend!: vscode.TextEditorDecorationType;\n  private _substitutionReplace!: vscode.TextEditorDecorationType;\n  private _easyMotionIncSearch!: vscode.TextEditorDecorationType;\n  private _easyMotionDimIncSearch!: vscode.TextEditorDecorationType;\n  private _insertModeVirtualCharacter!: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursor!: vscode.TextEditorDecorationType;\n  private _operatorPendingModeCursorChar!: vscode.TextEditorDecorationType;\n\n  private _markDecorationCache = new Map<string, vscode.TextEditorDecorationType>();\n\n  private _createMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const svg = [\n      '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 30 30\" width=\"30px\" height=\"30px\">',\n      '<style>text { font-family: sans-serif; font-size: 0.8em; }</style>',\n      '<path fill=\"rgb(3,102,214)\" d=\"M23,27l-8-7l-8,7V5c0-1.105,0.895-2,2-2h12c1.105,0,2,0.895,2,2V27z\"/>',\n      `<text x=\"50%\" y=\"40%\" fill=\"rgb(200,200,200)\" text-anchor=\"middle\" dominant-baseline=\"middle\">${name}</text>`,\n      '</svg>',\n    ].join('');\n\n    const uri = vscode.Uri.parse(`data:image/svg+xml;utf8,${encodeURI(svg)}`, true);\n\n    return vscode.window.createTextEditorDecorationType({\n      isWholeLine: false,\n      gutterIconPath: uri,\n      gutterIconSize: 'cover',\n    });\n  }\n\n  public readonly confirmedSubstitution = vscode.window.createTextEditorDecorationType({\n    letterSpacing: '-9999999px',\n    opacity: '0',\n  });\n\n  public set default(value: vscode.TextEditorDecorationType) {\n    if (this._default) {\n      this._default.dispose();\n    }\n    this._default = value;\n  }\n\n  public get default() {\n    return this._default;\n  }\n\n  public set searchHighlight(value: vscode.TextEditorDecorationType) {\n    if (this._searchHighlight) {\n      this._searchHighlight.dispose();\n    }\n    this._searchHighlight = value;\n  }\n\n  public get searchHighlight() {\n    return this._searchHighlight;\n  }\n\n  public set searchMatch(value: vscode.TextEditorDecorationType) {\n    if (this._searchMatch) {\n      this._searchMatch.dispose();\n    }\n    this._searchMatch = value;\n  }\n\n  public get searchMatch() {\n    return this._searchMatch;\n  }\n\n  public set substitutionAppend(value: vscode.TextEditorDecorationType) {\n    if (this._substitutionAppend) {\n      this._substitutionAppend.dispose();\n    }\n    this._substitutionAppend = value;\n  }\n\n  public get substitutionAppend() {\n    return this._substitutionAppend;\n  }\n\n  public set substitutionReplace(value: vscode.TextEditorDecorationType) {\n    if (this._substitutionReplace) {\n      this._substitutionReplace.dispose();\n    }\n    this._substitutionReplace = value;\n  }\n\n  public get substitutionReplace() {\n    return this._substitutionReplace;\n  }\n\n  public get easyMotionIncSearch() {\n    return this._easyMotionIncSearch;\n  }\n\n  public set easyMotionIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionIncSearch) {\n      this._easyMotionIncSearch.dispose();\n    }\n    this._easyMotionIncSearch = value;\n  }\n\n  public get easyMotionDimIncSearch() {\n    return this._easyMotionDimIncSearch;\n  }\n\n  public set easyMotionDimIncSearch(value: vscode.TextEditorDecorationType) {\n    if (this._easyMotionDimIncSearch) {\n      this._easyMotionDimIncSearch.dispose();\n    }\n    this._easyMotionDimIncSearch = value;\n  }\n\n  public getOrCreateMarkDecoration(name: string): vscode.TextEditorDecorationType {\n    const decorationType = this.getMarkDecoration(name);\n\n    if (decorationType) {\n      return decorationType;\n    } else {\n      const type = this._createMarkDecoration(name);\n      this._markDecorationCache.set(name, type);\n      return type;\n    }\n  }\n\n  public getMarkDecoration(name: string): vscode.TextEditorDecorationType | undefined {\n    return this._markDecorationCache.get(name);\n  }\n\n  public allMarkDecorations(): IterableIterator<vscode.TextEditorDecorationType> {\n    return this._markDecorationCache.values();\n  }\n\n  public set insertModeVirtualCharacter(value: vscode.TextEditorDecorationType) {\n    if (this._insertModeVirtualCharacter) {\n      this._insertModeVirtualCharacter.dispose();\n    }\n    this._insertModeVirtualCharacter = value;\n  }\n\n  public get insertModeVirtualCharacter() {\n    return this._insertModeVirtualCharacter;\n  }\n\n  public set operatorPendingModeCursor(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursor) {\n      this._operatorPendingModeCursor.dispose();\n    }\n    this._operatorPendingModeCursor = value;\n  }\n\n  public get operatorPendingModeCursor() {\n    return this._operatorPendingModeCursor;\n  }\n\n  public set operatorPendingModeCursorChar(value: vscode.TextEditorDecorationType) {\n    if (this._operatorPendingModeCursorChar) {\n      this._operatorPendingModeCursorChar.dispose();\n    }\n    this._operatorPendingModeCursorChar = value;\n  }\n\n  public get operatorPendingModeCursorChar() {\n    return this._operatorPendingModeCursorChar;\n  }\n\n  public load(configuration: IConfiguration) {\n    this.default = vscode.window.createTextEditorDecorationType({\n      backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      borderColor: new vscode.ThemeColor('editorCursor.foreground'),\n      dark: {\n        color: 'rgb(81,80,82)',\n      },\n      light: {\n        // used for light colored themes\n        color: 'rgb(255, 255, 255)',\n      },\n      borderStyle: 'solid',\n      borderWidth: '1px',\n    });\n\n    const searchHighlightBackgroundColor = configuration.searchHighlightColor\n      ? configuration.searchHighlightColor\n      : new vscode.ThemeColor('editor.findMatchHighlightBackground');\n\n    this.searchHighlight = vscode.window.createTextEditorDecorationType({\n      backgroundColor: searchHighlightBackgroundColor,\n      color: configuration.searchHighlightTextColor,\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n      after: {\n        color: 'transparent',\n        backgroundColor: searchHighlightBackgroundColor,\n      },\n    });\n\n    const searchMatchBackgroundColor = configuration.searchMatchColor\n      ? configuration.searchMatchColor\n      : new vscode.ThemeColor('editor.findMatchBackground');\n\n    this.searchMatch = vscode.window.createTextEditorDecorationType({\n      backgroundColor: searchMatchBackgroundColor,\n      color: configuration.searchMatchTextColor,\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n      after: {\n        color: 'transparent',\n        backgroundColor: searchMatchBackgroundColor,\n      },\n    });\n\n    const substitutionBackgroundColor = configuration.substitutionColor\n      ? configuration.substitutionColor\n      : new vscode.ThemeColor('editor.findMatchBackground');\n\n    this.substitutionAppend = vscode.window.createTextEditorDecorationType({\n      backgroundColor: searchHighlightBackgroundColor,\n      color: configuration.searchHighlightTextColor,\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n      after: {\n        color: configuration.substitutionTextColor,\n        backgroundColor: substitutionBackgroundColor,\n      },\n    });\n\n    // Use letterSpacing and opacity to hide the decorated range, so that before text gets rendered over it\n    this.substitutionReplace = vscode.window.createTextEditorDecorationType({\n      letterSpacing: '-9999999px',\n      opacity: '0',\n      overviewRulerColor: new vscode.ThemeColor('editorOverviewRuler.findMatchForeground'),\n      before: {\n        color: configuration.substitutionTextColor,\n        backgroundColor: substitutionBackgroundColor,\n      },\n    });\n\n    this.easyMotionIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionIncSearchForegroundColor,\n      fontWeight: configuration.easymotionMarkerFontWeight,\n    });\n\n    this.easyMotionDimIncSearch = vscode.window.createTextEditorDecorationType({\n      color: configuration.easymotionDimColor,\n    });\n\n    this.insertModeVirtualCharacter = vscode.window.createTextEditorDecorationType({\n      color: 'transparent', // no color to hide the existing character\n      before: {\n        color: 'currentColor',\n        backgroundColor: new vscode.ThemeColor('editor.background'),\n        borderColor: new vscode.ThemeColor('editor.background'),\n        margin: '0 -1ch 0 0',\n        height: '100%',\n      },\n    });\n\n    // This creates the half block cursor when on operator pending mode\n    this.operatorPendingModeCursor = vscode.window.createTextEditorDecorationType({\n      before: {\n        // no color to hide the existing character. We only need the character here to make\n        // the width be the same as the existing character.\n        color: 'transparent',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        bottom: 0;\n        line-height: 0;`,\n        height: '50%',\n        backgroundColor: new vscode.ThemeColor('editorCursor.foreground'),\n      },\n    });\n\n    // This puts a character on top of the half block cursor and on top of the existing character\n    // to create the mix-blend 'magic'\n    this.operatorPendingModeCursorChar = vscode.window.createTextEditorDecorationType({\n      // We make the existing character 'black' -> rgb(0,0,0), because when using the mix-blend-mode\n      // with 'exclusion' it subtracts the darker color from the lightest color which means we will\n      // subtract zero from our 'currentcolor' leaving us with 'currentcolor' on the part above the\n      // background of the half cursor.\n      color: 'black',\n      before: {\n        color: 'currentcolor',\n        // The '-1ch' right margin is so that it displays on top of the existing character. The amount\n        // here doesn't really matter, it could be '-1px' it just needs to be negative so that the left\n        // of this 'before' element coincides with the left of the existing character.\n        margin: `0 -1ch 0 0;\n        position: absolute;\n        mix-blend-mode: exclusion;`,\n        height: '100%',\n      },\n    });\n  }\n}\n\nexport const decoration = new DecorationImpl();\n","import { IConfiguration } from './iconfiguration';\n\ninterface IValidatorResult {\n  level: 'error' | 'warning';\n  message: string;\n}\n\nexport class ValidatorResults {\n  errors = new Array<IValidatorResult>();\n\n  public append(validationResult: IValidatorResult) {\n    this.errors.push(validationResult);\n  }\n\n  public concat(validationResults: ValidatorResults) {\n    this.errors = this.errors.concat(validationResults.get());\n  }\n\n  public get(): ReadonlyArray<IValidatorResult> {\n    return this.errors;\n  }\n\n  public get numErrors(): number {\n    return this.errors.filter((e) => e.level === 'error').length;\n  }\n\n  public get hasError(): boolean {\n    return this.numErrors > 0;\n  }\n\n  public get numWarnings(): number {\n    return this.errors.filter((e) => e.level === 'warning').length;\n  }\n\n  public get hasWarning(): boolean {\n    return this.numWarnings > 0;\n  }\n}\n\nexport interface IConfigurationValidator {\n  validate(config: IConfiguration): Promise<ValidatorResults>;\n  disable(config: IConfiguration): void;\n}\n","export class Notation {\n  // Mapping from a regex to the normalized string that it should be converted to.\n  private static readonly notationMap: ReadonlyArray<[RegExp, string]> = [\n    [/ctrl\\+|c\\-/gi, 'C-'],\n    [/cmd\\+|d\\-/gi, 'D-'],\n    [/shift\\+|s\\-/gi, 'S-'],\n    [/escape|esc/gi, 'Esc'],\n    [/backspace|bs/gi, 'BS'],\n    [/delete|del/gi, 'Del'],\n    [/home/gi, 'Home'],\n    [/end/gi, 'End'],\n    [/insert/gi, 'Insert'],\n    [/<space>/gi, ' '],\n    [/<cr>|<enter>|<return>/gi, '\\n'],\n  ];\n\n  private static shiftedLetterRegex = /<S-[a-zA-Z]>/;\n\n  /**\n   * Converts keystroke like <tab> to a single control character like \\t\n   */\n  public static ToControlCharacter(key: string) {\n    if (key === '<tab>') {\n      return '\\t';\n    }\n\n    return key;\n  }\n\n  public static IsControlKey(key: string): boolean {\n    key = key.toLocaleUpperCase();\n    return (\n      this.isSurroundedByAngleBrackets(key) && key !== '<BS>' && key !== '<S-BS>' && key !== '<TAB>'\n    );\n  }\n\n  /**\n   * Normalizes key to AngleBracketNotation\n   * (e.g. <ctrl+x>, Ctrl+x, <c-x> normalized to <C-x>)\n   * and converts the characters to their literals\n   * (e.g. <space>, <cr>, <leader>)\n   */\n  public static NormalizeKey(key: string, leaderKey: string): string {\n    if (typeof key !== 'string') {\n      return key;\n    }\n\n    if (key.length === 1) {\n      return key;\n    }\n\n    key = key.toLocaleLowerCase();\n\n    if (!this.isSurroundedByAngleBrackets(key)) {\n      key = `<${key}>`;\n    }\n\n    if (key === '<leader>') {\n      return leaderKey;\n    }\n\n    if (['<up>', '<down>', '<left>', '<right>'].includes(key)) {\n      return key;\n    }\n\n    for (const [regex, standardNotation] of this.notationMap) {\n      key = key.replace(regex, standardNotation);\n    }\n\n    if (this.shiftedLetterRegex.test(key)) {\n      key = key[3].toUpperCase();\n    }\n\n    return key;\n  }\n\n  /**\n   * Converts a key to a form which will look nice when logged, etc.\n   */\n  public static printableKey(key: string, leaderKey: string) {\n    const normalized = this.NormalizeKey(key, leaderKey);\n    return normalized === ' ' ? '<space>' : normalized === '\\n' ? '<enter>' : normalized;\n  }\n\n  private static isSurroundedByAngleBrackets(key: string): boolean {\n    return key.startsWith('<') && key.endsWith('>');\n  }\n}\n","import * as vscode from 'vscode';\nimport { IKeyRemapping } from './iconfiguration';\nimport { Logger } from '../util/logger';\nimport { ModeHandler } from '../mode/modeHandler';\nimport { Mode } from '../mode/mode';\nimport { configuration } from '../configuration/configuration';\nimport { StatusBar } from '../statusBar';\nimport { VimError, ErrorCode, ForceStopRemappingError } from '../error';\nimport { SpecialKeys } from '../util/specialKeys';\nimport { exCommandParser } from '../vimscript/exCommandParser';\n\ninterface IRemapper {\n  /**\n   * Send keys to remapper\n   */\n  sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean>;\n\n  /**\n   * Given keys pressed thus far, denotes if it is a potential remap\n   */\n  readonly isPotentialRemap: boolean;\n}\n\nexport class Remappers implements IRemapper {\n  private readonly remappers = [\n    new InsertModeRemapper(),\n    new NormalModeRemapper(),\n    new VisualModeRemapper(),\n    new CommandLineModeRemapper(),\n    new OperatorPendingModeRemapper(),\n  ];\n\n  get isPotentialRemap(): boolean {\n    return this.remappers.some((r) => r.isPotentialRemap);\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    for (const remapper of this.remappers) {\n      if (await remapper.sendKey(keys, modeHandler)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexport class Remapper implements IRemapper {\n  private readonly configKey: string;\n  private readonly remappedModes: Mode[];\n  private readonly logger = Logger.get('Remapper');\n\n  /**\n   * Checks if the current commandList is a potential remap.\n   */\n  private _isPotentialRemap = false;\n\n  /**\n   * If the commandList has a remap but there is still another potential remap we\n   * call it an Ambiguous Remap and we store it here. If later we need to handle it\n   * we don't need to go looking for it.\n   */\n  private hasAmbiguousRemap: IKeyRemapping | undefined;\n\n  /**\n   * If the commandList is a potential remap but has no ambiguous remap\n   * yet, we say that it has a Potential Remap.\n   *\n   * This is to distinguish the commands with ambiguous remaps and the\n   * ones without.\n   *\n   * Example 1: if 'aaaa' is mapped and so is 'aa', when the user has pressed\n   * 'aaa' we say it has an Ambiguous Remap which is 'aa', because if the\n   * user presses other key than 'a' next or waits for the timeout to finish\n   * we need to now that there was a remap to run so we first run the 'aa'\n   * remap and then handle the remaining keys.\n   *\n   * Example 2: if only 'aaaa' is mapped, when the user has pressed 'aaa'\n   * we say it has a Potential Remap, because if the user presses other key\n   * than 'a' next or waits for the timeout to finish we need to now that\n   * there was a potential remap that never came or was broken, so we can\n   * resend the keys again without allowing for a potential remap on the first\n   * key, which means we won't get to the same state because the first key\n   * will be handled as an action (in this case a 'CommandInsertAfterCursor')\n   */\n  private hasPotentialRemap = false;\n\n  get isPotentialRemap(): boolean {\n    return this._isPotentialRemap;\n  }\n\n  constructor(configKey: string, remappedModes: Mode[]) {\n    this.configKey = configKey;\n    this.remappedModes = remappedModes;\n  }\n\n  public async sendKey(keys: string[], modeHandler: ModeHandler): Promise<boolean> {\n    const { vimState, remapState } = modeHandler;\n\n    this._isPotentialRemap = false;\n    const allowPotentialRemapOnFirstKey = vimState.recordedState.allowPotentialRemapOnFirstKey;\n    let remainingKeys: string[] = [];\n\n    /**\n     * Means that the timeout finished so we now can't allow the keys to be buffered again\n     * because the user already waited for timeout.\n     */\n    let allowBufferingKeys = true;\n\n    if (!this.remappedModes.includes(vimState.currentModeIncludingPseudoModes)) {\n      return false;\n    }\n\n    const userDefinedRemappings = configuration[this.configKey] as Map<string, IKeyRemapping>;\n\n    if (keys[keys.length - 1] === SpecialKeys.TimeoutFinished) {\n      // Timeout finished. Don't let an ambiguous or potential remap start another timeout again\n      keys = keys.slice(0, keys.length - 1);\n      allowBufferingKeys = false;\n    }\n\n    if (keys.length === 0) {\n      return true;\n    }\n\n    this.logger.debug(\n      `trying to find matching remap. keys=${keys}. mode=${\n        Mode[vimState.currentMode]\n      }. keybindings=${this.configKey}.`\n    );\n\n    let remapping: IKeyRemapping | undefined = this.findMatchingRemap(\n      userDefinedRemappings,\n      keys,\n      vimState.currentMode\n    );\n\n    // Check to see if a remapping could potentially be applied when more keys are received\n    let isPotentialRemap = Remapper.hasPotentialRemap(keys, userDefinedRemappings);\n\n    this._isPotentialRemap =\n      isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey;\n\n    /**\n     * Handle a broken potential or ambiguous remap\n     * 1. If this Remapper doesn't have a remapping AND\n     * 2. (It previously had an AmbiguousRemap OR a PotentialRemap) AND\n     * 3. (It doesn't have a potential remap anymore OR timeout finished) AND\n     * 4. keys length is more than 1\n     *\n     * Points 1-3: If we no longer have a remapping but previously had one or a potential one\n     * and there is no longer potential remappings because of another pressed key or because the\n     * timeout has passed we need to handle those situations by resending the keys or handling the\n     * ambiguous remap and resending any remaining keys.\n     * Point 4: if there is only one key there is no point in resending it without allowing remaps\n     * on first key, we can let the remapper go to the end because since either there was no potential\n     * remap anymore or the timeout finished so this means that the next two checks (the 'Buffer keys\n     * and create timeout' and 'Handle remapping and remaining keys') will never be hit, so it reaches\n     * the end without doing anything which means that this key will be handled as an action as intended.\n     */\n    if (\n      !remapping &&\n      (this.hasAmbiguousRemap || this.hasPotentialRemap) &&\n      (!isPotentialRemap || !allowBufferingKeys) &&\n      keys.length > 1\n    ) {\n      if (this.hasAmbiguousRemap) {\n        remapping = this.hasAmbiguousRemap;\n        isPotentialRemap = false;\n        this._isPotentialRemap = false;\n\n        // Use the commandList to get the remaining keys so that it includes any existing\n        // '<TimeoutFinished>' key\n        remainingKeys = vimState.recordedState.commandList.slice(remapping.before.length);\n        this.hasAmbiguousRemap = undefined;\n      }\n      if (!remapping) {\n        // if there is still no remapping, handle all the keys without allowing\n        // a potential remap on the first key so that we don't repeat everything\n        // again, but still allow for other ambiguous remaps after the first key.\n        //\n        // Example: if 'iiii' is mapped in normal and 'ii' is mapped in insert mode,\n        // and the user presses 'iiia' in normal mode or presses 'iii' and waits\n        // for the timeout to finish, we want the first 'i' to be handled without\n        // allowing potential remaps, which means it will go into insert mode,\n        // but then the next 'ii' should be remapped in insert mode and after the\n        // remap the 'a' should be handled.\n        if (!allowBufferingKeys) {\n          // Timeout finished and there is no remapping, so handle the buffered\n          // keys but resend the '<TimeoutFinished>' key as well so we don't wait\n          // for the timeout again but can still handle potential remaps.\n          //\n          // Example 1: if 'ccc' is mapped in normal mode and user presses 'cc' and\n          // waits for the timeout to finish, this will resend the 'cc<TimeoutFinished>'\n          // keys without allowing a potential remap on first key, which makes the\n          // first 'c' be handled as a 'ChangeOperator' and the second 'c' which has\n          // potential remaps (the 'ccc' remap) is buffered and the timeout started\n          // but then the '<TimeoutFinished>' key comes straight away that clears the\n          // timeout without waiting again, and makes the second 'c' be handled normally\n          // as another 'ChangeOperator'.\n          //\n          // Example 2: if 'iiii' is mapped in normal and 'ii' is mapped in insert\n          // mode, and the user presses 'iii' in normal mode and waits for the timeout\n          // to finish, this will resend the 'iii<TimeoutFinished>' keys without allowing\n          // a potential remap on first key, which makes the first 'i' be handled as\n          // an 'CommandInsertAtCursor' and goes to insert mode, next the second 'i'\n          // is buffered, then the third 'i' finds the insert mode remapping of 'ii'\n          // and handles that remap, after the remapping being handled the '<TimeoutFinished>'\n          // key comes that clears the timeout and since the commandList will be empty\n          // we return true as we finished handling this sequence of keys.\n\n          keys.push(SpecialKeys.TimeoutFinished); // include the '<TimeoutFinished>' key\n\n          this.logger.debug(\n            `${this.configKey}. timeout finished, handling timed out buffer keys without allowing a new timeout.`\n          );\n        }\n        this.logger.debug(\n          `${this.configKey}. potential remap broken. resending keys without allowing a potential remap on first key. keys=${keys}`\n        );\n        this.hasPotentialRemap = false;\n        vimState.recordedState.allowPotentialRemapOnFirstKey = false;\n        vimState.recordedState.resetCommandList();\n\n        if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n          // Some keys that broke the possible remap were typed by the user so handle them seperatly\n          const lastRemapLength =\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!.length;\n          const keysPressedByUser = keys.slice(lastRemapLength);\n          keys = keys.slice(0, lastRemapLength);\n\n          try {\n            remapState.isCurrentlyPerformingRecursiveRemapping = true;\n            await modeHandler.handleMultipleKeyEvents(keys);\n          } catch (e) {\n            if (e instanceof ForceStopRemappingError) {\n              this.logger.debug(\n                `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            }\n          } finally {\n            remapState.isCurrentlyPerformingRecursiveRemapping = false;\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n            await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n          }\n        } else {\n          await modeHandler.handleMultipleKeyEvents(keys);\n        }\n        return true;\n      }\n    }\n\n    /**\n     * Buffer keys and create timeout\n     * 1. If the current keys have a potential remap AND\n     * 2. The timeout hasn't finished yet so we allow buffering keys AND\n     * 3. We allow potential remap on first key (check the note on RecordedState. TLDR: this will only\n     * be false for one key, the first one, when we resend keys that had a potential remap but no longer\n     * have it or the timeout finished)\n     *\n     * Points 1-3: If the current keys still have a potential remap and the timeout hasn't finished yet\n     * and we are not preventing a potential remap on the first key then we need to buffer this keys\n     * and wait for another key or the timeout to finish.\n     */\n    if (isPotentialRemap && allowBufferingKeys && allowPotentialRemapOnFirstKey) {\n      if (remapping) {\n        // There are other potential remaps (ambiguous remaps), wait for other key or for the timeout\n        // to finish. Also store this current ambiguous remap on '_hasAmbiguousRemap' so that if later\n        // this ambiguous remap is broken or the user waits for timeout we don't need to go looking for\n        // it again.\n        this.hasAmbiguousRemap = remapping;\n\n        this.logger.debug(\n          `${this.configKey}. ambiguous match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. waiting for other key or timeout to finish.`\n        );\n      } else {\n        this.hasPotentialRemap = true;\n        this.logger.debug(\n          `${this.configKey}. potential remap found. waiting for other key or timeout to finish.`\n        );\n      }\n\n      // Store BufferedKeys\n      vimState.recordedState.bufferedKeys = [...keys];\n\n      // Create Timeout\n      vimState.recordedState.bufferedKeysTimeoutObj = setTimeout(() => {\n        modeHandler.handleKeyEvent(SpecialKeys.TimeoutFinished);\n      }, configuration.timeout);\n      return true;\n    }\n\n    /**\n     * Handle Remapping and any remaining keys\n     * If we get here with a remapping that means we need to handle it.\n     */\n    if (remapping) {\n      if (!allowBufferingKeys) {\n        // If the user already waited for the timeout to finish, prevent the\n        // remapping from waiting for the timeout again by making a clone of\n        // remapping and change 'after' to send the '<TimeoutFinished>' key at\n        // the end.\n        const newRemapping = { ...remapping };\n        newRemapping.after = remapping.after?.slice(0);\n        newRemapping.after?.push(SpecialKeys.TimeoutFinished);\n        remapping = newRemapping;\n      }\n\n      this.hasAmbiguousRemap = undefined;\n      this.hasPotentialRemap = false;\n\n      let skipFirstCharacter = false;\n\n      // If we were performing a remapping already, it means this remapping has a parent remapping\n      const hasParentRemapping = remapState.isCurrentlyPerformingRemapping;\n      if (!hasParentRemapping) {\n        remapState.mapDepth = 0;\n      }\n\n      if (!remapping.recursive) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n      } else {\n        remapState.isCurrentlyPerformingRecursiveRemapping = true;\n\n        // As per the Vim documentation: (:help recursive)\n        // If the {rhs} starts with {lhs}, the first character is not mapped\n        // again (this is Vi compatible).\n        // For example:\n        // map ab abcd\n        // will execute the \"a\" command and insert \"bcd\" in the text. The \"ab\"\n        // in the {rhs} will not be mapped again.\n        if (remapping.after?.join('').startsWith(remapping.before.join(''))) {\n          skipFirstCharacter = true;\n        }\n      }\n\n      // Increase mapDepth\n      remapState.mapDepth++;\n\n      this.logger.debug(\n        `${this.configKey}. match found. before=${remapping.before}. after=${remapping.after}. command=${remapping.commands}. remainingKeys=${remainingKeys}. mapDepth=${remapState.mapDepth}.`\n      );\n\n      let remapFailed = false;\n\n      try {\n        // Check maxMapDepth\n        if (remapState.mapDepth >= configuration.maxmapdepth) {\n          const vimError = VimError.fromCode(ErrorCode.RecursiveMapping);\n          StatusBar.displayError(vimState, vimError);\n          throw ForceStopRemappingError.fromVimError(vimError);\n        }\n\n        // Hacky code incoming!!! If someone has a better way to do this please change it\n        if (remapState.mapDepth % 10 === 0) {\n          // Allow the user to press <C-c> or <Esc> key when inside an infinite looping remap.\n          // When inside an infinite looping recursive mapping it would block the editor until it reached\n          // the maxmapdepth. This 0ms wait allows the extension to handle any key typed by the user which\n          // means it allows the user to press <C-c> or <Esc> to force stop the looping remap.\n          // This shouldn't impact the normal use case because we're only running this every 10 nested\n          // remaps. Also when the logs are set to Error only, a looping recursive remap takes around 1.5s\n          // to reach 1000 mapDepth and give back control to the user, but when logs are set to debug it\n          // can take as long as 7 seconds.\n          const wait = (ms: number) => new Promise((res) => setTimeout(res, ms));\n          await wait(0);\n        }\n\n        remapState.remapUsedACharacter = false;\n\n        await this.handleRemapping(remapping, modeHandler, skipFirstCharacter);\n      } catch (e) {\n        if (e instanceof ForceStopRemappingError) {\n          // If a motion fails or a VimError happens during any kind of remapping or if the user presses the\n          // force stop remapping key (<C-c> or <Esc>) during a recursive remapping it should stop handling\n          // the remap and all its parent remaps if we are on a chain of recursive remaps.\n          // (Vim documentation :help map-error)\n          remapFailed = true;\n\n          // keep throwing until we reach the first parent\n          if (hasParentRemapping) {\n            throw e;\n          }\n\n          this.logger.debug(\n            `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n          );\n        } else {\n          // If some other error happens during the remapping handling it should stop the remap and rethrow\n          this.logger.debug(\n            `${this.configKey}. error found in the middle of remapping, ignoring the rest of the remap. error: ${e}`\n          );\n          throw e;\n        }\n      } finally {\n        // Check if we are still inside a recursive remap\n        if (!hasParentRemapping && remapState.isCurrentlyPerformingRecursiveRemapping) {\n          // no more recursive remappings being handled\n          if (vimState.recordedState.bufferedKeysTimeoutObj !== undefined) {\n            // In order to be able to receive other keys and at the same time wait for timeout, we need\n            // to create a timeout and return from the remapper so that modeHandler can be free to receive\n            // more keys. This means that if we are inside a recursive remapping, when we return on the\n            // last key of that remapping it will think that it is finished and set the currently\n            // performing recursive remapping flag to false, which would result in the current bufferedKeys\n            // not knowing they had a parent remapping. So we store that remapping here.\n            remapState.wasPerformingRemapThatFinishedWaitingForTimeout = { ...remapping };\n          }\n          remapState.isCurrentlyPerformingRecursiveRemapping = false;\n          remapState.forceStopRecursiveRemapping = false;\n        }\n\n        if (!hasParentRemapping) {\n          // Last remapping finished handling. Set undo step.\n          vimState.historyTracker.finishCurrentStep();\n        }\n\n        // NonRecursive remappings can't have nested remaps so after a finished remap we always set this to\n        // false, because either we were performing a non recursive remap and now we finish or we weren't\n        // performing a non recursive remapping and this was false anyway.\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n\n        // if there were other remaining keys on the buffered keys that weren't part of the remapping\n        // handle them now, except if the remap failed and the remaining keys weren't typed by the user.\n        // (we know that if this remapping has a parent remapping then the remaining keys weren't typed\n        // by the user, but instead were sent by the parent remapping handler)\n        if (remainingKeys.length > 0 && !(remapFailed && hasParentRemapping)) {\n          if (remapState.wasPerformingRemapThatFinishedWaitingForTimeout) {\n            // If there was a performing remap that finished waiting for timeout then only the remaining keys\n            // that are not part of that remap were typed by the user.\n            let specialKey: string | undefined = '';\n            if (remainingKeys[remainingKeys.length - 1] === SpecialKeys.TimeoutFinished) {\n              specialKey = remainingKeys.pop();\n            }\n            const lastRemap = remapState.wasPerformingRemapThatFinishedWaitingForTimeout.after!;\n            const lastRemapWithoutAmbiguousRemap = lastRemap.slice(remapping.before.length);\n            const keysPressedByUser = remainingKeys.slice(lastRemapWithoutAmbiguousRemap.length);\n            remainingKeys = remainingKeys.slice(0, remainingKeys.length - keysPressedByUser.length);\n            if (specialKey) {\n              remainingKeys.push(specialKey);\n              if (keysPressedByUser.length !== 0) {\n                keysPressedByUser.push(specialKey);\n              }\n            }\n            try {\n              remapState.isCurrentlyPerformingRecursiveRemapping = true;\n              await modeHandler.handleMultipleKeyEvents(remainingKeys);\n            } catch (e) {\n              this.logger.debug(\n                `${this.configKey}. Stopped the remapping in the middle, ignoring the rest. Reason: ${e.message}`\n              );\n            } finally {\n              remapState.isCurrentlyPerformingRecursiveRemapping = false;\n              remapState.wasPerformingRemapThatFinishedWaitingForTimeout = false;\n              if (keysPressedByUser.length > 0) {\n                await modeHandler.handleMultipleKeyEvents(keysPressedByUser);\n              }\n            }\n          } else {\n            await modeHandler.handleMultipleKeyEvents(remainingKeys);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    this.hasPotentialRemap = false;\n    this.hasAmbiguousRemap = undefined;\n    return false;\n  }\n\n  private async handleRemapping(\n    remapping: IKeyRemapping,\n    modeHandler: ModeHandler,\n    skipFirstCharacter: boolean\n  ) {\n    const { vimState, remapState } = modeHandler;\n\n    vimState.recordedState.resetCommandList();\n    if (remapping.after) {\n      if (skipFirstCharacter) {\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = true;\n        await modeHandler.handleKeyEvent(remapping.after[0]);\n        remapState.isCurrentlyPerformingNonRecursiveRemapping = false;\n        await modeHandler.handleMultipleKeyEvents(remapping.after.slice(1));\n      } else {\n        await modeHandler.handleMultipleKeyEvents(remapping.after);\n      }\n    }\n\n    if (remapping.commands) {\n      const count = vimState.recordedState.count || 1;\n      vimState.recordedState.count = 0;\n      for (let i = 0; i < count; i++) {\n        for (const command of remapping.commands) {\n          let commandString: string;\n          let commandArgs: string[];\n          if (typeof command === 'string') {\n            commandString = command;\n            commandArgs = [];\n          } else {\n            commandString = command.command;\n            commandArgs = command.args;\n          }\n\n          if (commandString.slice(0, 1) === ':') {\n            // Check if this is a vim command by looking for :\n            // TODO: Parse once & cache?\n            const result = exCommandParser.parse(commandString);\n            if (result.status) {\n              if (result.value.lineRange) {\n                await result.value.command.executeWithRange(vimState, result.value.lineRange);\n              } else {\n                await result.value.command.execute(vimState);\n              }\n            } else {\n              throw VimError.fromCode(ErrorCode.NotAnEditorCommand, commandString);\n            }\n            await modeHandler.updateView();\n          } else if (commandArgs) {\n            await vscode.commands.executeCommand(commandString, commandArgs);\n          } else {\n            await vscode.commands.executeCommand(commandString);\n          }\n\n          // TODO add test cases (silent defined in IKeyRemapping)\n          if (!remapping.silent) {\n            StatusBar.setText(vimState, `${commandString} ${commandArgs ?? ''}`);\n          }\n        }\n      }\n    }\n  }\n\n  protected findMatchingRemap(\n    userDefinedRemappings: Map<string, IKeyRemapping>,\n    inputtedKeys: string[],\n    currentMode: Mode\n  ): IKeyRemapping | undefined {\n    if (userDefinedRemappings.size === 0) {\n      return undefined;\n    }\n\n    const range = Remapper.getRemappedKeysLengthRange(userDefinedRemappings);\n    const startingSliceLength = inputtedKeys.length;\n    const inputtedString = inputtedKeys.join('');\n    for (let sliceLength = startingSliceLength; sliceLength >= range[0]; sliceLength--) {\n      const keySlice = inputtedKeys.slice(-sliceLength).join('');\n\n      this.logger.verbose(`key=${inputtedKeys}. keySlice=${keySlice}.`);\n      if (userDefinedRemappings.has(keySlice)) {\n        const precedingKeys = inputtedString.slice(0, inputtedString.length - keySlice.length);\n        if (precedingKeys.length > 0 && !/^[0-9]+$/.test(precedingKeys)) {\n          this.logger.verbose(\n            `key sequences need to match precisely. precedingKeys=${precedingKeys}.`\n          );\n          break;\n        }\n\n        return userDefinedRemappings.get(keySlice);\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given list of remappings, returns the length of the shortest and longest remapped keys\n   * @param remappings\n   */\n  protected static getRemappedKeysLengthRange(\n    remappings: ReadonlyMap<string, IKeyRemapping>\n  ): [number, number] {\n    if (remappings.size === 0) {\n      return [0, 0];\n    }\n    const keyLengths = Array.from(remappings.values()).map((remap) => remap.before.length);\n    return [Math.min(...keyLengths), Math.max(...keyLengths)];\n  }\n\n  /**\n   * Given list of keys and list of remappings, returns true if the keys are a potential remap\n   * @param keys the list of keys to be checked for potential remaps\n   * @param remappings The remappings Map\n   * @param countRemapAsPotential If the current keys are themselves a remap should they be considered a potential remap as well?\n   */\n  protected static hasPotentialRemap(\n    keys: string[],\n    remappings: ReadonlyMap<string, IKeyRemapping>,\n    countRemapAsPotential: boolean = false\n  ): boolean {\n    const keysAsString = keys.join('');\n    const re = /^<([^>]+)>/;\n    if (keysAsString !== '') {\n      for (const remap of remappings.keys()) {\n        if (remap.startsWith(keysAsString) && (remap !== keysAsString || countRemapAsPotential)) {\n          // Don't confuse a key combination starting with '<' that is not a special key like '<C-a>'\n          // with a remap that starts with a special key.\n          if (keysAsString.startsWith('<') && !re.test(keysAsString) && re.test(remap)) {\n            continue;\n          }\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n\nfunction keyBindingsConfigKey(mode: string): string {\n  return `${mode}ModeKeyBindingsMap`;\n}\n\nclass InsertModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('insert'), [Mode.Insert, Mode.Replace]);\n  }\n}\n\nclass NormalModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('normal'), [Mode.Normal]);\n  }\n}\n\nclass OperatorPendingModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('operatorPending'), [Mode.OperatorPendingMode]);\n  }\n}\n\nclass VisualModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('visual'), [Mode.Visual, Mode.VisualLine, Mode.VisualBlock]);\n  }\n}\n\nclass CommandLineModeRemapper extends Remapper {\n  constructor() {\n    super(keyBindingsConfigKey('commandLine'), [\n      Mode.CommandlineInProgress,\n      Mode.SearchInProgressMode,\n    ]);\n  }\n}\n","import { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { IConfiguration } from '../iconfiguration';\nimport { existsAsync } from 'platform/fs';\nimport { Globals } from '../../globals';\nimport { configurationValidator } from '../configurationValidator';\n\nexport class InputMethodSwitcherConfigurationValidator implements IConfigurationValidator {\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    const inputMethodConfig = config.autoSwitchInputMethod;\n\n    if (!inputMethodConfig.enable || Globals.isTesting) {\n      return Promise.resolve(result);\n    }\n\n    if (!inputMethodConfig.switchIMCmd.includes('{im}')) {\n      result.append({\n        level: 'error',\n        message:\n          'vim.autoSwitchInputMethod.switchIMCmd is incorrect, it should contain the placeholder {im}.',\n      });\n    }\n\n    if (inputMethodConfig.obtainIMCmd === undefined || inputMethodConfig.obtainIMCmd === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.obtainIMCmd is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.obtainIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.obtainIMCmd}. Check your 'vim.autoSwitchInputMethod.obtainIMCmd' in VSCode setting.`,\n      });\n    }\n\n    if (inputMethodConfig.defaultIM === undefined || inputMethodConfig.defaultIM === '') {\n      result.append({\n        level: 'error',\n        message: 'vim.autoSwitchInputMethod.defaultIM is empty.',\n      });\n    } else if (!(await existsAsync(this.getRawCmd(inputMethodConfig.switchIMCmd)))) {\n      result.append({\n        level: 'error',\n        message: `Unable to find ${inputMethodConfig.switchIMCmd}. Check your 'vim.autoSwitchInputMethod.switchIMCmd' in VSCode setting.`,\n      });\n    }\n\n    return Promise.resolve(result);\n  }\n\n  disable(config: IConfiguration) {\n    config.autoSwitchInputMethod.enable = false;\n  }\n\n  private getRawCmd(cmd: string): string {\n    return cmd.split(' ')[0];\n  }\n}\n\nconfigurationValidator.registerValidator(new InputMethodSwitcherConfigurationValidator());\n","import * as vscode from 'vscode';\nimport { IConfiguration, IKeyRemapping } from '../iconfiguration';\nimport { Notation } from '../notation';\nimport { IConfigurationValidator, ValidatorResults } from '../iconfigurationValidator';\nimport { configurationValidator } from '../configurationValidator';\nimport { PluginDefaultMappings } from '../../actions/plugins/pluginDefaultMappings';\n\nexport class RemappingValidator implements IConfigurationValidator {\n  private commandMap!: Map<string, boolean>;\n\n  async validate(config: IConfiguration): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n    const modeKeyBindingsKeys = [\n      'insertModeKeyBindings',\n      'insertModeKeyBindingsNonRecursive',\n      'normalModeKeyBindings',\n      'normalModeKeyBindingsNonRecursive',\n      'operatorPendingModeKeyBindings',\n      'operatorPendingModeKeyBindingsNonRecursive',\n      'visualModeKeyBindings',\n      'visualModeKeyBindingsNonRecursive',\n      'commandLineModeKeyBindings',\n      'commandLineModeKeyBindingsNonRecursive',\n    ];\n    for (const modeKeyBindingsKey of modeKeyBindingsKeys) {\n      const keybindings = config[modeKeyBindingsKey];\n      // add default mappings for activated plugins\n      // because we process keybindings backwards in next loop, user mapping will override\n      for (const pluginMapping of PluginDefaultMappings.getPluginDefaultMappings(\n        modeKeyBindingsKey,\n        config\n      )) {\n        // note concat(all mappings) does not work somehow\n        keybindings.push(pluginMapping);\n      }\n\n      const isRecursive = modeKeyBindingsKey.indexOf('NonRecursive') === -1;\n\n      const modeMapName = modeKeyBindingsKey.replace('NonRecursive', '');\n      let modeKeyBindingsMap = config[modeMapName + 'Map'] as Map<string, IKeyRemapping>;\n      if (!modeKeyBindingsMap) {\n        modeKeyBindingsMap = new Map<string, IKeyRemapping>();\n      }\n      for (let i = keybindings.length - 1; i >= 0; i--) {\n        const remapping = keybindings[i] as IKeyRemapping;\n\n        // set 'recursive' of the remapping according to where it was stored\n        remapping.recursive = isRecursive;\n\n        // validate\n        const remappingError = await this.isRemappingValid(remapping);\n        result.concat(remappingError);\n        if (remappingError.hasError) {\n          // errors with remapping, skip\n          keybindings.splice(i, 1);\n          continue;\n        }\n\n        // normalize\n        if (remapping.before) {\n          remapping.before.forEach(\n            (key, idx) => (remapping.before[idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        if (remapping.after) {\n          remapping.after.forEach(\n            (key, idx) => (remapping.after![idx] = Notation.NormalizeKey(key, config.leader))\n          );\n        }\n\n        // check for duplicates\n        const beforeKeys = remapping.before.join('');\n        if (modeKeyBindingsMap.has(beforeKeys)) {\n          result.append({\n            level: 'warning',\n            message: `${remapping.before}. Duplicate remapped key for ${beforeKeys}.`,\n          });\n          continue;\n        }\n\n        // add to map\n        modeKeyBindingsMap.set(beforeKeys, remapping);\n      }\n\n      config[modeMapName + 'Map'] = modeKeyBindingsMap;\n    }\n\n    return result;\n  }\n\n  disable(config: IConfiguration) {\n    // no-op\n  }\n\n  private async isRemappingValid(remapping: IKeyRemapping): Promise<ValidatorResults> {\n    const result = new ValidatorResults();\n\n    if (!remapping.after && !remapping.commands) {\n      result.append({\n        level: 'error',\n        message: `${remapping.before} missing 'after' key or 'command'.`,\n      });\n    }\n\n    if (!(remapping.before instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' should be a string array.`,\n      });\n    }\n\n    if (remapping.recursive === undefined) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.before}' missing 'recursive' info.`,\n      });\n    }\n\n    if (remapping.after && !(remapping.after instanceof Array)) {\n      result.append({\n        level: 'error',\n        message: `Remapping of '${remapping.after}' should be a string array.`,\n      });\n    }\n\n    if (remapping.commands) {\n      for (const command of remapping.commands) {\n        let cmd: string;\n\n        if (typeof command === 'string') {\n          cmd = command;\n        } else if (command.command) {\n          cmd = command.command;\n\n          if (!(await this.isCommandValid(cmd))) {\n            result.append({ level: 'warning', message: `${cmd} does not exist.` });\n          }\n        } else {\n          result.append({\n            level: 'error',\n            message: `Remapping of '${remapping.before}' has wrong \"commands\" structure. Should be 'string[] | { \"command\": string, \"args\": any[] }[]'.`,\n          });\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async isCommandValid(command: string): Promise<boolean> {\n    if (command.startsWith(':')) {\n      return true;\n    }\n\n    return (await this.getCommandMap()).has(command);\n  }\n\n  private async getCommandMap(): Promise<Map<string, boolean>> {\n    if (this.commandMap == null) {\n      this.commandMap = new Map(\n        (await vscode.commands.getCommands(true)).map((x) => [x, true] as [string, boolean])\n      );\n    }\n    return this.commandMap;\n  }\n}\n\nconfigurationValidator.registerValidator(new RemappingValidator());\n","interface IErrorMessage {\n  [index: number]: string;\n}\n\nexport enum ErrorCode {\n  InvalidAddress = 14,\n  InvalidRange = 16,\n  MarkNotSet = 20,\n  NoAlternateFile = 23,\n  NoInsertedTextYet = 29,\n  NoFileName = 32,\n  NoPreviousSubstituteRegularExpression = 33,\n  NoPreviousCommand = 34,\n  NoPreviousRegularExpression = 35,\n  NoWriteSinceLastChange = 37,\n  ErrorWritingToFile = 208,\n  FileNoLongerAvailable = 211,\n  RecursiveMapping = 223,\n  NoStringUnderCursor = 348,\n  NothingInRegister = 353,\n  InvalidRegisterName = 354,\n  SearchHitTop = 384,\n  SearchHitBottom = 385,\n  CannotCloseLastWindow = 444,\n  ArgumentRequired = 471,\n  InvalidArgument = 474,\n  NoRangeAllowed = 481,\n  PatternNotFound = 486,\n  TrailingCharacters = 488,\n  NotAnEditorCommand = 492,\n  NoBuffersDeleted = 516,\n  UnknownOption = 518,\n  NumberRequiredAfterEqual = 521,\n  AtStartOfChangeList = 662,\n  AtEndOfChangeList = 663,\n  ChangeListIsEmpty = 664,\n  NoPreviouslyUsedRegister = 748,\n}\n\nexport const ErrorMessage: IErrorMessage = {\n  14: 'Invalid address',\n  16: 'Invalid range',\n  20: 'Mark not set',\n  23: 'No alternate file',\n  29: 'No inserted text yet',\n  32: 'No file name',\n  33: 'No previous substitute regular expression',\n  34: 'No previous command',\n  35: 'No previous regular expression',\n  37: 'No write since last change (add ! to override)',\n  208: 'Error writing to file',\n  211: 'File no longer available', // TODO: Should be `File \"[file_name]\" no longer available`\n  223: 'Recursive mapping',\n  348: 'No string under cursor',\n  353: 'Nothing in register',\n  354: 'Invalid register name',\n  384: 'Search hit TOP without match for',\n  385: 'Search hit BOTTOM without match for',\n  444: 'Cannot close last window',\n  471: 'Argument required',\n  474: 'Invalid argument',\n  481: 'No range allowed',\n  486: 'Pattern not found',\n  488: 'Trailing characters',\n  492: 'Not an editor command',\n  516: 'No buffers were deleted',\n  518: 'Unknown option',\n  521: 'Number required after =',\n  662: 'At start of changelist',\n  663: 'At end of changelist',\n  664: 'changelist is empty',\n  748: 'No previously used register',\n};\n\nexport class VimError extends Error {\n  public readonly code: number;\n  public override readonly message: string;\n\n  private constructor(code: number, message: string) {\n    super();\n    this.code = code;\n    this.message = message;\n  }\n\n  static fromCode(code: ErrorCode, extraValue?: string): VimError {\n    if (ErrorMessage[code]) {\n      if (extraValue) {\n        if (code === ErrorCode.NothingInRegister) {\n          extraValue = ` ${extraValue}`;\n        } else {\n          extraValue = `: ${extraValue}`;\n        }\n      }\n      return new VimError(code, ErrorMessage[code] + (extraValue ?? ''));\n    }\n\n    throw new Error('unknown error code: ' + code);\n  }\n\n  override toString(): string {\n    return `E${this.code}: ${this.message}`;\n  }\n}\n\n/**\n * Used to stop a remapping or a chain of nested remappings after a VimError, a failed action\n * or the force stop recursive mapping key (<C-c> or <Esc>). (Vim doc :help map-error)\n */\nexport class ForceStopRemappingError extends Error {\n  constructor(reason: string = 'StopRemapping') {\n    super(reason);\n  }\n\n  static fromVimError(vimError: VimError): ForceStopRemappingError {\n    return new ForceStopRemappingError(vimError.toString());\n  }\n}\n","import { IConfiguration } from './configuration/iconfiguration';\n\n/**\n * Global variables shared throughout extension\n */\nexport class Globals {\n  /**\n   * This is where we put files like HistoryFile. The path is given to us by VSCode.\n   */\n  static extensionStoragePath: string;\n\n  /**\n   * Used for testing.\n   */\n  static isTesting = false;\n  static mockConfiguration: IConfiguration;\n}\n","import { ExtensionContext } from 'vscode';\nimport { Logger } from '../util/logger';\nimport { configuration } from '../configuration/configuration';\nimport { Globals } from '../globals';\nimport { HistoryBase } from 'platform/history';\n\n// TODO(jfields): What's going on here? Just combine HistoryFile and HistoryBase...\nexport class HistoryFile {\n  private readonly logger = Logger.get('HistoryFile');\n  private base: HistoryBase;\n\n  get historyFilePath(): string {\n    return this.base.historyKey;\n  }\n\n  constructor(context: ExtensionContext, historyFileName: string) {\n    this.base = new HistoryBase(\n      context,\n      historyFileName,\n      Globals.extensionStoragePath,\n      this.logger\n    );\n  }\n\n  public async add(value: string | undefined): Promise<void> {\n    return this.base.add(value, configuration.history);\n  }\n\n  public get(): string[] {\n    return this.base.get(configuration.history);\n  }\n\n  public clear() {\n    this.base.clear();\n  }\n\n  public async load(): Promise<void> {\n    await this.base.load();\n  }\n}\n\nexport class SearchHistory extends HistoryFile {\n  constructor(context: ExtensionContext) {\n    super(context, '.search_history');\n  }\n}\n\nexport class CommandLineHistory extends HistoryFile {\n  constructor(context: ExtensionContext) {\n    super(context, '.cmdline_history');\n  }\n}\n","/**\n * HistoryTracker is a handrolled undo/redo tracker for VSC. We currently\n * track history as a list of \"steps\", each of which consists of 1 or more\n * \"changes\".\n *\n * A Change is something like adding or deleting a few letters.\n *\n * A Step is multiple Changes.\n *\n * Undo/Redo will advance forward or backwards through Steps.\n */\nimport DiffMatchPatch = require('diff-match-patch');\nimport * as vscode from 'vscode';\n\nimport { VimState } from './../state/vimState';\nimport { TextEditor } from './../textEditor';\nimport { StatusBar } from '../statusBar';\nimport { Position } from 'vscode';\nimport { Jump } from '../jumps/jump';\nimport { globalState } from '../state/globalState';\nimport { Mode } from '../mode/mode';\nimport { ErrorCode, VimError } from '../error';\nimport { Logger } from '../util/logger';\nimport { earlierOf } from '../common/motion/position';\n\nconst diffEngine = new DiffMatchPatch.diff_match_patch();\ndiffEngine.Diff_Timeout = 1; // 1 second\n\nconst logger = Logger.get('HistoryTracker');\n\nclass DocumentChange {\n  /**\n   * The Position at which this change starts\n   */\n  public readonly start: Position;\n\n  /**\n   * The text that existed before this change\n   */\n  public readonly before: string;\n\n  /**\n   * The text that exists after this change\n   */\n  public readonly after: string;\n\n  public static insert(start: Position, text: string) {\n    return new DocumentChange(start, '', text);\n  }\n\n  public static delete(start: Position, text: string) {\n    return new DocumentChange(start, text, '');\n  }\n\n  public static replace(start: Position, before: string, after: string) {\n    return new DocumentChange(start, before, after);\n  }\n\n  /**\n   * @returns A new DocumentChange that represents undoing this change\n   */\n  public reversed() {\n    return DocumentChange.replace(this.start, this.after, this.before);\n  }\n\n  private constructor(start: Position, before: string, after: string) {\n    this.start = start;\n    this.before = before;\n    this.after = after;\n  }\n\n  /**\n   * Run this change.\n   */\n  public async do(editor: vscode.TextEditor): Promise<void> {\n    await TextEditor.replace(editor, this.beforeRange, this.after);\n  }\n\n  /**\n   * Run this change in reverse.\n   */\n  public async undo(editor: vscode.TextEditor): Promise<void> {\n    await TextEditor.replace(editor, this.afterRange, this.before);\n  }\n\n  /**\n   * The Range that the before text occupied\n   */\n  public get beforeRange(): vscode.Range {\n    return new vscode.Range(this.start, this.start.advancePositionByText(this.before));\n  }\n\n  /**\n   * The Range that the after text occupies\n   */\n  public get afterRange(): vscode.Range {\n    return new vscode.Range(this.start, this.start.advancePositionByText(this.after));\n  }\n}\n\nexport interface IMark {\n  name: string;\n  position: Position;\n  isUppercaseMark: boolean;\n  document?: vscode.TextDocument; // only required when using global marks (isUppercaseMark is true)\n}\n\n/**\n * An undo's worth of changes; generally corresponds to a single action.\n */\nclass HistoryStep {\n  /**\n   * The insertions and deletions that occured in this history step.\n   */\n  public changes: DocumentChange[];\n\n  /**\n   * Whether the user is still inserting or deleting for this history step.\n   */\n  public isFinished = false;\n\n  /**\n   * When this step was finished.\n   * // TODO: we currently set it to the current time upon creation to cover some edge cases, but this is messy.\n   */\n  public timestamp: Date;\n\n  /**\n   * The cursor position at the start of this history step.\n   * Restored by `u`. Currently, only one cursor is remembered.\n   */\n  public cursorStart: Position | undefined;\n\n  /**\n   * The position of every mark at the start of this history step.\n   */\n  public marks: IMark[] = [];\n\n  /**\n   * HACK: true if this step came from `U`.\n   * In `UU`, the second `U` should undo the first, and no more.\n   */\n  public readonly cameFromU: boolean;\n\n  /**\n   * \"global\" marks which operate across files. (when IMark.name is uppercase)\n   */\n  static globalMarks: IMark[] = [];\n\n  constructor(init: { marks: IMark[]; changes?: DocumentChange[]; cameFromU?: boolean }) {\n    this.changes = init.changes ?? [];\n    this.marks = init.marks ?? [];\n    this.cameFromU = init.cameFromU ?? false;\n\n    // This will usually be overwritten when the HistoryStep is finished\n    this.timestamp = new Date();\n  }\n\n  /**\n   * Collapse individual character changes into larger blocks of changes\n   */\n  public merge(document: vscode.TextDocument): void {\n    if (this.changes.length < 2) {\n      return;\n    }\n\n    // merged will replace this.changes\n    const merged: DocumentChange[] = [];\n    // manually reduce() this.changes with variables `current` and `next`\n    // we can't use reduce() directly because the loop can emit multiple elements\n    let current = this.changes[0];\n    for (const next of this.changes.slice(1)) {\n      if (current.before.length + current.after.length === 0) {\n        // current is eliminated, replace it with top of merged, or adopt next as current\n        // see also add+del case\n        if (merged.length > 0) {\n          current = merged.pop()!;\n        } else {\n          current = next;\n          continue;\n        }\n      }\n\n      const intersect = current.afterRange.intersection(next.beforeRange);\n      if (intersect) {\n        const [first, second] = current.start.isBeforeOrEqual(next.start)\n          ? [current, next]\n          : [next, current];\n        const intersectLength =\n          document.offsetAt(intersect.end) - document.offsetAt(intersect.start);\n        current = DocumentChange.replace(\n          first.start,\n          first.before + second.before.slice(intersectLength),\n          first.after.slice(0, first.after.length - intersectLength) + second.after\n        );\n      } else {\n        merged.push(current);\n        current = next;\n      }\n    }\n    merged.push(current);\n    this.changes = merged;\n  }\n\n  /**\n   * Returns, as a string, the time that has passed since this step took place.\n   */\n  public howLongAgo(): string {\n    const now = new Date();\n    const timeDiffMillis = now.getTime() - this.timestamp.getTime();\n    const timeDiffSeconds = Math.floor(timeDiffMillis / 1000);\n    if (timeDiffSeconds === 1) {\n      return `1 second ago`;\n    } else if (timeDiffSeconds >= 100) {\n      const hours = this.timestamp.getHours();\n      const minutes = this.timestamp.getMinutes().toString().padStart(2, '0');\n      const seconds = this.timestamp.getSeconds().toString().padStart(2, '0');\n      return `${hours}:${minutes}:${seconds}`;\n    } else {\n      return `${timeDiffSeconds} seconds ago`;\n    }\n  }\n}\n\n/**\n * A simple wrapper around a list of HistorySteps, for sanity's sake\n */\nclass UndoStack {\n  private historySteps: HistoryStep[] = [];\n  private currentStepIndex = -1;\n\n  // The marks as they existed before the first HistoryStep\n  private initialMarks: IMark[] = [];\n\n  public getHistoryStepAtIndex(idx: number): HistoryStep | undefined {\n    return this.historySteps[idx];\n  }\n\n  public getCurrentHistoryStepIndex(): number {\n    return this.currentStepIndex;\n  }\n\n  public getStackDepth(): number {\n    return this.historySteps.length;\n  }\n\n  /**\n   * @returns the current HistoryStep, or undefined if nothing's been done yet\n   */\n  public getCurrentHistoryStep(): HistoryStep | undefined {\n    if (this.currentStepIndex === -1) {\n      return undefined;\n    }\n\n    return this.historySteps[this.currentStepIndex];\n  }\n\n  /**\n   * Goes forward in time (redo), if possible\n   *\n   * @returns the new current HistoryStep, or undefined if none exists\n   */\n  public stepForward(): HistoryStep | undefined {\n    if (this.currentStepIndex === this.historySteps.length - 1) {\n      return undefined;\n    }\n\n    this.currentStepIndex++;\n    return this.getCurrentHistoryStep();\n  }\n\n  /**\n   * Goes backward in time (undo), if possible\n   *\n   * @returns the old HistoryStep, or undefined if there was none\n   */\n  public stepBackward(): HistoryStep | undefined {\n    const step = this.getCurrentHistoryStep();\n    if (step) {\n      this.currentStepIndex--;\n    }\n    return step;\n  }\n\n  /**\n   * Adds a change to the current unfinished step if there is one, or a new step if there isn't\n   */\n  public pushChange(change: DocumentChange): void {\n    let step = this.getCurrentHistoryStep();\n    if (step === undefined || step.isFinished) {\n      this.currentStepIndex++;\n      this.historySteps.splice(this.currentStepIndex);\n      step = new HistoryStep({\n        marks: step?.marks ?? this.initialMarks,\n      });\n      this.historySteps.push(step);\n    }\n\n    step.changes.push(change);\n  }\n\n  /**\n   * You probably don't want to use this.\n   * @see pushChange\n   */\n  public pushHistoryStep(step: HistoryStep) {\n    this.currentStepIndex++;\n    this.historySteps.splice(this.currentStepIndex + 1);\n    this.historySteps.push(step);\n  }\n\n  public getCurrentMarkList(): IMark[] {\n    const step = this.getCurrentHistoryStep();\n    return step?.marks ?? this.initialMarks;\n  }\n\n  public removeMarks(marks?: string[]): void {\n    const step = this.getCurrentHistoryStep();\n    if (marks === undefined) {\n      if (step) {\n        step.marks = [];\n      } else {\n        this.initialMarks = [];\n      }\n    } else {\n      if (step) {\n        step.marks = step.marks.filter((m) => !marks.includes(m.name));\n      } else {\n        this.initialMarks = this.initialMarks.filter((m) => !marks.includes(m.name));\n      }\n    }\n  }\n}\n\nclass ChangeList {\n  private readonly changeLocations: Position[] = [];\n  private index: number | undefined;\n\n  public addChangePosition(position: Position) {\n    if (\n      this.changeLocations.length > 0 &&\n      this.changeLocations[this.changeLocations.length - 1].line === position.line\n    ) {\n      this.changeLocations[this.changeLocations.length - 1] = position;\n    } else {\n      this.changeLocations.push(position);\n    }\n\n    this.index = undefined;\n  }\n\n  public nextChangePosition(): Position | VimError {\n    if (this.index === undefined) {\n      if (this.changeLocations.length === 0) {\n        return VimError.fromCode(ErrorCode.ChangeListIsEmpty);\n      }\n      this.index = this.changeLocations.length - 1;\n      return this.changeLocations[this.index];\n    } else if (this.index < this.changeLocations.length - 1) {\n      this.index++;\n      return this.changeLocations[this.index];\n    } else {\n      return VimError.fromCode(ErrorCode.AtEndOfChangeList);\n    }\n  }\n\n  public prevChangePosition(): Position | VimError {\n    if (this.index === undefined) {\n      if (this.changeLocations.length === 0) {\n        return VimError.fromCode(ErrorCode.ChangeListIsEmpty);\n      }\n      this.index = this.changeLocations.length - 1;\n      return this.changeLocations[this.index];\n    } else if (this.index > 0) {\n      this.index--;\n      return this.changeLocations[this.index];\n    } else {\n      return VimError.fromCode(ErrorCode.AtStartOfChangeList);\n    }\n  }\n}\n\nexport class HistoryTracker {\n  public lastContentChanges: vscode.TextDocumentContentChangeEvent[];\n  public currentContentChanges: vscode.TextDocumentContentChangeEvent[];\n\n  private nextStepStartPosition: Position | undefined;\n\n  private readonly undoStack: UndoStack;\n\n  private readonly changeList: ChangeList;\n\n  /**\n   * The state of the document the last time HistoryTracker.addChange() or HistoryTracker.ignoreChange() was called.\n   * This is used to avoid retrieiving the document text and doing a full diff when it isn't necessary.\n   */\n  private previousDocumentState: {\n    text: string;\n    versionNumber: number;\n  };\n\n  private readonly vimState: VimState;\n\n  constructor(vimState: VimState) {\n    this.vimState = vimState;\n    this.undoStack = new UndoStack();\n    this.changeList = new ChangeList();\n    this.previousDocumentState = {\n      text: this.getDocumentText(),\n      versionNumber: this.getDocumentVersion(),\n    };\n    this.lastContentChanges = [];\n    this.currentContentChanges = [];\n  }\n\n  private getDocumentText(): string {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.getText() ?? '';\n  }\n\n  private getDocumentVersion(): number {\n    // vimState.editor can be undefined in some unit tests\n    return this.vimState.editor?.document.version ?? -1;\n  }\n\n  /**\n   * Marks refer to relative locations in the document, rather than absolute ones.\n   *\n   * This big gnarly method updates our marks such that they continue to mark\n   * the same character when the user does a document edit that would move the\n   * text that was marked.\n   */\n  private updateAndReturnMarks(): IMark[] {\n    const previousMarks = this.getAllCurrentDocumentMarks();\n    const newMarks: IMark[] = [];\n\n    // clone old marks into new marks\n    for (const mark of previousMarks) {\n      newMarks.push({ ...mark });\n    }\n\n    for (const change of this.undoStack.getCurrentHistoryStep()?.changes ?? []) {\n      for (const newMark of newMarks) {\n        // Run through each character added/deleted, and see if it could have\n        // affected the position of this mark.\n\n        let pos = change.start;\n\n        // Pull mark back with deleted text\n        for (const ch of change.before.replace(/\\r/g, '')) {\n          if (pos.isBefore(newMark.position)) {\n            if (ch === '\\n') {\n              newMark.position = new Position(\n                Math.max(newMark.position.line - 1, 0),\n                newMark.position.character\n              );\n            } else if (pos.line === newMark.position.line) {\n              newMark.position = new Position(\n                newMark.position.line,\n                Math.max(newMark.position.character - 1, 0)\n              );\n            }\n          }\n\n          if (ch === '\\n') {\n            // The 99999 is a bit of a hack here. It's very difficult and\n            // completely unnecessary to get the correct position, so we\n            // just fake it.\n            pos = new Position(Math.max(pos.line - 1, 0), 99999);\n          } else {\n            pos = new Position(pos.line, Math.max(pos.character - 1, 0));\n          }\n        }\n\n        pos = change.start;\n\n        // Push mark forward with added text\n        for (const ch of change.after.replace(/\\r/g, '')) {\n          if (pos.isBeforeOrEqual(newMark.position)) {\n            if (ch === '\\n') {\n              newMark.position = new Position(\n                newMark.position.line + 1,\n                newMark.position.character\n              );\n            } else if (pos.line === newMark.position.line) {\n              newMark.position = new Position(\n                newMark.position.line,\n                newMark.position.character + 1\n              );\n            }\n          }\n\n          if (ch === '\\n') {\n            pos = new Position(pos.line + 1, 0);\n          } else {\n            pos = new Position(pos.line, pos.character + 1);\n          }\n        }\n      }\n    }\n\n    // Ensure the position of every mark is within the range of the document.\n\n    const docEnd = TextEditor.getDocumentEnd(this.vimState.document);\n    for (const mark of newMarks) {\n      if (mark.position.isAfter(docEnd)) {\n        mark.position = docEnd;\n      }\n    }\n\n    return newMarks;\n  }\n\n  /**\n   * @returns the shared static list if isFileMark is true, otherwise returns the currentHistoryStep.marks.\n   */\n  private getMarkList(isFileMark: boolean): IMark[] {\n    return isFileMark ? HistoryStep.globalMarks : this.undoStack.getCurrentMarkList();\n  }\n\n  /**\n   * @returns all local and global marks in this editor\n   */\n  private getAllCurrentDocumentMarks(): IMark[] {\n    const globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.document === vscode.window.activeTextEditor?.document\n    );\n    return [...this.getLocalMarks(), ...globalMarks];\n  }\n\n  /**\n   * Adds a mark.\n   */\n  public addMark(position: Position, markName: string): void {\n    // Sets previous context mark (adds current position to jump list).\n\n    if (markName === \"'\" || markName === '`') {\n      return globalState.jumpTracker.recordJump(Jump.fromStateNow(this.vimState));\n    }\n\n    const isUppercaseMark = markName.toUpperCase() === markName;\n    const newMark: IMark = {\n      position,\n      name: markName,\n      isUppercaseMark,\n      document: isUppercaseMark ? vscode.window.activeTextEditor?.document : undefined,\n    };\n    this.putMarkInList(newMark);\n  }\n\n  /**\n   * Puts the mark into either the global or local marks array depending on mark.isUppercaseMark.\n   */\n  private putMarkInList(mark: IMark): void {\n    const marks = this.getMarkList(mark.isUppercaseMark);\n    const previousIndex = marks.findIndex((existingMark) => existingMark.name === mark.name);\n    if (previousIndex !== -1) {\n      marks[previousIndex] = mark;\n    } else {\n      marks.push(mark);\n    }\n  }\n\n  /**\n   * Retrieves a mark from either the global or local array depending on mark.isUppercaseMark.\n   */\n  public getMark(name: string): IMark | undefined {\n    // First, handle \"special\" marks\n    let position: Position | undefined;\n    if (name === '<') {\n      const linewise = this.vimState.lastVisualSelection?.mode === Mode.VisualLine;\n      position = linewise\n        ? this.vimState.lastVisualSelection?.start.with({ character: 0 })\n        : this.vimState.lastVisualSelection?.start;\n    } else if (name === '>') {\n      const linewise = this.vimState.lastVisualSelection?.mode === Mode.VisualLine;\n      position = linewise\n        ? this.vimState.lastVisualSelection?.end.getLineEnd()\n        : this.vimState.lastVisualSelection?.end.getLeft();\n    } else if (name === '[') {\n      position = this.getLastChangeStartPosition();\n    } else if (name === ']') {\n      position = this.getLastChangeEndPosition();\n    } else if (name === '.') {\n      position = this.getLastHistoryStartPosition();\n    } else if (name === \"'\" || name === '`') {\n      position = globalState.jumpTracker.end?.position;\n    }\n    if (position) {\n      return {\n        name,\n        position,\n        isUppercaseMark: false,\n      };\n    }\n\n    const marks = this.getMarkList(name.toUpperCase() === name);\n    return marks.find((mark) => mark.name === name);\n  }\n\n  /**\n   * Removes all local marks.\n   */\n  public removeLocalMarks(): void {\n    this.undoStack.removeMarks();\n  }\n\n  /**\n   * Removes all marks matching from either the global or local array.\n   */\n  public removeMarks(markNames: string[]): void {\n    if (markNames.length === 0) {\n      return;\n    }\n\n    this.undoStack.removeMarks(markNames);\n\n    HistoryStep.globalMarks = HistoryStep.globalMarks.filter(\n      (mark) => mark.name === '' || !markNames.includes(mark.name)\n    );\n  }\n\n  /**\n   * Gets all local marks.  I.e., marks that are specific for the current\n   * editor.\n   */\n  public getLocalMarks(): IMark[] {\n    return [...this.undoStack.getCurrentMarkList()];\n  }\n\n  /**\n   * Gets all global marks.  I.e., marks that are shared among all editors.\n   */\n  public getGlobalMarks(): IMark[] {\n    return [...HistoryStep.globalMarks];\n  }\n\n  public getMarks(): IMark[] {\n    return [...this.getLocalMarks(), ...HistoryStep.globalMarks];\n  }\n\n  /**\n   * Adds an individual Change to the current Step.\n   *\n   * Determines what changed by diffing the document against what it used to look like.\n   */\n  public addChange(force: boolean = false): void {\n    if (this.getDocumentVersion() === this.previousDocumentState.versionNumber) {\n      return;\n    }\n\n    if (this.nextStepStartPosition === undefined) {\n      const cursor = this.vimState.cursorsInitialState[0];\n      this.nextStepStartPosition = earlierOf(cursor.start, cursor.stop);\n      logger.debug(`Set nextStepStartPosition to ${this.nextStepStartPosition}`);\n    }\n\n    if (\n      !force &&\n      (this.vimState.currentMode === Mode.Insert || this.vimState.currentMode === Mode.Replace)\n    ) {\n      // We can ignore changes while we're in insert/replace mode, since we can't interact with them (via undo, etc.) until we're back to normal mode\n      // This allows us to avoid a little bit of work per keystroke, but more importantly, it means we'll get bigger contiguous edit chunks to merge.\n      // This is particularly impactful when there are multiple cursors, which are otherwise difficult to optimize.\n      return;\n    }\n\n    const newText = this.getDocumentText();\n    if (newText === this.previousDocumentState.text) {\n      return;\n    }\n\n    // TODO: This is actually pretty stupid! Since we already have the cursorPosition,\n    // and most diffs are just +/- a few characters, we can just do a direct comparison rather\n    // than using jsdiff.\n\n    // The difficulty is with a few rare commands like :%s/one/two/g that make\n    // multiple changes in different places simultaneously. For those, we could require\n    // them to call addChange manually, I guess...\n\n    const diffs = diffEngine.diff_main(this.previousDocumentState.text, newText);\n    diffEngine.diff_cleanupEfficiency(diffs);\n\n    let currentPosition = new Position(0, 0);\n\n    for (const diff of diffs) {\n      const [whatHappened, text] = diff;\n      const added = whatHappened === DiffMatchPatch.DIFF_INSERT;\n      const removed = whatHappened === DiffMatchPatch.DIFF_DELETE;\n\n      if (added || removed) {\n        this.undoStack.pushChange(\n          added\n            ? DocumentChange.insert(currentPosition, text)\n            : DocumentChange.delete(currentPosition, text)\n        );\n      }\n\n      if (!removed) {\n        currentPosition = currentPosition.advancePositionByText(text);\n      }\n    }\n\n    this.previousDocumentState = {\n      text: newText,\n      versionNumber: this.getDocumentVersion(),\n    };\n  }\n\n  /**\n   * Tells the HistoryTracker that although the document has changed, we should simply\n   * ignore that change. Most often used when the change was itself triggered by\n   * the HistoryTracker.\n   */\n  public ignoreChange(): void {\n    this.previousDocumentState = {\n      text: this.getDocumentText(),\n      versionNumber: this.getDocumentVersion(),\n    };\n  }\n\n  /**\n   * Until we mark it as finished, the active Step will\n   * accrue multiple changes. This function will mark it as finished,\n   * and the next time we add a change, it'll be added to a new Step.\n   */\n  public finishCurrentStep(): void {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep && !currentHistoryStep.isFinished) {\n      currentHistoryStep.isFinished = true;\n      currentHistoryStep.timestamp = new Date();\n\n      currentHistoryStep.cursorStart ??= this.nextStepStartPosition;\n      this.nextStepStartPosition = undefined;\n\n      currentHistoryStep.merge(this.vimState.document);\n\n      currentHistoryStep.marks = this.updateAndReturnMarks();\n\n      const changes = currentHistoryStep.changes;\n      if (changes) {\n        const changePos = changes[0].after ? changes[0].afterRange.end.getLeft() : changes[0].start;\n        this.changeList.addChangePosition(changePos);\n      }\n\n      logger.debug(`Finished history step with ${changes.length} change(s)`);\n    }\n  }\n\n  /**\n   * Undo the current HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to undo\n   */\n  public async goBackHistoryStep(): Promise<Position | undefined> {\n    const step = this.undoStack.stepBackward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    for (const change of step.changes.slice(0).reverse()) {\n      await change.undo(this.vimState.editor);\n    }\n\n    this.ignoreChange();\n\n    // TODO: if there are more/fewer lines after undoing the change, it should say so\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; before #${this.undoStack.getCurrentHistoryStepIndex() + 1}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Redo the next HistoryStep, if there is one\n   *\n   * @returns the new cursor positions, or undefined if there are no steps to redo\n   */\n  public async goForwardHistoryStep(): Promise<Position | undefined> {\n    const step = this.undoStack.stepForward();\n    if (step === undefined) {\n      return undefined;\n    }\n\n    // TODO: do these transformations in a batch\n    for (const change of step.changes) {\n      await change.do(this.vimState.editor);\n    }\n\n    this.ignoreChange();\n\n    const changes = step.changes.length === 1 ? `1 change` : `${step.changes.length} changes`;\n    StatusBar.setText(\n      this.vimState,\n      `${changes}; after #${this.undoStack.getCurrentHistoryStepIndex()}  ${step.howLongAgo()}`\n    );\n\n    return step.cursorStart;\n  }\n\n  /**\n   * Logic for command U.\n   *\n   * Performs an undo action for all changes which occurred on\n   * the same line as the most recent change.\n   * Returns undefined if there's no more steps back to go.\n   * Only acts upon consecutive changes on the most-recently-changed line.\n   * U itself is a change, so all the changes are reversed and added back\n   * to the history.\n   *\n   * This method contains a significant amount of extra logic to account for\n   * the difficult scenario where a newline is embedded in a change (ex: '\\nhello'), which\n   * is created by the 'o' command. Vim behavior for the 'U' command does\n   * not undo newlines, so the change text needs to be checked & trimmed.\n   * This worst-case scenario tends to offset line values and make it harder to\n   * determine the line of the change, so this behavior is also compensated.\n   */\n  public async goBackHistoryStepsOnLine(): Promise<Position | undefined> {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    let done: boolean = false;\n    const changesToUndo: DocumentChange[] = [];\n\n    let lastChange = currentHistoryStep.changes[currentHistoryStep.changes.length - 1];\n    const undoLine = lastChange.afterRange.end.line;\n\n    for (let stepIdx = this.undoStack.getCurrentHistoryStepIndex(); stepIdx >= 0; stepIdx--) {\n      const step = this.undoStack.getHistoryStepAtIndex(stepIdx)!;\n      for (let change of [...step.changes].reverse()) {\n        /*\n         * This conditional accounts for the behavior where the change is a newline\n         * followed by text to undo. Note the line offset behavior that must be compensated.\n         */\n        const newlines = [...change.after.matchAll(/\\n/g)];\n        if (newlines.length > 0 && change.start.line + newlines.length === undoLine) {\n          // Modify & replace the change to avoid undoing the newline embedded in the change\n          change = DocumentChange.insert(\n            new Position(change.start.line + 1, 0),\n            change.after.slice(change.after.lastIndexOf('\\n'))\n          );\n          done = true;\n        } else if (newlines.length > 0 || change.start.line !== undoLine) {\n          done = true;\n          break;\n        }\n\n        changesToUndo.push(change);\n        lastChange = change;\n        if (done) {\n          break;\n        }\n      }\n      if (step.cameFromU) {\n        done = true;\n      }\n      if (done) {\n        break;\n      }\n    }\n\n    if (changesToUndo.length > 0) {\n      for (const change of changesToUndo) {\n        await change.undo(this.vimState.editor);\n      }\n\n      const newStep = new HistoryStep({\n        marks: this.undoStack.getCurrentMarkList(),\n        changes: changesToUndo.map((change) => change.reversed()).reverse(),\n        cameFromU: true,\n      });\n      this.nextStepStartPosition = lastChange.start;\n      this.undoStack.pushHistoryStep(newStep);\n\n      this.finishCurrentStep();\n    }\n\n    this.ignoreChange();\n\n    /*\n     * Unlike the goBackHistoryStep() function, this function does not trust the\n     * HistoryStep.cursorStart property. This can lead to invalid cursor position errors.\n     * Since this function reverses change-by-change, rather than step-by-step,\n     * the cursor position is based on the start of the last change that is undone.\n     */\n    return lastChange?.start;\n  }\n\n  /**\n   * Gets the ending cursor position of the last Change of the last Step.\n   *\n   * In practice, this sets the cursor position to the end of\n   * the most recent text change.\n   */\n  public getLastChangeEndPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const lastChangeIndex = currentHistoryStep.changes.length;\n    if (lastChangeIndex === 0) {\n      return undefined;\n    }\n\n    const lastChange = currentHistoryStep.changes[lastChangeIndex - 1];\n    return lastChange.afterRange.end;\n  }\n\n  public getLastHistoryStartPosition(): Position | undefined {\n    return this.undoStack.getCurrentHistoryStep()?.cursorStart;\n  }\n\n  private getLastChangeStartPosition(): Position | undefined {\n    const currentHistoryStep = this.undoStack.getCurrentHistoryStep();\n    if (currentHistoryStep === undefined) {\n      return undefined;\n    }\n\n    const changes = currentHistoryStep.changes;\n    if (changes.length === 0) {\n      return undefined;\n    }\n\n    return changes[changes.length - 1].start;\n  }\n\n  /**\n   * Logic for `g,` command\n   */\n  public nextChangeInChangeList(): Position | VimError {\n    return this.changeList.nextChangePosition();\n  }\n\n  /**\n   * Logic for `g;` command\n   */\n  public prevChangeInChangeList(): Position | VimError {\n    return this.changeList.prevChangePosition();\n  }\n\n  /**\n   * Handy for debugging the undo/redo stack. + means our current position, check means active.\n   */\n  public toString(): string {\n    let result = '';\n\n    for (let i = 0; i < this.undoStack.getStackDepth(); i++) {\n      const step = this.undoStack.getHistoryStepAtIndex(i)!;\n\n      result += step.changes\n        .map((x) => `${x.before.replace(/\\n/g, '\\\\n')} => ${x.after.replace(/\\n/g, '\\\\n')}`)\n        .join('');\n      if (i === this.undoStack.getCurrentHistoryStepIndex()) {\n        result += '+';\n      }\n      if (step.isFinished) {\n        result += '';\n      }\n      result += '| ';\n    }\n\n    return result;\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nimport { VimState } from '../state/vimState';\n\n/**\n * Represents a Jump in the JumpTracker.\n * Includes information necessary to determine jump actions,\n * and to be able to open the related file.\n */\nexport class Jump {\n  public readonly document: vscode.TextDocument;\n  public readonly position: Position;\n\n  /**\n   *\n   * @param options\n   * @param options.editor - The editor associated with the jump.\n   * @param options.position - The line and column number information.\n   */\n  constructor({ document, position }: { document: vscode.TextDocument; position: Position }) {\n    this.document = document;\n    this.position = position;\n  }\n\n  public get fileName() {\n    return this.document.fileName;\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's current cursor position.\n   * @param vimState - State that contains the fileName and position for the jump\n   */\n  public static fromStateNow(vimState: VimState) {\n    return new Jump({\n      document: vimState.document,\n      position: vimState.cursorStopPosition,\n    });\n  }\n\n  /**\n   * Factory method for creating a Jump from a VimState's cursor position,\n   * before any actions or commands were performed.\n   * @param vimState - State that contains the fileName and prior position for the jump\n   */\n  public static fromStateBefore(vimState: VimState) {\n    return new Jump({\n      document: vimState.document,\n      position: vimState.cursorsInitialState[0].stop,\n    });\n  }\n\n  /**\n   * Determine whether another jump matches the same file path, line number, and character column.\n   * @param other - Another Jump to compare against\n   */\n  public isSamePosition(other: Jump): boolean {\n    return this.fileName === other.fileName && this.position.isEqual(other.position);\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { FileCommand } from './../cmd_line/commands/file';\nimport { VimState } from '../state/vimState';\n\nimport { Jump } from './jump';\nimport { existsAsync } from 'platform/fs';\nimport { Position } from 'vscode';\nimport { ErrorCode, VimError } from '../error';\n\nconst MAX_JUMPS = 100;\n\n/**\n * JumpTracker is a handrolled version of VSCode's TextEditorState\n * in relation to the 'workbench.action.navigateBack' command.\n */\nexport class JumpTracker {\n  private _jumps: Jump[] = [];\n  private _currentJumpNumber = 0;\n\n  /**\n   * When receiving vscode.window.onDidChangeActiveTextEditor messages,\n   * don't record the jump if we initiated the command.\n   *\n   * Either the jump was added, or it was traversing jump history\n   * and shouldn't count as a new jump.\n   */\n  public isJumpingThroughHistory = false;\n\n  /**\n   * All recorded jumps, in the order of occurrence.\n   */\n  public get jumps(): Jump[] {\n    return this._jumps;\n  }\n\n  /**\n   * Current position in the list of jumps.\n   * This will be past last index if not traveling through history.\n   */\n  public get currentJumpNumber(): number {\n    return this._currentJumpNumber;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get currentJump(): Jump {\n    return this._jumps[this._currentJumpNumber] || null;\n  }\n\n  /**\n   * Current jump in the list of jumps.\n   */\n  public get hasJumps(): boolean {\n    return this._jumps.length > 0;\n  }\n\n  /**\n   * Last jump in list of jumps.\n   */\n  public get end(): Jump | null {\n    return this._jumps[this._jumps.length - 1];\n  }\n\n  /**\n   * Record that a jump occurred.\n   *\n   * If the current position is back in history,\n   * jumps after this position will be removed.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public recordJump(from: Jump, to?: Jump) {\n    if (to && from.isSamePosition(to)) {\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  /**\n   * Record that a jump occurred from one file to another.\n   * This is likely only needed on a handler for\n   * vscode.window.onDidChangeActiveTextEditor.\n   *\n   * File jumps have extra checks in place, keeping in mind\n   * whether this plugin initiated the jump, whether the new file is\n   * a legitimate file.\n   *\n   * @param from - File/position jumped from\n   * @param to - File/position jumped to\n   */\n  public handleFileJump(from: Jump | null, to: Jump) {\n    if (this.isJumpingThroughHistory) {\n      this.isJumpingThroughHistory = false;\n      return;\n    }\n\n    if (to.document.isClosed) {\n      // Wallaby.js seemed to be adding an extra file jump, named e.g. extension-output-#4\n      // It was marked closed when jumping to it. Hopefully we can rely on checking isClosed\n      // when extensions get all weird on us.\n      return;\n    }\n\n    this.pushJump(from, to);\n  }\n\n  private async performFileJump(jump: Jump, vimState: VimState): Promise<void> {\n    this.isJumpingThroughHistory = true;\n\n    if (jump.document) {\n      try {\n        // Open jump file from stored editor\n        await vscode.window.showTextDocument(jump.document);\n      } catch (e: unknown) {\n        // This can happen when the document we'd like to jump to is weird (like a search editor) or has been deleted\n        throw VimError.fromCode(ErrorCode.FileNoLongerAvailable);\n      }\n    } else if (await existsAsync(jump.fileName)) {\n      // Open jump file from disk\n      await new FileCommand({\n        name: 'edit',\n        bang: false,\n        opt: [],\n        file: jump.fileName,\n        cmd: { type: 'line_number', line: jump.position.line },\n        createFileIfNotExists: false,\n      }).execute(vimState);\n    } else {\n      // Get jump file from visible editors\n      const editor: vscode.TextEditor = vscode.window.visibleTextEditors.filter(\n        (e) => e.document.fileName === jump.fileName\n      )[0];\n\n      if (editor) {\n        await vscode.window.showTextDocument(editor.document, jump.position.character, false);\n      }\n    }\n  }\n\n  /**\n   * Jump forward, possibly resulting in a file jump\n   */\n  public async jumpForward(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpForward.bind(this), position, vimState);\n  }\n\n  /**\n   * Jump back, possibly resulting in a file jump\n   */\n  public async jumpBack(position: Position, vimState: VimState): Promise<void> {\n    await this.jumpThroughHistory(this.recordJumpBack.bind(this), position, vimState);\n  }\n\n  private async jumpThroughHistory(\n    getJump: (j: Jump) => Jump,\n    position: Position,\n    vimState: VimState\n  ): Promise<void> {\n    let jump = new Jump({\n      document: vimState.document,\n      position,\n    });\n\n    const iterations = vimState.recordedState.count || 1;\n    for (let i = 0; i < iterations; i++) {\n      jump = getJump(Jump.fromStateNow(vimState));\n    }\n\n    if (!jump) {\n      return;\n    }\n\n    const jumpedFiles = jump.fileName !== vimState.document.fileName;\n\n    if (jumpedFiles) {\n      await this.performFileJump(jump, vimState);\n    } else {\n      vimState.cursorStopPosition = jump.position;\n    }\n  }\n\n  /**\n   * Get the previous jump in history.\n   * Continues further back if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpBack(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber <= 0) {\n      return this._jumps[0];\n    }\n\n    const to: Jump = this._jumps[this._currentJumpNumber - 1];\n\n    if (this._currentJumpNumber === this._jumps.length) {\n      this.recordJump(from, to);\n      this._currentJumpNumber = this._currentJumpNumber - 2;\n    } else {\n      this._currentJumpNumber = this._currentJumpNumber - 1;\n    }\n\n    return to;\n  }\n\n  /**\n   * Get the next jump in history.\n   * Continues further ahead if the current line is on the same line.\n   *\n   * @param from - File/position jumped from\n   */\n  public recordJumpForward(from: Jump): Jump {\n    if (!this.hasJumps) {\n      return from;\n    }\n\n    if (this._currentJumpNumber >= this._jumps.length) {\n      return from;\n    }\n\n    this._currentJumpNumber = Math.min(this._currentJumpNumber + 1, this._jumps.length - 1);\n    return this._jumps[this._currentJumpNumber];\n  }\n\n  /**\n   * Update existing jumps when lines were added to a document.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was added.\n   * @param text - Text containing one or more newline characters.\n   */\n  public handleTextAdded(document: { fileName: string }, range: vscode.Range, text: string): void {\n    // Get distance from newlines in the text added.\n    // Unlike handleTextDeleted, the range parameter distance between start/end is generally zero,\n    // just showing where the text was added.\n    const distance = text.split('').filter((c) => c === '\\n').length;\n\n    this._jumps.forEach((jump, i) => {\n      const jumpIsAfterAddedText =\n        jump.fileName === document.fileName && jump.position.line > range.start.line;\n\n      if (jumpIsAfterAddedText) {\n        const newPosition = new Position(jump.position.line + distance, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    });\n  }\n\n  /**\n   * Update existing jumps when lines were removed from a document.\n   *\n   * Vim doesn't actually remove deleted lines. Instead, it seems to shift line numbers down\n   * for any jumps after the deleted text, and preserves position for jumps on deleted lines or\n   * lines above the deleted lines. After lines are shifted, if there are multiple jumps on a line,\n   * the duplicates are removed, preserving the newest jumps (preserving latest column number).\n   *\n   * Lines are shifted based on number of lines deleted before the jump. So if e.g. the jump is on\n   * a middle line #6, where the jump above and below it were also deleted, the jump position would\n   * move down just one so it is now line #5, based on the line above it being deleted.\n   *\n   * @param document - Document that was changed, typically a vscode.TextDocument.\n   * @param range - Location where the text was removed.\n   */\n  public handleTextDeleted(document: { fileName: string }, range: vscode.Range): void {\n    // Note that this is like Array.slice, such that range.end.line is one line AFTER a deleted line,\n    // so distance is expected to be at least 1.\n    const distance = range.end.line - range.start.line;\n\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (jump.fileName !== document.fileName) {\n        continue;\n      }\n\n      const jumpIsAfterDeletedText = jump.position.line > range.start.line;\n\n      if (jumpIsAfterDeletedText) {\n        const newLineShiftedUp =\n          jump.position.line - Math.min(jump.position.line - range.start.line, distance);\n        const newPosition = new Position(newLineShiftedUp, jump.position.character);\n\n        this.changePositionForJumpNumber(i, jump, newPosition);\n      }\n    }\n\n    this.removeDuplicateJumps();\n  }\n\n  /**\n   * Clear existing jumps and reset jump position.\n   */\n  public clearJumps(): void {\n    this._jumps.splice(0, this._jumps.length);\n    this._currentJumpNumber = 0;\n  }\n\n  private pushJump(from: Jump | null, to?: Jump) {\n    if (from) {\n      this.clearJumpsOnSameLine(from);\n    }\n\n    if (from && (!to || !from.isSamePosition(to))) {\n      if (this._jumps.length === MAX_JUMPS) {\n        this._jumps.splice(0, 1);\n      }\n\n      this._jumps.push(from);\n    }\n\n    this._currentJumpNumber = this._jumps.length;\n  }\n\n  private changePositionForJumpNumber(index: number, jump: Jump, newPosition: Position) {\n    this._jumps.splice(\n      index,\n      1,\n      new Jump({\n        document: jump.document,\n        position: newPosition,\n      })\n    );\n  }\n\n  private clearJumpsOnSameLine(jump: Jump): void {\n    this._jumps = this._jumps.filter(\n      (j) => j === jump || !(j.fileName === jump.fileName && j.position.line === jump.position.line)\n    );\n  }\n\n  private removeDuplicateJumps() {\n    const linesSeenPerFile = {};\n    for (let i = this._jumps.length - 1; i >= 0; i--) {\n      const jump = this._jumps[i];\n\n      if (!linesSeenPerFile[jump.fileName]) {\n        linesSeenPerFile[jump.fileName] = [];\n      }\n\n      if (linesSeenPerFile[jump.fileName].includes(jump.position.line)) {\n        this._jumps.splice(i, 1);\n      } else {\n        linesSeenPerFile[jump.fileName].push(jump.position.line);\n      }\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport { Position } from 'vscode';\n\nexport enum Mode {\n  Normal,\n  Insert,\n  Visual,\n  VisualBlock,\n  VisualLine,\n  SearchInProgressMode,\n  CommandlineInProgress,\n  Replace,\n  EasyMotionMode,\n  EasyMotionInputMode,\n  SurroundInputMode,\n  OperatorPendingMode, // Pseudo-Mode, used only when remapping. DON'T SET TO THIS MODE\n  Disabled,\n}\n\nexport enum VSCodeVimCursorType {\n  Block,\n  Line,\n  LineThin,\n  Underline,\n  TextDecoration,\n  Native,\n  UnderlineThin,\n}\n\n/**\n * Is the given mode visual, visual line, or visual block?\n */\nexport function isVisualMode(mode: Mode): mode is Mode.Visual | Mode.VisualLine | Mode.VisualBlock {\n  return [Mode.Visual, Mode.VisualLine, Mode.VisualBlock].includes(mode);\n}\n\n/**\n * Is the given mode one where the cursor is on the status bar?\n * This means SearchInProgess and CommandlineInProgress modes.\n */\nexport function isStatusBarMode(\n  mode: Mode\n): mode is Mode.CommandlineInProgress | Mode.SearchInProgressMode {\n  return [Mode.SearchInProgressMode, Mode.CommandlineInProgress].includes(mode);\n}\n\nexport function getCursorStyle(cursorType: VSCodeVimCursorType) {\n  switch (cursorType) {\n    case VSCodeVimCursorType.Block:\n      return vscode.TextEditorCursorStyle.Block;\n    case VSCodeVimCursorType.Line:\n      return vscode.TextEditorCursorStyle.Line;\n    case VSCodeVimCursorType.LineThin:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Underline:\n      return vscode.TextEditorCursorStyle.Underline;\n    case VSCodeVimCursorType.UnderlineThin:\n      return vscode.TextEditorCursorStyle.UnderlineThin;\n    case VSCodeVimCursorType.TextDecoration:\n      return vscode.TextEditorCursorStyle.LineThin;\n    case VSCodeVimCursorType.Native:\n    default:\n      return vscode.TextEditorCursorStyle.Block;\n  }\n}\n\nexport function visualBlockGetTopLeftPosition(start: Position, stop: Position): Position {\n  return new Position(Math.min(start.line, stop.line), Math.min(start.character, stop.character));\n}\n\nexport function visualBlockGetBottomRightPosition(start: Position, stop: Position): Position {\n  return new Position(Math.max(start.line, stop.line), Math.max(start.character, stop.character));\n}\n","import * as vscode from 'vscode';\n\nimport { BaseAction, KeypressState, BaseCommand, getRelevantAction } from './../actions/base';\nimport { BaseMovement } from '../actions/baseMotion';\nimport {\n  CommandBackspaceInInsertMode,\n  CommandEscInsertMode,\n  CommandInsertInInsertMode,\n  CommandInsertPreviousText,\n  InsertCharAbove,\n  InsertCharBelow,\n} from './../actions/commands/insert';\nimport { Jump } from '../jumps/jump';\nimport { Logger } from '../util/logger';\nimport { Mode, VSCodeVimCursorType, isVisualMode, getCursorStyle, isStatusBarMode } from './mode';\nimport { PairMatcher } from './../common/matching/matcher';\nimport { laterOf } from './../common/motion/position';\nimport { Cursor } from '../common/motion/cursor';\nimport { RecordedState } from './../state/recordedState';\nimport { IBaseAction } from '../actions/types';\nimport { Register, RegisterMode } from './../register/register';\nimport { Remappers } from '../configuration/remapper';\nimport { StatusBar } from '../statusBar';\nimport { TextEditor } from './../textEditor';\nimport { VimError, ForceStopRemappingError } from './../error';\nimport { VimState } from './../state/vimState';\nimport { VSCodeContext } from '../util/vscodeContext';\nimport { configuration } from '../configuration/configuration';\nimport { decoration } from '../configuration/decoration';\nimport { scrollView } from '../util/util';\nimport {\n  CommandQuitRecordMacro,\n  DocumentContentChangeAction,\n  ActionOverrideCmdD,\n  CommandNumber,\n} from './../actions/commands/actions';\nimport { isTextTransformation } from '../transformations/transformations';\nimport { executeTransformations, IModeHandler } from '../transformations/execute';\nimport { globalState } from '../state/globalState';\nimport { Notation } from '../configuration/notation';\nimport { SpecialKeys } from '../util/specialKeys';\nimport { SearchDecorations, getDecorationsForSearchMatchRanges } from '../util/decorationUtils';\nimport { BaseOperator } from '../actions/operator';\nimport { SearchByNCharCommand } from '../actions/plugins/easymotion/easymotion.cmd';\nimport { Position, Uri } from 'vscode';\nimport { RemapState } from '../state/remapState';\nimport * as process from 'process';\nimport { EasyMotion } from '../actions/plugins/easymotion/easymotion';\n\ninterface IModeHandlerMap {\n  get(editorId: Uri): ModeHandler | undefined;\n}\n\n/**\n * ModeHandler is the extension's backbone. It listens to events and updates the VimState.\n * One of these exists for each editor - see ModeHandlerMap\n *\n * See:  https://github.com/VSCodeVim/Vim/blob/master/.github/CONTRIBUTING.md#the-vim-state-machine\n */\nexport class ModeHandler implements vscode.Disposable, IModeHandler {\n  public readonly vimState: VimState;\n  public readonly remapState: RemapState;\n\n  public focusChanged = false;\n\n  private searchDecorationCacheKey: { searchString: string; documentVersion: number } | undefined;\n\n  private readonly disposables: vscode.Disposable[] = [];\n  private readonly handlerMap: IModeHandlerMap;\n  private readonly remappers: Remappers;\n  private static readonly logger = Logger.get('ModeHandler');\n\n  /**\n   * Used internally to ignore selection changes that were performed by us.\n   * 'ignoreIntermediateSelections': set to true when running an action, during this time\n   * all selections change events will be ignored.\n   * 'ourSelections': keeps track of our selections that will trigger a selection change event\n   * so that we can ignore them.\n   */\n  public selectionsChanged = {\n    /**\n     * Set to true when running an action, during this time\n     * all selections change events will be ignored.\n     */\n    ignoreIntermediateSelections: false,\n    /**\n     * keeps track of our selections that will trigger a selection change event\n     * so that we can ignore them.\n     */\n    ourSelections: Array<string>(),\n  };\n\n  /**\n   * Was the previous mouse click past EOL\n   */\n  private lastClickWasPastEol: boolean = false;\n\n  // TODO: clarify the difference between ModeHandler.currentMode and VimState.currentMode\n  private _currentMode!: Mode;\n\n  get currentMode(): Mode {\n    return this._currentMode;\n  }\n\n  private async setCurrentMode(mode: Mode): Promise<void> {\n    if (this.vimState.currentMode !== mode) {\n      await this.vimState.setCurrentMode(mode);\n    }\n    this._currentMode = mode;\n  }\n\n  public static async create(\n    handlerMap: IModeHandlerMap,\n    textEditor: vscode.TextEditor\n  ): Promise<ModeHandler> {\n    const modeHandler = new ModeHandler(handlerMap, textEditor);\n    await modeHandler.vimState.load();\n    await modeHandler.setCurrentMode(configuration.startInInsertMode ? Mode.Insert : Mode.Normal);\n    modeHandler.syncCursors();\n    return modeHandler;\n  }\n\n  private constructor(handlerMap: IModeHandlerMap, textEditor: vscode.TextEditor) {\n    this.handlerMap = handlerMap;\n    this.remappers = new Remappers();\n\n    this.vimState = new VimState(textEditor, new EasyMotion());\n    this.remapState = new RemapState();\n    this.disposables.push(this.vimState);\n  }\n\n  /**\n   * Updates VSCodeVim's internal representation of cursors to match VSCode's selections.\n   * This loses some information, so it should only be done when necessary.\n   */\n  public syncCursors() {\n    // TODO: getCursorsAfterSync() is basically this, but stupider\n    const { selections } = this.vimState.editor;\n    if (\n      !this.vimState.cursorStartPosition.isEqual(selections[0].anchor) ||\n      !this.vimState.cursorStopPosition.isEqual(selections[0].active)\n    ) {\n      this.vimState.desiredColumn = selections[0].active.character;\n    }\n\n    this.vimState.cursors = selections.map(({ active, anchor }) =>\n      active.isBefore(anchor) ? new Cursor(anchor.getLeft(), active) : new Cursor(anchor, active)\n    );\n  }\n\n  /**\n   * This is easily the worst function in VSCodeVim.\n   *\n   * We need to know when VSCode has updated our selection, so that we can sync\n   * that internally. Unfortunately, VSCode has a habit of calling this\n   * function at weird times, or or with incomplete information, so we have to\n   * do a lot of voodoo to make sure we're updating the cursors correctly.\n   *\n   * Even worse, we don't even know how to test this stuff.\n   *\n   * Anyone who wants to change the behavior of this method should make sure\n   * all selection related test cases pass. Follow this spec\n   * https://gist.github.com/rebornix/d21d1cc060c009d4430d3904030bd4c1 to\n   * perform the manual testing. Besides this testing you should still test\n   * commands like 'editor.action.smartSelect.grow' and you should test moving\n   * continuously up/down or left/right with and without remapped movement keys\n   * because sometimes vscode lags behind and calls this function with information\n   * that is not up to date with our selections yet and we need to make sure we don't\n   * change our cursors to previous information (this usally is only an issue in visual\n   * mode because of our different ways of handling selections and in those cases\n   * updating our cursors with not up to date info might result in us changing our\n   * cursor start position).\n   */\n  public async handleSelectionChange(e: vscode.TextEditorSelectionChangeEvent): Promise<void> {\n    if (\n      vscode.window.activeTextEditor === undefined ||\n      e.textEditor.document !== vscode.window.activeTextEditor.document\n    ) {\n      // we don't care if there is no active editor\n      // or user selection changed in a paneled window (e.g debug console/terminal)\n      // This check is made before enqueuing this selection change, but sometimes\n      // between the enqueueing and the actual calling of this function the editor\n      // might close or change to other document\n      return;\n    }\n    const selection = e.selections[0];\n    ModeHandler.logger.debug(\n      `Selections: Handling Selection Change! Selection: ${selection.anchor.toString()}, ${\n        selection.active\n      }, SelectionsLength: ${e.selections.length}`\n    );\n\n    // If our previous cursors are not included on any of the current selections, then a snippet\n    // must have been inserted.\n    const isSnippetSelectionChange = () => {\n      return e.selections.every((s) => {\n        return this.vimState.cursors.every((c) => !s.contains(new vscode.Range(c.start, c.stop)));\n      });\n    };\n\n    if (\n      (e.selections.length !== this.vimState.cursors.length || this.vimState.isMultiCursor) &&\n      this.vimState.currentMode !== Mode.VisualBlock\n    ) {\n      const allowedModes = [Mode.Normal];\n      if (!isSnippetSelectionChange()) {\n        allowedModes.push(...[Mode.Insert, Mode.Replace]);\n      }\n      // Number of selections changed, make sure we know about all of them still\n      this.vimState.cursors = e.textEditor.selections.map(\n        (sel) =>\n          new Cursor(\n            // Adjust the cursor positions because cursors & selections don't match exactly\n            sel.anchor.isAfter(sel.active) ? sel.anchor.getLeft() : sel.anchor,\n            sel.active\n          )\n      );\n      if (\n        e.selections.some((s) => !s.anchor.isEqual(s.active)) &&\n        allowedModes.includes(this.vimState.currentMode)\n      ) {\n        // If we got a visual selection and we are on normal, insert or replace mode, enter visual mode.\n        // We shouldn't go to visual mode on any other mode, because the other visual modes are handled\n        // very differently than vscode so only our extension will create them. And the other modes\n        // like the plugin modes shouldn't be changed or else it might mess up the plugins actions.\n        await this.setCurrentMode(Mode.Visual);\n      }\n      return this.updateView({ drawSelection: false, revealRange: false });\n    }\n\n    /**\n     * We only trigger our view updating process if it's a mouse selection.\n     * Otherwise we only update our internal cursor positions accordingly.\n     */\n    if (e.kind !== vscode.TextEditorSelectionChangeKind.Mouse) {\n      if (selection) {\n        if (e.kind === vscode.TextEditorSelectionChangeKind.Command) {\n          // This 'Command' kind is triggered when using a command like 'editor.action.smartSelect.grow'\n          // but it is also triggered when we set the 'editor.selections' on 'updateView'.\n          const allowedModes = [Mode.Normal, Mode.Visual];\n          if (!isSnippetSelectionChange()) {\n            // if we just inserted a snippet then don't allow insert modes to go to visual mode\n            allowedModes.push(...[Mode.Insert, Mode.Replace]);\n          }\n          if (allowedModes.includes(this.vimState.currentMode)) {\n            // Since the selections weren't ignored then probably we got change of selection from\n            // a command, so we need to update our start and stop positions. This is where commands\n            // like 'editor.action.smartSelect.grow' are handled.\n            if (this.vimState.currentMode === Mode.Visual) {\n              ModeHandler.logger.debug('Selections: Updating Visual Selection!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            } else if (!selection.active.isEqual(selection.anchor)) {\n              ModeHandler.logger.debug('Selections: Creating Visual Selection from command!');\n              this.vimState.cursorStopPosition = selection.active;\n              this.vimState.cursorStartPosition = selection.anchor;\n              await this.setCurrentMode(Mode.Visual);\n              await this.updateView({ drawSelection: false, revealRange: false });\n              return;\n            }\n          }\n        }\n        // Here we are on the selection changed of kind 'Keyboard' or 'undefined' which is triggered\n        // when pressing movement keys that are not caught on the 'type' override but also when using\n        // commands like 'cursorMove'.\n\n        if (isVisualMode(this.vimState.currentMode)) {\n          /**\n           * In Visual Mode, our `cursorPosition` and `cursorStartPosition` can not reflect `active`,\n           * `start`, `end` and `anchor` information in a selection.\n           * See `Fake block cursor with text decoration` section of `updateView` method.\n           * Besides this, sometimes on visual modes our start position is not the same has vscode\n           * anchor because we need to move vscode anchor one to the right of our start when our start\n           * is after our stop in order to include the start character on vscodes selection.\n           */\n          return;\n        }\n\n        const cursorEnd = laterOf(\n          this.vimState.cursorStartPosition,\n          this.vimState.cursorStopPosition\n        );\n        if (e.textEditor.document.validatePosition(cursorEnd).isBefore(cursorEnd)) {\n          // The document changed such that our cursor position is now out of bounds, possibly by\n          // another program. Let's just use VSCode's selection.\n          // TODO: if this is the case, but we're in visual mode, we never get here (because of branch above)\n        } else if (\n          e.kind === vscode.TextEditorSelectionChangeKind.Keyboard &&\n          this.vimState.cursorStopPosition.isEqual(this.vimState.cursorStartPosition) &&\n          this.vimState.cursorStopPosition.getRight().isLineEnd() &&\n          this.vimState.cursorStopPosition.getLineEnd().isEqual(selection.active)\n        ) {\n          // We get here when we use a 'cursorMove' command (that is considered a selection changed\n          // kind of 'Keyboard') that ends past the line break. But our cursors are already on last\n          // character which is what we want. Even though our cursors will be corrected again when\n          // checking if they are in bounds on 'runAction' there is no need to be changing them back\n          // and forth so we check for this situation here.\n          return;\n        }\n\n        // Here we allow other 'cursorMove' commands to update our cursors in case there is another\n        // extension making cursor changes that we need to catch.\n        //\n        // We still need to be careful with this because this here might be changing our cursors\n        // in ways we don't want to. So with future selection issues this is a good place to start\n        // looking.\n        ModeHandler.logger.debug(\n          `Selections: Changing Cursors from selection handler... ${selection.anchor.toString()}, ${\n            selection.active\n          }`\n        );\n        this.vimState.cursorStopPosition = selection.active;\n        this.vimState.cursorStartPosition = selection.anchor;\n        this.vimState.desiredColumn = selection.active.character;\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n      return;\n    }\n\n    if (isStatusBarMode(this.vimState.currentMode)) {\n      return;\n    }\n\n    let toDraw = false;\n\n    if (selection) {\n      let newPosition = selection.active;\n\n      // Only check on a click, not a full selection (to prevent clicking past EOL)\n      if (newPosition.character >= newPosition.getLineEnd().character && selection.isEmpty) {\n        if (this.vimState.currentMode !== Mode.Insert) {\n          this.lastClickWasPastEol = true;\n\n          // This prevents you from mouse clicking past the EOL\n          newPosition = newPosition.withColumn(Math.max(newPosition.getLineEnd().character - 1, 0));\n\n          // Switch back to normal mode since it was a click not a selection\n          await this.setCurrentMode(Mode.Normal);\n\n          toDraw = true;\n        }\n      } else if (selection.isEmpty) {\n        this.lastClickWasPastEol = false;\n      }\n\n      this.vimState.cursorStopPosition = newPosition;\n      this.vimState.cursorStartPosition = newPosition;\n      this.vimState.desiredColumn = newPosition.character;\n\n      // start visual mode?\n      if (\n        selection.anchor.line === selection.active.line &&\n        selection.anchor.character >= newPosition.getLineEnd().character &&\n        selection.active.character >= newPosition.getLineEnd().character\n      ) {\n        // This prevents you from selecting EOL\n      } else if (!selection.anchor.isEqual(selection.active)) {\n        let selectionStart = new Position(selection.anchor.line, selection.anchor.character);\n\n        if (selectionStart.character > selectionStart.getLineEnd().character) {\n          selectionStart = new Position(selectionStart.line, selectionStart.getLineEnd().character);\n        }\n\n        this.vimState.cursorStartPosition = selectionStart;\n\n        if (selectionStart.isAfter(newPosition)) {\n          this.vimState.cursorStartPosition = this.vimState.cursorStartPosition.getLeft();\n        }\n\n        // If we prevented from clicking past eol but it is part of this selection, include the last char\n        if (this.lastClickWasPastEol) {\n          const newStart = new Position(selection.anchor.line, selection.anchor.character + 1);\n          this.vimState.editor.selection = new vscode.Selection(newStart, selection.end);\n          this.vimState.cursorStartPosition = selectionStart;\n          this.lastClickWasPastEol = false;\n        }\n\n        if (\n          configuration.mouseSelectionGoesIntoVisualMode &&\n          !isVisualMode(this.vimState.currentMode) &&\n          this.currentMode !== Mode.Insert\n        ) {\n          await this.setCurrentMode(Mode.Visual);\n\n          // double click mouse selection causes an extra character to be selected so take one less character\n        }\n      } else if (this.vimState.currentMode !== Mode.Insert) {\n        await this.setCurrentMode(Mode.Normal);\n      }\n\n      this.updateView({ drawSelection: toDraw, revealRange: false });\n    }\n  }\n\n  async handleMultipleKeyEvents(keys: string[]): Promise<void> {\n    for (const key of keys) {\n      await this.handleKeyEvent(key);\n    }\n  }\n\n  public async handleKeyEvent(key: string): Promise<void> {\n    const now = Date.now();\n    const printableKey = Notation.printableKey(key, configuration.leader);\n\n    // Check forceStopRemapping\n    if (this.remapState.forceStopRecursiveRemapping) {\n      return;\n    }\n\n    ModeHandler.logger.debug(`handling key=${printableKey}.`);\n\n    if (\n      (key === SpecialKeys.TimeoutFinished ||\n        this.vimState.recordedState.bufferedKeys.length > 0) &&\n      this.vimState.recordedState.bufferedKeysTimeoutObj\n    ) {\n      // Handle the bufferedKeys or append the new key to the previously bufferedKeys\n      clearTimeout(this.vimState.recordedState.bufferedKeysTimeoutObj);\n      this.vimState.recordedState.bufferedKeysTimeoutObj = undefined;\n      this.vimState.recordedState.commandList = [...this.vimState.recordedState.bufferedKeys];\n      this.vimState.recordedState.bufferedKeys = [];\n    }\n\n    // rewrite copy\n    if (configuration.overrideCopy) {\n      // The conditions when you trigger a \"copy\" rather than a ctrl-c are\n      // too sophisticated to be covered by the \"when\" condition in package.json\n      if (key === '<D-c>') {\n        key = '<copy>';\n      }\n\n      if (key === '<C-c>' && process.platform !== 'darwin') {\n        if (\n          !configuration.useCtrlKeys ||\n          this.vimState.currentMode === Mode.Visual ||\n          this.vimState.currentMode === Mode.VisualBlock ||\n          this.vimState.currentMode === Mode.VisualLine\n        ) {\n          key = '<copy>';\n        }\n      }\n    }\n\n    // <C-d> triggers \"add selection to next find match\" by default,\n    // unless users explicity make <C-d>: true\n    if (key === '<C-d>' && !(configuration.handleKeys['<C-d>'] === true)) {\n      key = '<D-d>';\n    }\n\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n    this.vimState.recordedState.commandList.push(key);\n\n    const oldMode = this.vimState.currentMode;\n    const oldFullMode = this.vimState.currentModeIncludingPseudoModes;\n    const oldStatusBarText = StatusBar.getText();\n    const oldWaitingForAnotherActionKey = this.vimState.recordedState.waitingForAnotherActionKey;\n\n    let handledAsRemap = false;\n    let handledAsAction = false;\n    try {\n      // Handling special case for '0'. From Vim documentation (:help :map-modes)\n      // Special case: While typing a count for a command in Normal mode, mapping zero\n      // is disabled. This makes it possible to map zero without making it impossible\n      // to type a count with a zero.\n      const preventZeroRemap =\n        key === '0' &&\n        this.vimState.recordedState.actionsRun[\n          this.vimState.recordedState.actionsRun.length - 1\n        ] instanceof CommandNumber;\n\n      // Check for remapped keys if:\n      // 1. We are not currently performing a non-recursive remapping\n      // 2. We are not typing '0' after starting to type a count\n      // 3. We are not waiting for another action key\n      //    Example: jj should not remap the second 'j', if jj -> <Esc> in insert mode\n      //             0 should not be remapped if typed after another number, like 10\n      //             for actions with multiple keys like 'gg' or 'fx' the second character\n      //           shouldn't be mapped\n      if (\n        !this.remapState.isCurrentlyPerformingNonRecursiveRemapping &&\n        !preventZeroRemap &&\n        !this.vimState.recordedState.waitingForAnotherActionKey\n      ) {\n        handledAsRemap = await this.remappers.sendKey(\n          this.vimState.recordedState.commandList,\n          this\n        );\n      }\n\n      this.vimState.recordedState.allowPotentialRemapOnFirstKey = true;\n\n      if (!handledAsRemap) {\n        if (key === SpecialKeys.TimeoutFinished) {\n          // Remove the <TimeoutFinished> key and get the key before that. If the <TimeoutFinished>\n          // key was the last key, then 'key' will be undefined and won't be sent to handle action.\n          this.vimState.recordedState.commandList.pop();\n          key =\n            this.vimState.recordedState.commandList[\n              this.vimState.recordedState.commandList.length - 1\n            ];\n        }\n        if (key !== undefined) {\n          handledAsAction = await this.handleKeyAsAnAction(key);\n        }\n      }\n    } catch (e) {\n      this.selectionsChanged.ignoreIntermediateSelections = false;\n      if (e instanceof VimError) {\n        StatusBar.displayError(this.vimState, e);\n        this.vimState.recordedState = new RecordedState();\n        if (this.remapState.isCurrentlyPerformingRemapping) {\n          // If we are handling a remap and we got a VimError stop handling the remap\n          // and discard the rest of the keys. We throw an Exception here to stop any other\n          // remapping handling steps and go straight to the 'finally' step of the remapper.\n          throw ForceStopRemappingError.fromVimError(e);\n        }\n      } else if (e instanceof ForceStopRemappingError) {\n        // If this is a ForceStopRemappingError rethrow it until it gets to the remapper\n        throw e;\n      } else if (e instanceof Error) {\n        e.message = `Failed to handle key \\`${key}\\`: ${e.message}`;\n        throw e;\n      } else {\n        throw new Error(`Failed to handle key \\`${key}\\` due to an unknown error.`);\n      }\n    }\n\n    this.remapState.lastKeyPressedTimestamp = now;\n\n    StatusBar.updateShowCmd(this.vimState);\n\n    // We don't want to immediately erase any message that resulted from the action just performed\n    if (StatusBar.getText() === oldStatusBarText) {\n      // Clear the status bar of high priority messages if the mode has changed, the view has scrolled\n      // or it is recording a Macro\n      const forceClearStatusBar =\n        (this.vimState.currentMode !== oldMode && this.vimState.currentMode !== Mode.Normal) ||\n        this.vimState.macro !== undefined;\n      StatusBar.clear(this.vimState, forceClearStatusBar);\n    }\n\n    // We either already ran an action or we have a potential action to run but\n    // the key is already stored on 'actionKeys' in that case we don't need it\n    // anymore on commandList that is only used for the remapper and 'showCmd'\n    // and both had already been handled at this point.\n    // If we got here it means that there is no potential remap for the key\n    // either so we need to clear it from commandList so that it doesn't interfere\n    // with the next remapper check.\n    this.vimState.recordedState.resetCommandList();\n\n    ModeHandler.logger.debug(`handleKeyEvent('${printableKey}') took ${Date.now() - now}ms`);\n\n    // If we are handling a remap and the last movement failed stop handling the remap\n    // and discard the rest of the keys. We throw an Exception here to stop any other\n    // remapping handling steps and go straight to the 'finally' step of the remapper.\n    if (this.remapState.isCurrentlyPerformingRemapping && this.vimState.lastMovementFailed) {\n      this.vimState.lastMovementFailed = false;\n      throw new ForceStopRemappingError('Last movement failed');\n    }\n\n    // Reset lastMovementFailed. Anyone who needed it has probably already handled it.\n    // And keeping it past this point would make any following remapping force stop.\n    this.vimState.lastMovementFailed = false;\n\n    if (!handledAsAction) {\n      // There was no action run yet but we still want to update the view to be able\n      // to show the potential remapping keys being pressed, the `\"` character when\n      // waiting on a register key or the `?` character and any following character\n      // when waiting on digraph keys. The 'oldWaitingForAnotherActionKey' is used\n      // to call the updateView after we are no longer waiting keys so that any\n      // existing overlapped key is removed.\n      if (\n        ((this.vimState.currentMode === Mode.Insert ||\n          this.vimState.currentMode === Mode.Replace) &&\n          (this.vimState.recordedState.bufferedKeys.length > 0 ||\n            this.vimState.recordedState.waitingForAnotherActionKey ||\n            this.vimState.recordedState.waitingForAnotherActionKey !==\n              oldWaitingForAnotherActionKey)) ||\n        this.vimState.currentModeIncludingPseudoModes !== oldFullMode\n      ) {\n        // TODO: this call to updateView is only used to update the virtualCharacter and halfBlock\n        // cursor decorations, if in the future we split up the updateView function there should\n        // be no need to call all of it.\n        await this.updateView({ drawSelection: false, revealRange: false });\n      }\n    }\n  }\n\n  private async handleKeyAsAnAction(key: string): Promise<boolean> {\n    if (vscode.window.activeTextEditor !== this.vimState.editor) {\n      ModeHandler.logger.warn('Current window is not active');\n      return false;\n    }\n\n    // Catch any text change not triggered by us (example: tab completion).\n    this.vimState.historyTracker.addChange();\n\n    const recordedState = this.vimState.recordedState;\n    recordedState.actionKeys.push(key);\n\n    const action = getRelevantAction(recordedState.actionKeys, this.vimState);\n    switch (action) {\n      case KeypressState.NoPossibleMatch:\n        if (this.vimState.currentMode === Mode.Insert) {\n          this.vimState.recordedState.actionKeys = [];\n        } else {\n          this.vimState.recordedState = new RecordedState();\n        }\n        // Since there is no possible action we are no longer waiting any action keys\n        this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n        return false;\n      case KeypressState.WaitingOnKeys:\n        this.vimState.recordedState.waitingForAnotherActionKey = true;\n\n        return false;\n    }\n\n    if (\n      !this.remapState.remapUsedACharacter &&\n      this.remapState.isCurrentlyPerformingRecursiveRemapping\n    ) {\n      // Used a character inside a recursive remapping so we reset the mapDepth.\n      this.remapState.remapUsedACharacter = true;\n      this.remapState.mapDepth = 0;\n    }\n\n    // Since we got an action we are no longer waiting any action keys\n    this.vimState.recordedState.waitingForAnotherActionKey = false;\n\n    // Store action pressed keys for showCmd\n    recordedState.actionsRunPressedKeys.push(...recordedState.actionKeys);\n\n    let actionToRecord: BaseAction | undefined = action;\n    if (recordedState.actionsRun.length === 0) {\n      recordedState.actionsRun.push(action);\n    } else {\n      const lastAction = recordedState.actionsRun[recordedState.actionsRun.length - 1];\n\n      const actionCanBeMergedWithDocumentChange =\n        action instanceof CommandInsertInInsertMode ||\n        action instanceof CommandBackspaceInInsertMode ||\n        action instanceof CommandInsertPreviousText ||\n        action instanceof InsertCharAbove ||\n        action instanceof InsertCharBelow;\n\n      if (lastAction instanceof DocumentContentChangeAction) {\n        if (!(action instanceof CommandEscInsertMode)) {\n          // TODO: this includes things like <BS>, which it shouldn't\n          lastAction.keysPressed.push(key);\n        }\n\n        if (actionCanBeMergedWithDocumentChange) {\n          // delay the macro recording\n          actionToRecord = undefined;\n        } else {\n          // Push document content change to the stack\n          lastAction.addChanges(\n            this.vimState.historyTracker.currentContentChanges,\n            this.vimState.cursorStopPosition\n          );\n          this.vimState.historyTracker.currentContentChanges = [];\n          recordedState.actionsRun.push(action);\n        }\n      } else {\n        if (actionCanBeMergedWithDocumentChange) {\n          // This means we are already in Insert Mode but there is still not DocumentContentChangeAction in stack\n          this.vimState.historyTracker.currentContentChanges = [];\n          const newContentChange = new DocumentContentChangeAction(\n            this.vimState.cursorStopPosition\n          );\n          newContentChange.keysPressed.push(key);\n          recordedState.actionsRun.push(newContentChange);\n          actionToRecord = newContentChange;\n        } else {\n          recordedState.actionsRun.push(action);\n        }\n      }\n    }\n\n    if (\n      this.vimState.macro !== undefined &&\n      actionToRecord &&\n      !(actionToRecord instanceof CommandQuitRecordMacro)\n    ) {\n      this.vimState.macro.actionsRun.push(actionToRecord);\n    }\n\n    await this.runAction(recordedState, action);\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      recordedState.isInsertion = true;\n    }\n\n    // Update view\n    await this.updateView();\n\n    if (action.isJump) {\n      globalState.jumpTracker.recordJump(\n        Jump.fromStateBefore(this.vimState),\n        Jump.fromStateNow(this.vimState)\n      );\n    }\n\n    return true;\n  }\n\n  private async runAction(recordedState: RecordedState, action: IBaseAction): Promise<void> {\n    this.selectionsChanged.ignoreIntermediateSelections = true;\n\n    // We handle the end of selections different to VSCode. In order for VSCode to select\n    // including the last character we will at the end of 'runAction' shift our stop position\n    // to the right. So here we shift it back by one so that our actions have our correct\n    // position instead of the position sent to VSCode.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBefore(c.stop) ? c.withNewStop(c.stop.getLeftThroughLineBreaks(true)) : c\n      );\n    }\n\n    // Make sure all cursors are within the document's bounds before running any action\n    // It's not 100% clear to me that this is the correct place to do this, but it should solve a lot of issues\n    this.vimState.cursors = this.vimState.cursors.map(\n      (c) =>\n        new Cursor(\n          this.vimState.document.validatePosition(c.start),\n          this.vimState.document.validatePosition(c.stop)\n        )\n    );\n\n    let ranRepeatableAction = false;\n    let ranAction = false;\n\n    if (action instanceof BaseMovement) {\n      recordedState = await this.executeMovement(action);\n      ranAction = true;\n    } else if (action instanceof BaseCommand) {\n      await action.execCount(this.vimState.cursorStopPosition, this.vimState);\n\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n\n      if (action.isCompleteAction) {\n        ranAction = true;\n      }\n\n      if (action.createsUndoPoint) {\n        ranRepeatableAction = true;\n      }\n    } else if (action instanceof BaseOperator) {\n      recordedState.operatorCount = recordedState.count;\n    } else {\n      throw new Error('Unknown action type');\n    }\n\n    // Update mode (note the ordering allows you to go into search mode,\n    // then return and have the motion immediately applied to an operator).\n    const prevMode = this.currentMode;\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      // We don't want to mark any searches as a repeatable action\n      if (\n        this.vimState.currentMode === Mode.Normal &&\n        prevMode !== Mode.SearchInProgressMode &&\n        prevMode !== Mode.EasyMotionInputMode &&\n        prevMode !== Mode.EasyMotionMode\n      ) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    // If there's an operator pending and we have a motion or visual selection, run the operator\n    if (recordedState.getOperatorState(this.vimState.currentMode) === 'ready') {\n      const operator = this.vimState.recordedState.operator;\n      if (operator) {\n        await this.executeOperator();\n        this.vimState.recordedState.hasRunOperator = true;\n        ranRepeatableAction = operator.createsUndoPoint;\n        ranAction = true;\n      }\n    }\n\n    // And then we have to do it again because an operator could\n    // have changed it as well. (TODO: do you even decomposition bro)\n    if (this.vimState.currentMode !== this.currentMode) {\n      await this.setCurrentMode(this.vimState.currentMode);\n\n      if (this.vimState.currentMode === Mode.Normal) {\n        ranRepeatableAction = true;\n      }\n    }\n\n    ranRepeatableAction =\n      (ranRepeatableAction && this.vimState.currentMode === Mode.Normal) ||\n      this.createUndoPointForBrackets();\n\n    // Record down previous action and flush temporary state\n    if (ranRepeatableAction && this.vimState.lastCommandDotRepeatable) {\n      globalState.previousFullAction = this.vimState.recordedState;\n\n      if (recordedState.isInsertion) {\n        Register.setReadonlyRegister('.', recordedState);\n      }\n    }\n    this.vimState.lastCommandDotRepeatable = true;\n\n    // Update desiredColumn\n    const preservesDesiredColumn =\n      action instanceof BaseOperator && !ranAction ? true : action.preservesDesiredColumn;\n    if (!preservesDesiredColumn) {\n      if (action instanceof BaseMovement) {\n        // We check !operator here because e.g. d$ should NOT set the desired column to EOL.\n        if (action.setsDesiredColumnToEOL && !recordedState.operator) {\n          this.vimState.desiredColumn = Number.POSITIVE_INFINITY;\n        } else {\n          this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n        }\n      } else if (this.vimState.currentMode !== Mode.VisualBlock) {\n        // TODO: explain why not VisualBlock\n        this.vimState.desiredColumn = this.vimState.cursorStopPosition.character;\n      }\n    }\n\n    // Like previously stated we handle the end of selections different to VSCode. In order\n    // for VSCode to select including the last character we shift our stop position to the\n    // right now that all steps that need that position have already run. On the next action\n    // we will shift it back again on the start of 'runAction'.\n    if (this.vimState.currentMode === Mode.Visual) {\n      this.vimState.cursors = this.vimState.cursors.map((c) =>\n        c.start.isBeforeOrEqual(c.stop)\n          ? c.withNewStop(\n              c.stop.isLineEnd() ? c.stop.getRightThroughLineBreaks() : c.stop.getRight()\n            )\n          : c\n      );\n    }\n\n    // We've run a complete action sequence - wipe the slate clean with a new RecordedState\n    if (ranAction && this.vimState.currentMode === Mode.Normal) {\n      this.vimState.recordedState = new RecordedState();\n\n      // Return to insert mode after 1 command in this case for <C-o>\n      if (this.vimState.returnToInsertAfterCommand) {\n        if (this.vimState.actionCount > 0) {\n          await this.setCurrentMode(Mode.Insert);\n        } else {\n          this.vimState.actionCount++;\n        }\n      }\n    }\n\n    // track undo history\n    if (!this.focusChanged) {\n      // important to ensure that focus didn't change, otherwise\n      // we'll grab the text of the incorrect active window and assume the\n      // whole document changed!\n\n      this.vimState.historyTracker.addChange();\n    }\n\n    // Don't record an undo point for every action of a macro, only at the very end\n    if (\n      ranRepeatableAction &&\n      !this.vimState.isReplayingMacro &&\n      !this.remapState.isCurrentlyPerformingRemapping\n    ) {\n      this.vimState.historyTracker.finishCurrentStep();\n    }\n\n    recordedState.actionKeys = [];\n    this.vimState.currentRegisterMode = undefined;\n\n    // If we're in Normal mode, collapse each cursor down to one character\n    if (this.currentMode === Mode.Normal) {\n      this.vimState.cursors = this.vimState.cursors.map(\n        (cursor) => new Cursor(cursor.stop, cursor.stop)\n      );\n    }\n\n    // Ensure cursors are within bounds\n    if (\n      !this.vimState.document.isClosed &&\n      this.vimState.editor === vscode.window.activeTextEditor\n    ) {\n      const documentEndPosition = TextEditor.getDocumentEnd(this.vimState.document);\n      const documentLineCount = this.vimState.document.lineCount;\n\n      this.vimState.cursors = this.vimState.cursors.map((cursor: Cursor) => {\n        // adjust start/stop\n        if (cursor.start.line >= documentLineCount) {\n          cursor = cursor.withNewStart(documentEndPosition);\n        }\n        if (cursor.stop.line >= documentLineCount) {\n          cursor = cursor.withNewStop(documentEndPosition);\n        }\n\n        // adjust column\n        if (this.vimState.currentMode === Mode.Normal || isVisualMode(this.vimState.currentMode)) {\n          const currentLineLength = TextEditor.getLineLength(cursor.stop.line);\n          const currentStartLineLength = TextEditor.getLineLength(cursor.start.line);\n\n          // When in visual mode you can move the cursor past the last character in order\n          // to select that character. We use this offset to allow for that, otherwise\n          // we would consider the position invalid and change it to the left of the last\n          // character.\n          const offsetAllowed =\n            isVisualMode(this.vimState.currentMode) && currentLineLength > 0 ? 1 : 0;\n          if (cursor.start.character >= currentStartLineLength) {\n            cursor = cursor.withNewStart(\n              cursor.start.withColumn(Math.max(currentStartLineLength - 1, 0))\n            );\n          }\n\n          if (cursor.stop.character >= currentLineLength + offsetAllowed) {\n            cursor = cursor.withNewStop(cursor.stop.withColumn(Math.max(currentLineLength - 1, 0)));\n          }\n        }\n        return cursor;\n      });\n    }\n\n    if (isVisualMode(this.vimState.currentMode) && !this.vimState.isRunningDotCommand) {\n      // Store selection for commands like gv\n      this.vimState.lastVisualSelection = {\n        mode: this.vimState.currentMode,\n        start: this.vimState.cursorStartPosition,\n        end: this.vimState.cursorStopPosition,\n      };\n    }\n\n    this.selectionsChanged.ignoreIntermediateSelections = false;\n  }\n\n  private async executeMovement(movement: BaseMovement): Promise<RecordedState> {\n    this.vimState.lastMovementFailed = false;\n    const recordedState = this.vimState.recordedState;\n    const cursorsToRemove: number[] = [];\n\n    for (let i = 0; i < this.vimState.cursors.length; i++) {\n      /**\n       * Essentially what we're doing here is pretending like the\n       * current VimState only has one cursor (the cursor that we just\n       * iterated to).\n       *\n       * We set the cursor position to be equal to the iterated one,\n       * and then set it back immediately after we're done.\n       *\n       * The slightly more complicated logic here allows us to write\n       * Action definitions without having to think about multiple\n       * cursors in almost all cases.\n       */\n      const oldCursorPositionStart = this.vimState.cursorStartPosition;\n      const oldCursorPositionStop = this.vimState.cursorStopPosition;\n      movement.multicursorIndex = i;\n\n      this.vimState.cursorStartPosition = this.vimState.cursors[i].start;\n      const cursorPosition = this.vimState.cursors[i].stop;\n      this.vimState.cursorStopPosition = cursorPosition;\n\n      const result = await movement.execActionWithCount(\n        cursorPosition,\n        this.vimState,\n        recordedState.count\n      );\n\n      // We also need to update the specific cursor, in case the cursor position was modified inside\n      // the handling functions (e.g. 'it')\n      this.vimState.cursors[i] = new Cursor(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      this.vimState.cursorStartPosition = oldCursorPositionStart;\n      this.vimState.cursorStopPosition = oldCursorPositionStop;\n\n      if (result instanceof Position) {\n        this.vimState.cursors[i] = this.vimState.cursors[i].withNewStop(result);\n\n        if (!isVisualMode(this.currentMode) && !this.vimState.recordedState.operator) {\n          this.vimState.cursors[i] = this.vimState.cursors[i].withNewStart(result);\n        }\n      } else {\n        if (result.failed) {\n          this.vimState.recordedState = new RecordedState();\n          this.vimState.lastMovementFailed = true;\n        }\n\n        if (result.removed) {\n          cursorsToRemove.push(i);\n        } else {\n          this.vimState.cursors[i] = new Cursor(result.start, result.stop);\n        }\n      }\n    }\n\n    if (cursorsToRemove.length > 0) {\n      // Remove the cursors that no longer exist. Remove from the end to the start\n      // so that the index values don't change.\n      for (let i = cursorsToRemove.length - 1; i >= 0; i--) {\n        const idx = cursorsToRemove[i];\n        if (idx !== 0) {\n          // We should never remove the main selection! This shouldn't happen, but just\n          // in case it does, lets protect against it. Remember kids, always use protection!\n          this.vimState.cursors.splice(idx, 1);\n        }\n      }\n    }\n\n    this.vimState.recordedState.count = 0;\n\n    // Keep the cursor within bounds\n    if (this.vimState.currentMode !== Mode.Normal || recordedState.operator) {\n      const stop = this.vimState.cursorStopPosition;\n\n      // Vim does this weird thing where it allows you to select and delete\n      // the newline character, which it places 1 past the last character\n      // in the line. This is why we use > instead of >=.\n\n      if (stop.character > TextEditor.getLineLength(stop.line)) {\n        this.vimState.cursorStopPosition = stop.getLineEnd();\n      }\n    }\n\n    return recordedState;\n  }\n\n  private async executeOperator(): Promise<void> {\n    const recordedState = this.vimState.recordedState;\n    const operator = recordedState.operator!;\n\n    // TODO - if actions were more pure, this would be unnecessary.\n    const startingMode = this.vimState.currentMode;\n    const startingRegisterMode = this.vimState.currentRegisterMode;\n\n    const resultingCursors: Cursor[] = [];\n    for (let [i, { start, stop }] of this.vimState.cursors.entries()) {\n      operator.multicursorIndex = i;\n\n      if (start.isAfter(stop)) {\n        [start, stop] = [stop, start];\n      }\n\n      if (!isVisualMode(startingMode) && startingRegisterMode !== RegisterMode.LineWise) {\n        stop = stop.getLeftThroughLineBreaks(true);\n      }\n\n      if (this.currentMode === Mode.VisualLine) {\n        start = start.getLineBegin();\n        stop = stop.getLineEnd();\n\n        this.vimState.currentRegisterMode = RegisterMode.LineWise;\n      }\n\n      await this.vimState.setCurrentMode(startingMode);\n\n      // We run the repeat version of an operator if the last 2 operators are the same.\n      if (\n        recordedState.operators.length > 1 &&\n        recordedState.operators.reverse()[0].constructor ===\n          recordedState.operators.reverse()[1].constructor\n      ) {\n        await operator.runRepeat(this.vimState, start, recordedState.count);\n      } else {\n        await operator.run(this.vimState, start, stop);\n      }\n\n      for (const transformation of this.vimState.recordedState.transformer.transformations) {\n        if (isTextTransformation(transformation) && transformation.cursorIndex === undefined) {\n          transformation.cursorIndex = operator.multicursorIndex;\n        }\n      }\n\n      const resultingCursor = new Cursor(\n        this.vimState.cursorStartPosition,\n        this.vimState.cursorStopPosition\n      );\n\n      resultingCursors.push(resultingCursor);\n    }\n\n    if (this.vimState.recordedState.transformer.transformations.length > 0) {\n      const transformer = this.vimState.recordedState.transformer;\n      await executeTransformations(this, transformer.transformations);\n    } else {\n      // Keep track of all cursors (in the case of multi-cursor).\n      this.vimState.cursors = resultingCursors;\n    }\n  }\n\n  public async rerunRecordedState(recordedState: RecordedState): Promise<void> {\n    const actions = [...recordedState.actionsRun];\n\n    this.vimState.isRunningDotCommand = true;\n\n    // If a previous visual selection exists, store it for use in replay of some commands\n    if (this.vimState.lastVisualSelection) {\n      this.vimState.dotCommandPreviousVisualSelection = new vscode.Selection(\n        this.vimState.lastVisualSelection.start,\n        this.vimState.lastVisualSelection.end\n      );\n    }\n\n    recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n\n    for (const [i, action] of actions.entries()) {\n      recordedState.actionsRun = actions.slice(0, i + 1);\n      await this.runAction(recordedState, action);\n\n      if (this.vimState.lastMovementFailed) {\n        // TODO: Shouldn't this be `break`? Can't this leave us in a very bad state?\n        return;\n      }\n\n      await this.updateView();\n    }\n    recordedState.actionsRun = actions;\n    this.vimState.isRunningDotCommand = false;\n  }\n\n  public async runMacro(recordedMacro: RecordedState): Promise<void> {\n    let recordedState = new RecordedState();\n    this.vimState.recordedState = recordedState;\n    this.vimState.isRunningDotCommand = true;\n\n    for (const action of recordedMacro.actionsRun) {\n      const originalLocation = Jump.fromStateNow(this.vimState);\n\n      this.vimState.cursorsInitialState = this.vimState.cursors;\n\n      recordedState.actionsRun.push(action);\n\n      await this.runAction(recordedState, action);\n\n      // We just finished a full action; let's clear out our current state.\n      if (this.vimState.recordedState.actionsRun.length === 0) {\n        recordedState = new RecordedState();\n        this.vimState.recordedState = recordedState;\n      }\n\n      if (this.vimState.lastMovementFailed) {\n        break;\n      }\n\n      await this.updateView();\n\n      if (action.isJump) {\n        globalState.jumpTracker.recordJump(originalLocation, Jump.fromStateNow(this.vimState));\n      }\n    }\n\n    this.vimState.isRunningDotCommand = false;\n    this.vimState.cursorsInitialState = this.vimState.cursors;\n  }\n\n  public updateSearchHighlights(showHighlights: boolean) {\n    const cacheKey = this.searchDecorationCacheKey;\n    this.searchDecorationCacheKey = undefined;\n\n    let decorations: SearchDecorations | undefined;\n    if (showHighlights) {\n      if (\n        this.vimState.modeData.mode === Mode.CommandlineInProgress ||\n        this.vimState.modeData.mode === Mode.SearchInProgressMode\n      ) {\n        decorations = this.vimState.modeData.commandLine.getDecorations(this.vimState);\n      } else if (globalState.searchState) {\n        if (\n          cacheKey &&\n          cacheKey.searchString === globalState.searchState.searchString &&\n          cacheKey.documentVersion === this.vimState.document.version\n        ) {\n          // The decorations are fine as-is, don't waste time re-calculating\n          this.searchDecorationCacheKey = cacheKey;\n          return;\n        }\n        // If there are no decorations from the command line, get decorations for previous SearchState\n        decorations = getDecorationsForSearchMatchRanges(\n          globalState.searchState.getMatchRanges(this.vimState)\n        );\n        this.searchDecorationCacheKey = {\n          searchString: globalState.searchState.searchString,\n          documentVersion: this.vimState.document.version,\n        };\n      }\n    }\n\n    this.vimState.editor.setDecorations(\n      decoration.searchHighlight,\n      decorations?.searchHighlight ?? []\n    );\n    this.vimState.editor.setDecorations(decoration.searchMatch, decorations?.searchMatch ?? []);\n    this.vimState.editor.setDecorations(\n      decoration.substitutionAppend,\n      decorations?.substitutionAppend ?? []\n    );\n    this.vimState.editor.setDecorations(\n      decoration.substitutionReplace,\n      decorations?.substitutionReplace ?? []\n    );\n  }\n\n  public async updateView(\n    args: { drawSelection: boolean; revealRange: boolean } = {\n      drawSelection: true,\n      revealRange: true,\n    }\n  ): Promise<void> {\n    // Draw selection (or cursor)\n    if (args.drawSelection) {\n      let selectionMode: Mode = this.vimState.currentMode;\n      if (this.vimState.modeData.mode === Mode.SearchInProgressMode) {\n        selectionMode = this.vimState.modeData.commandLine.previousMode;\n      } else if (this.vimState.modeData.mode === Mode.CommandlineInProgress) {\n        selectionMode = this.vimState.modeData.commandLine.previousMode;\n      } else if (this.vimState.modeData.mode === Mode.SurroundInputMode) {\n        selectionMode = this.vimState.surround!.previousMode;\n      }\n\n      let selections = [] as vscode.Selection[];\n      for (const cursor of this.vimState.cursors) {\n        let { start, stop } = cursor;\n        switch (selectionMode) {\n          case Mode.Visual:\n            /**\n             * Always select the letter that we started visual mode on, no matter\n             * if we are in front or behind it. Imagine that we started visual mode\n             * with some text like this:\n             *\n             *   abc|def\n             *\n             * (The | represents the cursor.) If we now press w, we'll select def,\n             * but if we hit b we expect to select abcd, so we need to getRight() on the\n             * start of the selection when it precedes where we started visual mode.\n             */\n            if (start.isAfterOrEqual(stop)) {\n              start = start.getRight();\n            }\n\n            selections.push(new vscode.Selection(start, stop));\n            break;\n\n          case Mode.VisualLine:\n            if (start.isBeforeOrEqual(stop)) {\n              selections.push(new vscode.Selection(start.getLineBegin(), stop.getLineEnd()));\n            } else {\n              selections.push(new vscode.Selection(start.getLineEnd(), stop.getLineBegin()));\n            }\n            break;\n\n          case Mode.VisualBlock:\n            for (const line of TextEditor.iterateLinesInBlock(this.vimState, cursor)) {\n              selections.push(\n                new vscode.Selection(\n                  this.vimState.document.validatePosition(line.start),\n                  this.vimState.document.validatePosition(line.end)\n                )\n              );\n            }\n            break;\n\n          default:\n            // Note that this collapses the selection onto one position\n            selections.push(new vscode.Selection(stop, stop));\n            break;\n        }\n      }\n\n      /**\n       * Combine instersected selections - When we have multiple cursors\n       * sometimes those cursors selections intersect and combine, we need\n       * to check that here so that we know if our currents cursors will\n       * trigger a selectionChangeEvent or not. If we didn't check for this\n       * vscode might already have the resulting combined selection selected\n       * but since that wouldn't be the same as our selections we would think\n       * there would be a selectionChangeEvent when there wouldn't be any.\n       */\n      const getSelectionsCombined = (sel: vscode.Selection[]) => {\n        const combinedSelections: vscode.Selection[] = [];\n        sel.forEach((s, i) => {\n          if (i > 0) {\n            const previousSelection = combinedSelections[combinedSelections.length - 1];\n            const overlap = s.intersection(previousSelection);\n            if (overlap) {\n              // If anchor is after active we have a backwards selection and in that case we want\n              // the anchor that is lower and/or to the right and the active that is up and/or to\n              // the left. Otherwise we want the anchor that is upper and/or to the left and the\n              // active that is lower and/or to the right.\n\n              let anchor: Position;\n              let active: Position;\n              if (s.anchor.isBeforeOrEqual(s.active)) {\n                // Forwards Selection\n\n                // Get min anchor\n                if (s.anchor.isBeforeOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get max active\n                if (s.active.isAfterOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              } else {\n                // Backwards Selection\n\n                // Get max anchor\n                if (s.anchor.isAfterOrEqual(previousSelection.anchor)) {\n                  anchor = s.anchor;\n                } else {\n                  anchor = previousSelection.anchor;\n                }\n\n                // Get min active\n                if (s.active.isBeforeOrEqual(previousSelection.active)) {\n                  active = s.active;\n                } else {\n                  active = previousSelection.active;\n                }\n              }\n              combinedSelections[combinedSelections.length - 1] = new vscode.Selection(\n                anchor,\n                active\n              );\n            } else {\n              combinedSelections.push(s);\n            }\n          } else {\n            combinedSelections.push(s);\n          }\n        });\n        return combinedSelections;\n      };\n      selections = getSelectionsCombined(selections);\n\n      // Check if the selection we are going to set is different than the current one.\n      // If they are the same vscode won't trigger a selectionChangeEvent so we don't\n      // have to add it to the ignore selections.\n      const willTriggerChange =\n        selections.length !== this.vimState.editor.selections.length ||\n        selections.some(\n          (s, i) =>\n            !s.anchor.isEqual(this.vimState.editor.selections[i].anchor) ||\n            !s.active.isEqual(this.vimState.editor.selections[i].active)\n        );\n\n      if (willTriggerChange) {\n        const selectionsHash = selections.reduce(\n          (hash, s) =>\n            hash +\n            `[${s.anchor.line}, ${s.anchor.character}; ${s.active.line}, ${s.active.character}]`,\n          ''\n        );\n        this.selectionsChanged.ourSelections.push(selectionsHash);\n        ModeHandler.logger.debug(\n          `Selections: Adding Selection Change to be Ignored! (total: ${\n            this.selectionsChanged.ourSelections.length\n          }) Hash: ${selectionsHash}, Selections: ${selections[0].anchor.toString()}, ${selections[0].active.toString()}`\n        );\n      }\n\n      this.vimState.editor.selections = selections;\n    }\n\n    // Scroll to position of cursor\n    if (\n      this.vimState.editor.visibleRanges.length > 0 &&\n      !this.vimState.postponedCodeViewChanges.some((change) => change.command === 'editorScroll')\n    ) {\n      /**\n       * This variable decides to which cursor we scroll the view.\n       * It is meant as a patch to #880.\n       * Extend this condition if it is the desired behaviour for other actions as well.\n       */\n      const isLastCursorTracked =\n        this.vimState.recordedState.actionsRun[\n          this.vimState.recordedState.actionsRun.length - 1\n        ] instanceof ActionOverrideCmdD;\n\n      let cursorToTrack: Cursor;\n      if (isLastCursorTracked) {\n        cursorToTrack = this.vimState.cursors[this.vimState.cursors.length - 1];\n      } else {\n        cursorToTrack = this.vimState.cursors[0];\n      }\n\n      const isCursorAboveRange = (visibleRange: vscode.Range): boolean =>\n        visibleRange.start.line - cursorToTrack.stop.line >= 15;\n      const isCursorBelowRange = (visibleRange: vscode.Range): boolean =>\n        cursorToTrack.stop.line - visibleRange.end.line >= 15;\n\n      const { visibleRanges } = this.vimState.editor;\n      const centerViewportAroundCursor =\n        visibleRanges.every(isCursorAboveRange) || visibleRanges.every(isCursorBelowRange);\n\n      const revealType = centerViewportAroundCursor\n        ? vscode.TextEditorRevealType.InCenter\n        : vscode.TextEditorRevealType.Default;\n\n      if (this.vimState.modeData.mode === Mode.SearchInProgressMode && configuration.incsearch) {\n        const currentMatch = this.vimState.modeData.commandLine.getCurrentMatchRange(this.vimState);\n\n        if (currentMatch) {\n          this.vimState.editor.revealRange(currentMatch.range, revealType);\n        } else if (this.vimState.modeData.mode === Mode.SearchInProgressMode) {\n          const offset =\n            this.vimState.editor.visibleRanges[0].start.line -\n            this.vimState.modeData.firstVisibleLineBeforeSearch;\n          scrollView(this.vimState, offset);\n        }\n      } else if (args.revealRange) {\n        if (\n          !isLastCursorTracked ||\n          this.vimState.cursorsInitialState.length !== this.vimState.cursors.length\n        ) {\n          /**\n           * We scroll the view if either:\n           * 1. the cursor we want to keep in view is the main one (this is the \"standard\"\n           * (before this commit) situation)\n           * 2. if we track the last cursor, but no additional cursor was created in this step\n           * (in the Cmd+D situation this means that no other matches were found)\n           */\n          this.vimState.editor.revealRange(\n            new vscode.Range(cursorToTrack.stop, cursorToTrack.stop),\n            revealType\n          );\n        }\n      }\n    }\n\n    // cursor style\n    let cursorStyle = configuration.getCursorStyleForMode(Mode[this.currentMode]);\n    if (!cursorStyle) {\n      const cursorType = getCursorType(\n        this.vimState,\n        this.vimState.currentModeIncludingPseudoModes\n      );\n      cursorStyle = getCursorStyle(cursorType);\n      if (\n        cursorType === VSCodeVimCursorType.Native &&\n        configuration.editorCursorStyle !== undefined\n      ) {\n        cursorStyle = configuration.editorCursorStyle;\n      }\n    }\n    this.vimState.editor.options.cursorStyle = cursorStyle;\n\n    // cursor block\n    const cursorRange: vscode.Range[] = [];\n    if (\n      getCursorType(this.vimState, this.currentMode) === VSCodeVimCursorType.TextDecoration &&\n      this.currentMode !== Mode.Insert\n    ) {\n      // Fake block cursor with text decoration. Unfortunately we can't have a cursor\n      // in the middle of a selection natively, which is what we need for Visual Mode.\n      if (this.currentMode === Mode.Visual) {\n        for (const { start: cursorStart, stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStart.isBefore(cursorStop)) {\n            cursorRange.push(new vscode.Range(cursorStop.getLeft(), cursorStop));\n          } else {\n            cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n          }\n        }\n      } else {\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          cursorRange.push(new vscode.Range(cursorStop, cursorStop.getRight()));\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.default, cursorRange);\n\n    // Insert Mode virtual characters: used to temporarily show the remapping pressed keys on\n    // insert mode, to show the `\"` character after pressing `<C-r>`, and to show `?` and the\n    // first character when inserting digraphs with `<C-k>`.\n    const iModeVirtualCharDecorationOptions: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentMode === Mode.Insert || this.vimState.currentMode === Mode.Replace) {\n      let virtualKey: string | undefined;\n      if (this.vimState.recordedState.bufferedKeys.length > 0) {\n        virtualKey =\n          this.vimState.recordedState.bufferedKeys[\n            this.vimState.recordedState.bufferedKeys.length - 1\n          ];\n      } else if (this.vimState.recordedState.waitingForAnotherActionKey) {\n        virtualKey =\n          this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n        if (virtualKey === '<C-r>') {\n          virtualKey = '\"';\n        } else if (virtualKey === '<C-k>') {\n          virtualKey = '?';\n        }\n      }\n      // Don't show keys with `<` like `<C-x>` but show everything else\n      virtualKey = virtualKey && /<[^>]+>/.test(virtualKey) ? undefined : virtualKey;\n\n      if (virtualKey) {\n        // Normal Render Options with the key to overlap on the next character\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n          },\n        };\n\n        /**\n         * EOL Render Options:\n         * Some times when at the end of line the `currentColor` won't work, or it might be\n         * transparent, so we set the color to 'editor.foreground' when at EOL to avoid the\n         * virtualKey character not showing up.\n         */\n        const eolRenderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: virtualKey,\n            color: new vscode.ThemeColor('editor.foreground'),\n          },\n        };\n\n        for (const { stop: cursorStop } of this.vimState.cursors) {\n          if (cursorStop.isLineEnd()) {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getLineEndIncludingEOL()),\n              renderOptions: eolRenderOptions,\n            });\n          } else {\n            iModeVirtualCharDecorationOptions.push({\n              range: new vscode.Range(cursorStop, cursorStop.getRightThroughLineBreaks(true)),\n              renderOptions,\n            });\n          }\n        }\n      }\n    }\n\n    this.vimState.editor.setDecorations(\n      decoration.insertModeVirtualCharacter,\n      iModeVirtualCharDecorationOptions\n    );\n\n    // OperatorPendingMode half block cursor\n    const opCursorDecorations: vscode.DecorationOptions[] = [];\n    const opCursorCharDecorations: vscode.DecorationOptions[] = [];\n    if (this.vimState.currentModeIncludingPseudoModes === Mode.OperatorPendingMode) {\n      for (const { stop: cursorStop } of this.vimState.cursors) {\n        let text = TextEditor.getCharAt(this.vimState.document, cursorStop);\n        // the ' ' (<space>) needs to be changed to '&nbsp;'\n        text = text === ' ' ? '\\u00a0' : text;\n        const renderOptions: vscode.ThemableDecorationRenderOptions = {\n          before: {\n            contentText: text,\n          },\n        };\n        opCursorDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n        opCursorCharDecorations.push({\n          range: new vscode.Range(cursorStop, cursorStop.getRight()),\n          renderOptions,\n        });\n      }\n    }\n\n    this.vimState.editor.setDecorations(decoration.operatorPendingModeCursor, opCursorDecorations);\n    this.vimState.editor.setDecorations(\n      decoration.operatorPendingModeCursorChar,\n      opCursorCharDecorations\n    );\n\n    for (const markDecoration of decoration.allMarkDecorations()) {\n      this.vimState.editor.setDecorations(markDecoration, []);\n    }\n\n    if (configuration.showMarksInGutter) {\n      for (const mark of this.vimState.historyTracker.getMarks()) {\n        if (mark.isUppercaseMark && mark.document !== this.vimState.document) {\n          continue;\n        }\n\n        const markDecoration = decoration.getOrCreateMarkDecoration(mark.name);\n        const markLine = mark.position.getLineBegin();\n        const markRange = new vscode.Range(markLine, markLine);\n\n        this.vimState.editor.setDecorations(markDecoration, [markRange]);\n      }\n    }\n\n    const showHighlights =\n      (configuration.incsearch &&\n        (this.currentMode === Mode.SearchInProgressMode ||\n          this.currentMode === Mode.CommandlineInProgress)) ||\n      (configuration.inccommand && this.currentMode === Mode.CommandlineInProgress) ||\n      (configuration.hlsearch && globalState.hl);\n    for (const editor of vscode.window.visibleTextEditors) {\n      const mh = this.handlerMap.get(editor.document.uri);\n      if (mh) {\n        mh.updateSearchHighlights(showHighlights);\n      }\n    }\n\n    const easyMotionDimRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      configuration.easymotionDimBackground &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? [\n            new vscode.Range(\n              TextEditor.getDocumentBegin(),\n              TextEditor.getDocumentEnd(this.vimState.document)\n            ),\n          ]\n        : [];\n    const easyMotionHighlightRanges =\n      this.currentMode === Mode.EasyMotionInputMode &&\n      this.vimState.easyMotion.searchAction instanceof SearchByNCharCommand\n        ? this.vimState.easyMotion.searchAction\n            .getMatches(this.vimState.cursorStopPosition, this.vimState)\n            .map((match) => match.toRange())\n        : [];\n    this.vimState.editor.setDecorations(decoration.easyMotionDimIncSearch, easyMotionDimRanges);\n    this.vimState.editor.setDecorations(decoration.easyMotionIncSearch, easyMotionHighlightRanges);\n\n    for (const viewChange of this.vimState.postponedCodeViewChanges) {\n      vscode.commands.executeCommand(viewChange.command, viewChange.args);\n    }\n    this.vimState.postponedCodeViewChanges = [];\n\n    if (this.currentMode === Mode.EasyMotionMode) {\n      // Update all EasyMotion decorations\n      this.vimState.easyMotion.updateDecorations(this.vimState.editor);\n    }\n\n    StatusBar.clear(this.vimState, false);\n\n    // NOTE: this is not being awaited to save the 15-20ms block - I think this is fine\n    VSCodeContext.set('vim.mode', Mode[this.vimState.currentMode]);\n\n    // Tell VSCode that the cursor position changed, so it updates its highlights for `editor.occurrencesHighlight`.\n    const range = new vscode.Range(\n      this.vimState.cursorStartPosition,\n      this.vimState.cursorStopPosition\n    );\n    if (!/\\s+/.test(this.vimState.document.getText(range))) {\n      vscode.commands.executeCommand('editor.action.wordHighlight.trigger');\n    }\n  }\n\n  // Return true if a new undo point should be created based on brackets and parentheses\n  private createUndoPointForBrackets(): boolean {\n    // }])> keys all start a new undo state when directly next to an {[(< opening character\n    const key =\n      this.vimState.recordedState.actionKeys[this.vimState.recordedState.actionKeys.length - 1];\n\n    if (key === undefined) {\n      return false;\n    }\n\n    if (this.vimState.currentMode === Mode.Insert) {\n      // Check if the keypress is a closing bracket to a corresponding opening bracket right next to it\n      let result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition,\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.isEqual(result)) {\n          return true;\n        }\n      }\n\n      result = PairMatcher.nextPairedChar(\n        this.vimState.cursorStopPosition.getLeft(),\n        key,\n        this.vimState,\n        false\n      );\n      if (result !== undefined) {\n        if (this.vimState.cursorStopPosition.getLeft(2).isEqual(result)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  dispose() {\n    this.disposables.map((d) => d.dispose());\n  }\n}\n\nfunction getCursorType(vimState: VimState, mode: Mode): VSCodeVimCursorType {\n  switch (mode) {\n    case Mode.Normal:\n      return VSCodeVimCursorType.Block;\n    case Mode.Insert:\n      return VSCodeVimCursorType.Native;\n    case Mode.Visual:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualBlock:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.VisualLine:\n      return VSCodeVimCursorType.TextDecoration;\n    case Mode.SearchInProgressMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.CommandlineInProgress:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Replace:\n      return VSCodeVimCursorType.Underline;\n    case Mode.EasyMotionMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.EasyMotionInputMode:\n      return VSCodeVimCursorType.Block;\n    case Mode.SurroundInputMode:\n      return getCursorType(vimState, vimState.surround!.previousMode);\n    case Mode.OperatorPendingMode:\n      return VSCodeVimCursorType.UnderlineThin;\n    case Mode.Disabled:\n    default:\n      return VSCodeVimCursorType.Line;\n  }\n}\n","import { TextEditor, Uri } from 'vscode';\nimport { ModeHandler } from './modeHandler';\n\n/**\n * Stores one ModeHandler (and therefore VimState) per TextDocument.\n */\nclass ModeHandlerMapImpl {\n  private modeHandlerMap = new Map<Uri, ModeHandler>();\n\n  public async getOrCreate(editor: TextEditor): Promise<[ModeHandler, boolean]> {\n    const editorId = editor.document.uri;\n\n    let isNew = false;\n    let modeHandler: ModeHandler | undefined = this.get(editorId);\n\n    if (!modeHandler) {\n      isNew = true;\n      modeHandler = await ModeHandler.create(this, editor);\n      this.modeHandlerMap.set(editorId, modeHandler);\n    }\n    return [modeHandler, isNew];\n  }\n\n  public get(uri: Uri): ModeHandler | undefined {\n    return this.modeHandlerMap.get(uri);\n  }\n\n  public keys(): IterableIterator<Uri> {\n    return this.modeHandlerMap.keys();\n  }\n\n  public getAll(): ModeHandler[] {\n    return [...this.modeHandlerMap.values()];\n  }\n\n  public delete(editorId: Uri) {\n    const modeHandler = this.modeHandlerMap.get(editorId);\n    if (modeHandler) {\n      modeHandler.dispose();\n      this.modeHandlerMap.delete(editorId);\n    }\n  }\n\n  public clear() {\n    for (const key of this.modeHandlerMap.keys()) {\n      this.delete(key);\n    }\n  }\n}\n\nexport const ModeHandlerMap = new ModeHandlerMapImpl();\n","export const SUPPORT_VIMRC = false;\nexport const SUPPORT_NVIM = false;\nexport const SUPPORT_IME_SWITCHER = false;\nexport const SUPPORT_READ_COMMAND = false;\n","import * as vscode from 'vscode';\n\nexport const constants = {\n  UV_FS_SYMLINK_DIR: 1,\n  UV_FS_SYMLINK_JUNCTION: 2,\n  O_RDONLY: 0,\n  O_WRONLY: 1,\n  O_RDWR: 2,\n  UV_DIRENT_UNKNOWN: 0,\n  UV_DIRENT_FILE: 1,\n  UV_DIRENT_DIR: 2,\n  UV_DIRENT_LINK: 3,\n  UV_DIRENT_FIFO: 4,\n  UV_DIRENT_SOCKET: 5,\n  UV_DIRENT_CHAR: 6,\n  UV_DIRENT_BLOCK: 7,\n  S_IFMT: 61440,\n  S_IFREG: 32768,\n  S_IFDIR: 16384,\n  S_IFCHR: 8192,\n  S_IFBLK: 24576,\n  S_IFIFO: 4096,\n  S_IFLNK: 40960,\n  S_IFSOCK: 49152,\n  O_CREAT: 512,\n  O_EXCL: 2048,\n  UV_FS_O_FILEMAP: 0,\n  O_NOCTTY: 131072,\n  O_TRUNC: 1024,\n  O_APPEND: 8,\n  O_DIRECTORY: 1048576,\n  O_NOFOLLOW: 256,\n  O_SYNC: 128,\n  O_DSYNC: 4194304,\n  O_SYMLINK: 2097152,\n  O_NONBLOCK: 4,\n  S_IRWXU: 448,\n  S_IRUSR: 256,\n  S_IWUSR: 128,\n  S_IXUSR: 64,\n  S_IRWXG: 56,\n  S_IRGRP: 32,\n  S_IWGRP: 16,\n  S_IXGRP: 8,\n  S_IRWXO: 7,\n  S_IROTH: 4,\n  S_IWOTH: 2,\n  S_IXOTH: 1,\n  F_OK: 0,\n  R_OK: 4,\n  W_OK: 2,\n  X_OK: 1,\n  UV_FS_COPYFILE_EXCL: 1,\n  COPYFILE_EXCL: 1,\n  UV_FS_COPYFILE_FICLONE: 2,\n  COPYFILE_FICLONE: 2,\n  UV_FS_COPYFILE_FICLONE_FORCE: 4,\n  COPYFILE_FICLONE_FORCE: 4,\n};\n\nexport async function doesFileExist(fileUri: vscode.Uri) {\n  try {\n    await vscode.workspace.fs.stat(fileUri);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nexport async function existsAsync(path: string): Promise<boolean> {\n  try {\n    await vscode.workspace.fs.stat(vscode.Uri.parse(path));\n    return true;\n  } catch (_e) {\n    return false;\n  }\n}\n\nexport async function unlink(path: string): Promise<void> {\n  await vscode.workspace.fs.delete(vscode.Uri.parse(path));\n}\n\nexport async function readFileAsync(path: string, encoding: BufferEncoding): Promise<string> {\n  const ret = await vscode.workspace.fs.readFile(vscode.Uri.parse(path));\n  return ret.toString();\n}\n\nexport async function mkdirAsync(path: string, options: any): Promise<void> {\n  return vscode.workspace.fs.createDirectory(vscode.Uri.parse(path));\n}\n\nexport async function writeFileAsync(\n  path: string,\n  content: string,\n  encoding: BufferEncoding\n): Promise<void> {\n  return vscode.workspace.fs.writeFile(vscode.Uri.parse(path), Buffer.from(content));\n}\n\nexport async function accessAsync(path: string, mode: number) {\n  // no op in nodeless\n}\n\nexport async function chmodAsync(path: string, mode: string | number) {\n  // no op in nodeless\n}\n\nexport function unlinkSync(path: string) {\n  // no op in nodeless\n}\n","import * as vscode from 'vscode';\nimport { ILogger } from '../common/logger';\n\nexport class HistoryBase {\n  private readonly context: vscode.ExtensionContext;\n  private readonly historyFileName: string;\n  private history: string[] = [];\n\n  get historyKey(): string {\n    return `vim.${this.historyFileName}`;\n  }\n\n  constructor(\n    context: vscode.ExtensionContext,\n    historyFileName: string,\n    extensionStoragePath: string,\n    logger: ILogger\n  ) {\n    this.context = context;\n    this.historyFileName = historyFileName;\n  }\n\n  public async add(value: string | undefined, history: number): Promise<void> {\n    if (!value || value.length === 0) {\n      return;\n    }\n\n    // remove duplicates\n    const index: number = this.history.indexOf(value);\n    if (index !== -1) {\n      this.history.splice(index, 1);\n    }\n\n    // append to the end\n    this.history.push(value);\n\n    // resize array if necessary\n    if (this.history.length > history) {\n      this.history = this.history.slice(this.history.length - history);\n    }\n\n    return this.save();\n  }\n\n  public get(history: number): string[] {\n    // resize array if necessary\n    if (this.history.length > history) {\n      this.history = this.history.slice(this.history.length - history);\n    }\n\n    return this.history;\n  }\n\n  public async clear() {\n    this.context.workspaceState.update(this.historyKey, undefined);\n    this.history = [];\n  }\n\n  public async load(): Promise<void> {\n    const data = this.context.workspaceState.get<string>(this.historyKey) || '';\n    if (data.length === 0) {\n      return;\n    }\n\n    const parsedData = JSON.parse(data);\n    if (!Array.isArray(parsedData)) {\n      throw Error('Unexpected format in history. Expected JSON.');\n    }\n    this.history = parsedData;\n  }\n\n  async save(): Promise<void> {\n    this.context.workspaceState.update(this.historyKey, JSON.stringify(this.history));\n  }\n}\n","import { IConfiguration } from '../../configuration/iconfiguration';\nimport { ILogger } from 'src/platform/common/logger';\n\n/**\n * Displays VSCode message to user\n */\nexport class VsCodeMessage implements ILogger {\n  actionMessages = ['Dismiss', 'Suppress Errors'];\n  private prefix: string;\n  configuration?: IConfiguration;\n\n  constructor(prefix: string) {\n    this.prefix = prefix;\n  }\n\n  error(errorMessage: string): void {\n    this.log({ level: 'error', message: errorMessage });\n  }\n\n  debug(debugMessage: string): void {\n    this.log({ level: 'debug', message: debugMessage });\n  }\n\n  warn(warnMessage: string): void {\n    this.log({ level: 'warn', message: warnMessage });\n  }\n\n  verbose(verboseMessage: string): void {\n    this.log({ level: 'verbose', message: verboseMessage });\n  }\n\n  private async log(info: { level: string; message: string }) {\n    if (this.configuration && this.configuration.debug.silent) {\n      return;\n    }\n    let showMessage: (message: string, ...items: string[]) => void;\n    switch (info.level) {\n      case 'error':\n        showMessage = console.error;\n        break;\n      case 'warn':\n        showMessage = console.warn;\n        break;\n      case 'info':\n      case 'verbose':\n      case 'debug':\n        showMessage = console.log;\n        break;\n      default:\n        throw Error(`Unsupported log level ${info.level}`);\n    }\n\n    showMessage(`${this.prefix}: ${info.message}`, ...this.actionMessages);\n  }\n\n  public configChanged(configuration: IConfiguration): void {\n    this.configuration = configuration;\n  }\n}\n\nexport class LoggerImpl {\n  static get(prefix: string): ILogger {\n    return new VsCodeMessage(prefix);\n  }\n}\n","import { Clipboard } from './../util/clipboard';\nimport {\n  ActionDeleteChar,\n  ActionDeleteCharVisualLineMode,\n  ActionDeleteCharWithDeleteKey,\n  ActionDeleteLastChar,\n  CommandRegister,\n  CommandYankFullLine,\n} from './../actions/commands/actions';\nimport { DeleteOperator, YankOperator } from './../actions/operator';\nimport { RecordedState } from './../state/recordedState';\nimport { VimState } from './../state/vimState';\nimport { readFileAsync, writeFileAsync } from 'platform/fs';\nimport { Globals } from '../globals';\n\n/**\n * This is included in the register file.\n * Whenever the format saved to disk changes, so should this.\n */\nconst REGISTER_FORMAT_VERSION = '1.0';\n\n/**\n * There are two different modes of copy/paste in Vim - copy by character\n * and copy by line. Copy by line typically happens in Visual Line mode, but\n * also shows up in some other actions that work over lines (most notably dd,\n * yy).\n */\nexport enum RegisterMode {\n  CharacterWise,\n  LineWise,\n  BlockWise,\n}\n\nexport type RegisterContent = string | RecordedState;\n\nexport interface IRegisterContent {\n  text: RegisterContent;\n  registerMode: RegisterMode;\n}\n\nexport class Register {\n  private static readonly specialRegisters: readonly string[] = [\n    '\"', // Unnamed (default)\n    '*', // Clipboard\n    '+', // Clipboard\n    '.', // Last inserted text\n    '-', // Last deleted text less than a line\n    '/', // Most recently executed search\n    ':', // Most recently executed command\n    '%', // Current file path (relative to workspace root)\n    '#', // Previous file path (relative to workspace root)\n    '_', // Black hole (always empty)\n  ];\n\n  private static registers: Map<string, IRegisterContent[]>;\n\n  /**\n   * Puts given content in the currently selected register, using the current RegisterMode.\n   *\n   * @param copyToUnnamed: If true, set the unnamed register (\") as well\n   */\n  public static put(\n    vimState: VimState,\n    content: RegisterContent,\n    multicursorIndex?: number,\n    copyToUnnamed?: boolean\n  ): void {\n    const register = vimState.recordedState.registerName;\n\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    if (Register.isBlackHoleRegister(register) || Register.isReadOnlyRegister(register)) {\n      return;\n    }\n\n    if (Register.isValidUppercaseRegister(register)) {\n      Register.appendToRegister(vimState, register.toLowerCase(), content, multicursorIndex ?? 0);\n    } else {\n      Register.overwriteRegister(vimState, register, content, multicursorIndex ?? 0);\n    }\n\n    if (copyToUnnamed && register !== '\"') {\n      Register.registers.set('\"', Register.registers.get(register)!);\n    }\n  }\n\n  public static isValidRegister(register: string): boolean {\n    return (\n      Register.isValidLowercaseRegister(register) ||\n      Register.isValidUppercaseRegister(register) ||\n      /^[0-9]$/.test(register) ||\n      this.specialRegisters.includes(register)\n    );\n  }\n\n  public static isValidRegisterForMacro(register: string): boolean {\n    return /^[a-zA-Z0-9:]$/.test(register);\n  }\n\n  private static isBlackHoleRegister(registerName: string): boolean {\n    return registerName === '_';\n  }\n\n  private static isClipboardRegister(registerName: string): boolean {\n    return registerName === '*' || registerName === '+';\n  }\n\n  private static isReadOnlyRegister(registerName: string): boolean {\n    return ['.', '%', ':', '#', '/'].includes(registerName);\n  }\n\n  private static isValidLowercaseRegister(register: string): boolean {\n    return /^[a-z]$/.test(register);\n  }\n\n  public static isValidUppercaseRegister(register: string): boolean {\n    return /^[A-Z]$/.test(register);\n  }\n\n  /**\n   * Puts the content at the specified index of the multicursor Register.\n   * If multicursorIndex === 0, the register will be completely overwritten. Otherwise, just that index will be.\n   */\n  private static overwriteRegister(\n    vimState: VimState,\n    register: string,\n    content: RegisterContent,\n    multicursorIndex: number\n  ): void {\n    if (multicursorIndex === 0 || !Register.registers.has(register)) {\n      Register.registers.set(register, []);\n    }\n\n    Register.registers.get(register)![multicursorIndex] = {\n      registerMode: vimState.currentRegisterMode,\n      text: content,\n    };\n\n    if (\n      multicursorIndex === 0 &&\n      this.isClipboardRegister(register) &&\n      !(content instanceof RecordedState)\n    ) {\n      Clipboard.Copy(content);\n    }\n\n    this.processNumberedRegisters(vimState, content);\n  }\n\n  /**\n   * Appends the content at the specified index of the multicursor Register.\n   */\n  private static appendToRegister(\n    vimState: VimState,\n    register: string,\n    content: RegisterContent,\n    multicursorIndex: number\n  ): void {\n    if (!Register.registers.has(register)) {\n      Register.registers.set(register, []);\n    }\n\n    const contentByCursor = Register.registers.get(register)!;\n    const oldContent = contentByCursor[multicursorIndex];\n    if (oldContent === undefined) {\n      contentByCursor[multicursorIndex] = {\n        registerMode: vimState.currentRegisterMode,\n        text: content,\n      };\n    } else {\n      // Line-wise trumps other RegisterModes\n      const registerMode =\n        vimState.currentRegisterMode === RegisterMode.LineWise\n          ? RegisterMode.LineWise\n          : oldContent.registerMode;\n      let newText: RegisterContent;\n      if (oldContent.text instanceof RecordedState || content instanceof RecordedState) {\n        newText = oldContent.text;\n      } else {\n        newText = oldContent.text + (registerMode === RegisterMode.LineWise ? '\\n' : '') + content;\n      }\n      contentByCursor[multicursorIndex] = {\n        registerMode,\n        text: newText,\n      };\n    }\n\n    if (multicursorIndex === 0 && this.isClipboardRegister(register)) {\n      const newContent = contentByCursor[multicursorIndex].text;\n      if (!(newContent instanceof RecordedState)) {\n        Clipboard.Copy(newContent);\n      }\n    }\n  }\n\n  /**\n   * Updates a readonly register's content. This is the only way to do so.\n   */\n  public static setReadonlyRegister(\n    register: '.' | '%' | ':' | '#' | '/',\n    content: RegisterContent\n  ) {\n    Register.registers.set(register, [\n      {\n        text: content,\n        registerMode: RegisterMode.CharacterWise,\n      },\n    ]);\n  }\n\n  /**\n   * Handles special cases for Yank- and DeleteOperator.\n   */\n  private static processNumberedRegisters(vimState: VimState, content: RegisterContent): void {\n    // Find the BaseOperator of the current actions\n    const baseOperator = vimState.recordedState.operator || vimState.recordedState.command;\n\n    if (baseOperator instanceof YankOperator || baseOperator instanceof CommandYankFullLine) {\n      // 'yank' to 0 only if no register was specified\n      const registerCommand = vimState.recordedState.actionsRun.find((value) => {\n        return value instanceof CommandRegister;\n      });\n\n      if (!registerCommand) {\n        Register.registers.set('0', [\n          {\n            text: content,\n            registerMode: vimState.currentRegisterMode,\n          },\n        ]);\n      }\n    } else if (\n      (baseOperator instanceof DeleteOperator ||\n        baseOperator instanceof ActionDeleteChar ||\n        baseOperator instanceof ActionDeleteLastChar ||\n        baseOperator instanceof ActionDeleteCharVisualLineMode ||\n        baseOperator instanceof ActionDeleteCharWithDeleteKey) &&\n      !(vimState.macro !== undefined || vimState.isReplayingMacro)\n    ) {\n      if (\n        !content.toString().match(/\\n/g) &&\n        vimState.currentRegisterMode !== RegisterMode.LineWise\n      ) {\n        Register.registers.set('-', [\n          {\n            text: content,\n            registerMode: RegisterMode.CharacterWise,\n          },\n        ]);\n      } else {\n        // shift 'delete-history' register\n        for (let index = 9; index > 1; index--) {\n          const previous = Register.registers.get(String(index - 1));\n          if (previous) {\n            Register.registers.set(String(index), { ...previous });\n          }\n        }\n\n        // Paste last delete into register '1'\n        Register.registers.set('1', [\n          {\n            text: content,\n            registerMode: vimState.currentRegisterMode,\n          },\n        ]);\n      }\n    }\n  }\n\n  /**\n   * Gets content from a register. If no register is specified, uses `vimState.recordedState.registerName`.\n   */\n  public static async get(\n    register: string,\n    multicursorIndex = 0\n  ): Promise<IRegisterContent | undefined> {\n    if (!Register.isValidRegister(register)) {\n      throw new Error(`Invalid register ${register}`);\n    }\n\n    register = register.toLowerCase();\n\n    const contentByCursor = Register.registers.get(register);\n\n    if (Register.isClipboardRegister(register)) {\n      const clipboardContent = (await Clipboard.Paste()).replace(/\\r\\n/g, '\\n');\n      const currentRegisterContent = (contentByCursor?.[0]?.text as string)?.replace(/\\r\\n/g, '\\n');\n      if (currentRegisterContent !== clipboardContent) {\n        // System clipboard seems to have changed\n        const registerContent = {\n          text: clipboardContent,\n          registerMode: RegisterMode.CharacterWise,\n        };\n        Register.registers.set(register, [registerContent]);\n        return registerContent;\n      }\n    }\n\n    // Default to the first cursor.\n    if (contentByCursor?.[multicursorIndex] === undefined) {\n      // If multicursorIndex is too high, try the first cursor\n      multicursorIndex = 0;\n    }\n\n    return contentByCursor?.[multicursorIndex];\n  }\n\n  public static has(register: string): boolean {\n    return Register.registers.has(register);\n  }\n\n  public static getKeys(): string[] {\n    return [...Register.registers.keys()];\n  }\n\n  public static clearAllRegisters(): void {\n    Register.registers.clear();\n  }\n\n  public static async saveToDisk(supportNode: boolean): Promise<void> {\n    if (supportNode) {\n      const serializableRegisters = new Array<[string, IRegisterContent[]]>();\n      for (const [key, contentByCursor] of Register.registers) {\n        if (!contentByCursor.some((content) => content instanceof RecordedState)) {\n          serializableRegisters.push([key, contentByCursor]);\n        }\n      }\n      return import('path').then((path) => {\n        return writeFileAsync(\n          path.join(Globals.extensionStoragePath, '.registers'),\n          JSON.stringify({\n            version: REGISTER_FORMAT_VERSION,\n            registers: serializableRegisters,\n          }),\n          'utf8'\n        );\n      });\n    }\n  }\n\n  public static loadFromDisk(supportNode: boolean): void {\n    if (supportNode) {\n      Register.registers = new Map();\n      import('path').then((path) => {\n        readFileAsync(path.join(Globals.extensionStoragePath, '.registers'), 'utf8').then(\n          (savedRegisters) => {\n            const parsed = JSON.parse(savedRegisters);\n            if (parsed.version === REGISTER_FORMAT_VERSION) {\n              Register.registers = new Map(parsed.registers);\n            }\n          }\n        );\n      });\n    } else {\n      Register.registers = new Map();\n    }\n  }\n}\n","export class CompositionState {\n  isInComposition: boolean = false;\n  insertedText: boolean = false;\n  composingText: string = '';\n\n  reset() {\n    this.isInComposition = false;\n    this.insertedText = false;\n    this.composingText = '';\n  }\n}\n","import { JumpTracker } from '../jumps/jumpTracker';\nimport { RecordedState } from './../state/recordedState';\nimport { SearchState } from './searchState';\nimport { SubstituteState } from './substituteState';\n\n/**\n * State which stores global state (across editors)\n */\nclass GlobalState {\n  /**\n   * Track jumps, and traverse jump history\n   */\n  public readonly jumpTracker: JumpTracker = new JumpTracker();\n\n  /**\n   * The keystroke sequence that made up our last complete action (that can be\n   * repeated with '.').\n   */\n  public previousFullAction: RecordedState | undefined = undefined;\n\n  /**\n   * Last substitute state for running :s by itself\n   */\n  public substituteState: SubstituteState | undefined = undefined;\n\n  /**\n   * The most recently active SearchState\n   * This is used for things like `n` and `hlsearch`\n   */\n  public searchState: SearchState | undefined = undefined;\n\n  /**\n   * Used internally for nohl.\n   */\n  public hl = true;\n}\n\nexport const globalState = new GlobalState();\n","import { configuration } from '../configuration/configuration';\nimport { Mode, isVisualMode } from '../mode/mode';\nimport { PositionDiff } from './../common/motion/position';\nimport { Transformer } from './../transformations/transformer';\nimport { SpecialKeys } from '../util/specialKeys';\nimport { IBaseAction, IBaseOperator, IBaseCommand } from '../actions/types';\n\n/**\n * Much of Vim's power comes from the composition of individual actions.\n *\n * RecordedState holds the state associated with a sequence of actions,\n * generally beginning and ending in Normal mode.\n *\n * For example, each of these action sequences would be combined into a single RecordedState:\n *   - 5\"xyw      (yank 5 words into the 'x' register)\n *   - Axyz<Esc>  (append 'xyz' to end of line)\n *   - Vjj~       (reverse case of next 3 lines)\n *\n * The last action (for dot-repeating), macros, and a few other things are RecordedStates.\n */\nexport class RecordedState {\n  constructor() {\n    this.registerName = configuration.useSystemClipboard ? '*' : '\"';\n  }\n\n  /**\n   * The keys the user has pressed that have not caused an action to be executed\n   * yet and have not been stored on action keys. Used for command remapping.\n   */\n  public commandList: string[] = [];\n\n  /**\n   * String representation of the exact keys that the user entered.\n   */\n  public get commandString(): string {\n    let result = '';\n\n    if (this.actionsRun.length > 0) {\n      result = this.actionsRunPressedKeys.join('');\n    }\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    if (\n      this.actionsRun.length === 0 &&\n      this.actionKeys.length === 0 &&\n      this.bufferedKeys.length === 0 &&\n      this.commandList.length > 0\n    ) {\n      // Used for the registers and macros that only record on commandList\n      result = this.commandList.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * String representation of the pending keys that the user entered.\n   */\n  public get pendingCommandString(): string {\n    let result = '';\n\n    if (this.actionKeys.length > 0) {\n      // if there are any actionKeys waiting for other key append them\n      result += this.actionKeys.join('');\n    }\n    if (this.bufferedKeys.length > 0) {\n      // if there are any bufferedKeys waiting for other key append them\n      result += this.bufferedKeys.join('');\n    }\n    const regexEscape = new RegExp(/[|\\\\{}()[\\]^$+*?.]/, 'g');\n    const regexLeader = new RegExp(configuration.leader.replace(regexEscape, '\\\\$&'), 'g');\n    const regexBufferedKeys = new RegExp(SpecialKeys.TimeoutFinished, 'g');\n    result = result.replace(regexLeader, '<leader>').replace(regexBufferedKeys, '');\n\n    return result;\n  }\n\n  /**\n   * Determines if the current command list is prefixed with a count\n   */\n  public get commandWithoutCountPrefix() {\n    return this.commandList.join('').replace(/^[0-9]+/g, '');\n  }\n\n  /**\n   * Reset the command list.\n   */\n  public resetCommandList() {\n    this.commandList = [];\n  }\n\n  /**\n   * Keeps track of keys pressed for the next action. Comes in handy when parsing\n   * multiple length movements, e.g. gg.\n   */\n  public actionKeys: string[] = [];\n\n  /**\n   * Waiting for another key for a potential action.\n   *\n   * Used to prevent the remapping of keys after a potential action key\n   * like @zZtTfF[]rm'`\"gq<C-r><C-w>. This is done to be able to use all\n   * the named registers and marks, even when the command with the same\n   * name has been mapped.\n   *\n   * Vim Documentation: (:help map-error)\n   * \"Note that the second character (argument) of the commands @zZtTfF[]rm'`\"v\n   * and CTRL-X is not mapped. This was done to be able to use all the named\n   * registers and marks, even when the command with the same name has been\n   * mapped.\"\n   *\n   * The documentation only specifies some keys, but from testing pretty much\n   * every key has this condition (keys like 'g', 'q', '<C-r>' and '<C-w>' all\n   * behave the same) so here we use 'waitingForAnotherActionKey' to prevent\n   * remapping on next keys. In the case of the 'v' key specified in the vim\n   * documentation, I don't really understand what they mean with that because\n   * it doesn't make much sense. The 'v' key puts you in Visual mode, it doesn't\n   * accept any character argument.\n   */\n  public waitingForAnotherActionKey: boolean = false;\n\n  /**\n   * Every action that has been run.\n   */\n  public actionsRun: IBaseAction[] = [];\n\n  /**\n   * Keeps track of keys pressed by the actionsRun. Used for the showCmd. If an action\n   * changes previous actions pressed keys it should change this list, like the <Del>\n   * key after a number key.\n   */\n  public actionsRunPressedKeys: string[] = [];\n\n  /**\n   * Every key that was buffered to wait for a new key or the timeout to finish\n   * in order to get another potential remap or to solve an ambiguous remap.\n   */\n  public bufferedKeys: string[] = [];\n  public bufferedKeysTimeoutObj: NodeJS.Timeout | undefined = undefined;\n\n  /**\n   * This is used when the remappers are resending the keys after a potential\n   * remap without an ambiguous remap is broken, either by a new key or by the\n   * timeout finishing.\n   *\n   * It will make it so the first key sent will not be considered as a potential\n   * remap by any of the remappers, even though it is, to prevent the remappers\n   * of doing the same thing again. This way the first key will be handled as an\n   * action but the next keys can still be remapped.\n   *\n   * Example: if you map `iiii -> i<C-A><Esc>` in normal mode and map `ii -> <Esc>`\n   * in insert mode, after pressing `iii` you want the first `i` to put you in\n   * insert mode and the next `ii` to escape to normal mode.\n   */\n  public allowPotentialRemapOnFirstKey = true;\n\n  public hasRunOperator = false;\n\n  /**\n   * This is kind of a hack and should be associated with something like this:\n   *\n   * https://github.com/VSCodeVim/Vim/issues/805\n   */\n  public operatorPositionDiff: PositionDiff | undefined;\n\n  public isInsertion = false;\n\n  /**\n   * The text transformations that we want to run. They will all be run after the action has been processed.\n   *\n   * Running an individual action will generally queue up to one of these, but if you're in\n   * multi-cursor mode, you'll queue one per cursor, or more.\n   *\n   * Note that the text transformations are run in parallel. This is useful in most cases,\n   * but will get you in trouble in others.\n   */\n  public transformer = new Transformer();\n\n  /**\n   * The operator (e.g. d, y, >) the user wants to run, if there is one.\n   */\n  public get operator(): IBaseOperator | undefined {\n    const operators = this.operators;\n    return operators.length > 0 ? operators[0] : undefined;\n  }\n\n  public get operators(): IBaseOperator[] {\n    return this.actionsRun.filter((a): a is IBaseOperator => a.actionType === 'operator').reverse();\n  }\n\n  /**\n   * The command (e.g. i, ., R, /) the user wants to run, if there is one.\n   */\n  public get command(): IBaseCommand {\n    // TODO: this is probably wrong\n    const list = this.actionsRun.filter((a): a is IBaseCommand => a.actionType === 'command').reverse();\n\n    // TODO - disregard <Esc>, then assert this is of length 1.\n\n    return list[0];\n  }\n\n  /**\n   * The number of times the user wants to repeat this action.\n   */\n  public count: number = 0;\n\n  /**\n   * The number of times the user wants to repeat the operator. If after the operator the user\n   * uses a motion with count that count will be multiplied by this count.\n   *\n   * Example: if user presses 2d3w it deletes 6 words.\n   */\n  public operatorCount: number = 0;\n\n  /**\n   * The register name for this action.\n   */\n  public registerName: string;\n\n  /**\n   * The key used to access the register with `registerName`\n   * Example: if 'q5' then key=5 and name=5\n   * Or:      if 'qA' then key=A and name=a\n   */\n  public registerKey: string = '';\n\n  public clone(): RecordedState {\n    const res = new RecordedState();\n\n    // TODO: Actual clone.\n\n    res.actionKeys = this.actionKeys.slice(0);\n    res.actionsRun = this.actionsRun.slice(0);\n    res.hasRunOperator = this.hasRunOperator;\n\n    return res;\n  }\n\n  public getOperatorState(mode: Mode): 'pending' | 'ready' | undefined {\n    // Do we have an operator that hasn't been run yet?\n    if (\n      this.operator === undefined ||\n      this.hasRunOperator ||\n      // TODO: Is this mode check necessary?\n      mode === Mode.SearchInProgressMode ||\n      mode === Mode.CommandlineInProgress\n    ) {\n      return undefined;\n    }\n\n    // We've got an operator - do we also have a motion or visual selection to operate on?\n    if (this.actionsRun.some((a) => a.actionType === 'motion') || isVisualMode(mode)) {\n      return 'ready';\n    }\n\n    // TODO: I don't think reversing is necessary - can't there only ever be two operators?\n    // This case is for a \"repeated\" operator (such as `dd` or `yy`)\n    if (\n      this.operators.length > 1 &&\n      this.operators.reverse()[0].constructor === this.operators.reverse()[1].constructor\n    ) {\n      return 'ready';\n    }\n\n    return 'pending';\n  }\n}\n","import { IKeyRemapping } from '../configuration/iconfiguration';\n\n/**\n * State related to key remapping. Held by ModeHandler.\n */\nexport class RemapState {\n  /**\n   * For timing out remapped keys like jj to esc.\n   */\n  public lastKeyPressedTimestamp = 0;\n\n  /**\n   * Used to indicate that a non-recursive remap is being handled.\n   * This is used to prevent non-recursive remappings from looping.\n   */\n  public isCurrentlyPerformingNonRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a recursive remap is being handled. This is used to prevent recursive remappings\n   * from looping farther then maxMapDepth and to stop recursive remappings when an action fails.\n   */\n  public isCurrentlyPerformingRecursiveRemapping = false;\n\n  /**\n   * Used to indicate that a remap is being handled and the keys sent to modeHandler were not typed\n   * by the user.\n   */\n  public get isCurrentlyPerformingRemapping() {\n    return (\n      this.isCurrentlyPerformingNonRecursiveRemapping ||\n      this.isCurrentlyPerformingRecursiveRemapping\n    );\n  }\n\n  /**\n   * When performing a recursive remapping that has no parent remappings and that finishes while\n   * still waiting for timeout or another key to come we store that remapping here. This is used\n   * to be able to handle those buffered keys and any other key that the user might press to brake\n   * the timeout seperatly. Because if an error happens in the middle of a remap, the remaining\n   * remap keys shouldn't be handled but the user pressed ones should, but if an error happens on\n   * a user typed key, the following typed keys will still be handled.\n   *\n   * Example: having the following remapings:\n   * * `nmap <leader>lf Lfill`\n   * * `nmap Lfillc 4I<space><esc>`\n   * * `nmap Lfillp 2I<space><esc>`\n   * When user presses `<leader>lf` it remaps that to `Lfill` but because that is an ambiguous remap\n   * it creates the timeout and returns from remapper setting the performing remapping flag to false.\n   * This allows the user to then press `c` or `p` and the corresponding remap would run. But if the\n   * user presses another key or the timeout finishes we need to handle the `Lfill` keys and they\n   * need to know they were sent by a remap and not by the user so that in case the find 'i' in\n   * `Lfill` fails the last two `l` shouldn't be executed and any keys typed by the user after the\n   * remap that brake the timeout need to be handled seperatly from `Lfill`.\n   * (Check the tests for this example to understand better).\n   *\n   * To prevent this, we stored the remapping that finished waiting for timeout so that, if the\n   * timeout finishes or the user presses some keys that brake the potential remap, we will know\n   * what was the remapping waiting for timeout. So in case the timeout finishes we set the\n   * currently performing recursive remapping flag to true manually, send the <TimeoutFinished> key\n   * and in the end we set the flag back to false again and clear the stored remapping. In case\n   * the user presses one or more keys that brake the potential timeout we set the flag to true\n   * manually, handle the keys from the remapping and then set the flag back to false, clear the\n   * stored remapping and handle the keys pressed by the user seperatly.\n   * We do this because any VimError or ForceStopRemappingError are thrown only when performing a\n   * remapping.\n   */\n  public wasPerformingRemapThatFinishedWaitingForTimeout: IKeyRemapping | false = false;\n\n  /**\n   * Holds the current map depth count (number of nested remaps without using a character). In recursive remaps\n   * every time we map a key when already performing a remapping this number increases by one. When a remapping\n   * handling uses a character this number resets to 0.\n   *\n   * When it reaches the maxMapDepth it throws the VimError E223.\n   * (check vim documentation :help maxmapdepth)\n   */\n  public mapDepth: number = 0;\n\n  /**\n   * Used to reset the mapDepth on nested recursive remaps. Is set to false every time we get a remapping and is set to\n   * true when a character is used. We consider a character as being used when we get an action.\n   * (check vim documentation :help maxmapdepth).\n   *\n   * Example 1: if we remap `x -> y` and `y -> x` if we press any of those keys we will continuously find a new\n   * remap and increase the mapDepth without ever using an action until we hit maxMapDepth and we get E223 stopping\n   * it all.\n   *\n   * Example 2: if we map `a -> x`, `x -> y`, `y -> b` and `b -> w` and we set maxMapDepth to 4 we get 'E223 Recursive\n   * Mapping', because we get to the fourth remap without ever executing an action, but if we change the 'y' map to\n   * `y -> wb`, now the max mapDepth we hit is 3 and then we execute the action 'w' that resets the mapDepth and then\n   * call another remap of `b -> w` that executes another 'w', meaning that after pressing 'a' the result would be 'ww'.\n   * Another option would be to increase the maxMapDepth to 5 or more and then we could use the initial remaps that would\n   * turn the pressing of 'a' into a single 'w'.\n   *\n   * Example 3 (possible use case): if we remap `<leader>cb -> 0i//<Space><Esc>j<leader>cb` that recursively calls itself,\n   * every time the`0` key is sent we set remapUsedACharacter to true and reset mapDepth to 0 on all nested remaps so even\n   * if it calls itself more than 1000 times (on a file with more than 1000 lines) the mapDepth will always be reset to 0,\n   * which allows the remap to keep calling itself to comment all the lines until either we get to the last line and the 'j'\n   * action fails stopping the entire remap chain or the user presses `<C-c>` or `<Esc>` to forcelly stop the recursive remaps.\n   *\n   * P.S. This behavior is weird, because we should reduce the mapDepth by one when the remapping finished handling\n   * or if it failed. But this is the way Vim does it. This allows the user to create infinite looping remaps\n   * that call themselves and only stop after an error or the user pressing a key (usually <C-c> but we also\n   * allow <Esc> because the user might not allow the use of ctrl keys).\n   *\n   * P.S.2 This is a complicated explanation for a seemingly simple feature, but I wrote this because when I first read the\n   * Vim documentation it wasn't very clear to me how this worked, I first thought that mapDepth was like a map count but that\n   * is not the case because we can have thousands of nested remaps without ever hitting maxMapDepth like in Example 3, and I\n   * only started to understand it better when I tried Example 2 in Vim and some variations of it.\n   */\n  public remapUsedACharacter: boolean = false;\n\n  /**\n   * This will force Stop a recursive remapping. Used by <C-c> or <Esc> key when there is a recursive remapping\n   */\n  public forceStopRecursiveRemapping: boolean = false;\n}\n","import { Position } from 'vscode';\n\ntype ReplaceModeChange = {\n  before: string;\n  after: string;\n};\n\n/**\n * State involved with entering Replace mode (R).\n */\nexport class ReplaceState {\n  /**\n   * Number of times we're going to repeat this replace action.\n   * Comes from the count applied to the `R` command.\n   */\n  public readonly timesToRepeat: number;\n\n  private _changes: ReplaceModeChange[][];\n  public getChanges(cursorIdx: number): ReplaceModeChange[] {\n    if (this._changes[cursorIdx] === undefined) {\n      this._changes[cursorIdx] = [];\n    }\n    return this._changes[cursorIdx];\n  }\n  public resetChanges(cursorIdx: number) {\n    this._changes[cursorIdx] = [];\n  }\n\n  constructor(startPositions: Position[], timesToRepeat: number = 1) {\n    this.timesToRepeat = timesToRepeat;\n    this._changes = startPositions.map((pos) => []);\n  }\n}\n","import { Position, Range } from 'vscode';\n\nimport { configuration } from '../configuration/configuration';\nimport { Pattern, SearchDirection, SearchOffset, searchStringParser } from '../vimscript/pattern';\nimport { VimState } from './vimState';\n\nexport type IndexedRange = {\n  range: Range;\n  index: number;\n};\n\nexport type IndexedPosition = {\n  pos: Position;\n  index: number;\n};\n\n/**\n * @returns the least residue of n mod m in the range [0, m) if m > 0, or (m, 0] if m < 0\n */\nfunction mod(n: number, m: number): number {\n  return (m + (n % m)) % m;\n}\n\n/**\n * State involved with beginning a search (/).\n */\nexport class SearchState {\n  constructor(\n    direction: SearchDirection,\n    startPosition: Position,\n    searchString = '',\n    { ignoreSmartcase = false } = {}\n  ) {\n    this._searchString = searchString;\n\n    const result = searchStringParser({ direction, ignoreSmartcase }).parse(this._searchString);\n    const { pattern, offset } = result.status\n      ? result.value\n      : { pattern: undefined, offset: undefined };\n    this.pattern = pattern;\n    this.offset = offset;\n\n    this.cursorStartPosition = startPosition;\n    this.ignoreSmartcase = ignoreSmartcase;\n  }\n\n  private _searchString: string;\n  public pattern?: Pattern;\n  private offset?: SearchOffset;\n\n  public readonly cursorStartPosition: Position;\n\n  public get searchString(): string {\n    return this._searchString;\n  }\n  public set searchString(str: string) {\n    this._searchString = str;\n    const result = searchStringParser({\n      direction: this.direction,\n      ignoreSmartcase: this.ignoreSmartcase,\n    }).parse(str);\n    const { pattern, offset } = result.status\n      ? result.value\n      : { pattern: undefined, offset: undefined };\n    if (pattern?.patternString !== this.pattern?.patternString) {\n      this.pattern = pattern;\n      this.matchRanges.clear();\n    }\n    this.offset = offset;\n  }\n\n  public get direction(): SearchDirection {\n    // TODO: Defaulting to forward is wrong - I think storing the direction in the pattern is a mistake\n    return this.pattern?.direction ?? SearchDirection.Forward;\n  }\n\n  /**\n   * Every range in the document that matches the search string.\n   *\n   * This might not be 100% complete - @see Pattern::MAX_SEARCH_RANGES\n   */\n  public getMatchRanges(vimState: VimState): Range[] {\n    return this.recalculateSearchRanges(vimState);\n  }\n  private matchRanges: Map<string, { version: number; ranges: Range[] }> = new Map();\n\n  /**\n   * If true, an all-lowercase needle will not be treated as case-insensitive, even if smartcase is enabled.\n   * This is used for [g]* and [g]#.\n   */\n  private readonly ignoreSmartcase: boolean;\n\n  private recalculateSearchRanges(vimState: VimState): Range[] {\n    if (this.searchString === '' || this.pattern === undefined) {\n      return [];\n    }\n\n    const document = vimState.document;\n\n    const cached = this.matchRanges.get(document.fileName);\n    if (cached?.version === document.version) {\n      return cached.ranges;\n    }\n\n    // TODO: It's weird to use the active selection for this...\n    const matchRanges = this.pattern\n      .allMatches(vimState, { fromPosition: vimState.editor.selection.active })\n      .map((match) => match.range);\n\n    this.matchRanges.set(document.fileName, {\n      version: document.version,\n      ranges: matchRanges,\n    });\n\n    return matchRanges;\n  }\n\n  /**\n   * @returns The start of the next match range, after applying the search offset\n   *\n   * @see getNextSearchMatchRange for parameters\n   */\n  public getNextSearchMatchPosition(\n    vimState: VimState,\n    startPosition: Position,\n    direction = SearchDirection.Forward,\n    relativeIndex = 0\n  ): IndexedPosition | undefined {\n    const nextMatch = this.getNextSearchMatchRange(\n      vimState,\n      startPosition,\n      direction,\n      relativeIndex\n    );\n    if (nextMatch === undefined) {\n      return undefined;\n    }\n    const { range, index } = nextMatch;\n\n    return { pos: this.offset ? this.offset.apply(range) : range.start, index };\n  }\n\n  /**\n   * @returns The next match range from the given position and its rank in the document's matches, or undefined if none exists.\n   * An optional index can be provided to target other matches relative to the next.\n   *\n   * @param direction If `SearchDirection.Backward`, this will search in the opposite of the pattern's direction\n   *\n   * @param relativeIndex Which match to return, relative to the next match. 0 (default) corresponds to the next match,\n   * 1 corresponds to the match after next (in the given direction), -1 corresponds to the match before next, etc.\n   *\n   * NOTE: This method does not take the search offset into account\n   */\n  public getNextSearchMatchRange(\n    vimState: VimState,\n    fromPosition: Position,\n    direction = SearchDirection.Forward,\n    relativeIndex = 0\n  ): IndexedRange | undefined {\n    const matchRanges = this.recalculateSearchRanges(vimState);\n\n    if (matchRanges.length === 0) {\n      return undefined;\n    }\n\n    const effectiveDirection = (direction * this.direction) as SearchDirection;\n    let index: number | undefined;\n\n    if (effectiveDirection === SearchDirection.Forward) {\n      for (let i = 0; i < matchRanges.length; i++) {\n        if (\n          (this.offset?.apply(matchRanges[i]) ?? matchRanges[i].start).compareTo(fromPosition) > 0\n        ) {\n          index = i;\n          break;\n        }\n      }\n    } else {\n      for (let i = matchRanges.length - 1; i >= 0; i--) {\n        if (\n          (this.offset?.apply(matchRanges[i]) ?? matchRanges[i].start).compareTo(fromPosition) < 0\n        ) {\n          index = i;\n          break;\n        }\n      }\n    }\n\n    if (index === undefined) {\n      // We've hit the top/bottom of the file. Wrap around if configured to do so, or return undefined.\n      if (configuration.wrapscan) {\n        index = effectiveDirection === SearchDirection.Forward ? 0 : matchRanges.length - 1;\n      } else {\n        return undefined;\n      }\n    }\n\n    // index of the first match now stored in variable index.\n    // Offsetting it by relativeIndex in the appropriate direction gets the index of the desired match.\n    index += effectiveDirection * relativeIndex;\n\n    if (0 <= index && index < matchRanges.length) {\n      return { index, range: matchRanges[index] };\n    }\n\n    // We've hit the top/bottom of the file. Wrap around (possibly many times) if configured to do so, or return undefined\n    if (configuration.wrapscan) {\n      index = mod(index, matchRanges.length);\n      return { index, range: matchRanges[index] };\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @returns the match range which contains the given Position, or undefined if none exists\n   */\n  public findContainingMatchRange(vimState: VimState, pos: Position): IndexedRange | undefined {\n    const matchRanges = this.recalculateSearchRanges(vimState);\n\n    if (matchRanges.length === 0) {\n      return undefined;\n    }\n\n    for (const [index, range] of matchRanges.entries()) {\n      if (range.start.isBeforeOrEqual(pos) && range.end.isAfter(pos)) {\n        return {\n          range,\n          index,\n        };\n      }\n    }\n\n    return undefined;\n  }\n}\n","import { ReplaceString } from '../cmd_line/commands/substitute';\nimport { Pattern } from '../vimscript/pattern';\n\n/**\n * State involved with Substitution commands (:s).\n */\nexport class SubstituteState {\n  /**\n   * The last pattern searched for in the substitution\n   */\n  public searchPattern: Pattern | undefined;\n\n  /**\n   * The last replacement string in the substitution\n   */\n  public replaceString: ReplaceString;\n\n  constructor(searchPattern: Pattern | undefined, replaceString: ReplaceString) {\n    this.searchPattern = searchPattern;\n    this.replaceString = replaceString;\n  }\n}\n","import * as vscode from 'vscode';\n\nimport { IMovement } from '../actions/baseMotion';\nimport { configuration } from '../configuration/configuration';\nimport { IEasyMotion } from '../actions/plugins/easymotion/types';\nimport { HistoryTracker } from './../history/historyTracker';\nimport { Logger } from '../util/logger';\nimport { Mode } from '../mode/mode';\nimport { Cursor } from '../common/motion/cursor';\nimport { RecordedState } from './recordedState';\nimport { RegisterMode } from './../register/register';\nimport { ReplaceState } from './../state/replaceState';\nimport { SurroundState } from '../actions/plugins/surround';\nimport { SUPPORT_NVIM, SUPPORT_IME_SWITCHER } from 'platform/constants';\nimport { Position } from 'vscode';\nimport { ExCommandLine, SearchCommandLine } from '../cmd_line/commandLine';\nimport { ModeData } from '../mode/modeData';\nimport { SearchDirection } from '../vimscript/pattern';\nimport { globalState } from './globalState';\n\ninterface IInputMethodSwitcher {\n  switchInputMethod(prevMode: Mode, newMode: Mode): Promise<void>;\n}\n\ninterface IBaseMovement {\n  execActionWithCount(\n    position: Position,\n    vimState: VimState,\n    count: number\n  ): Promise<Position | IMovement>;\n}\n\ninterface INVim {\n  run(vimState: VimState, command: string): Promise<{ statusBarText: string; error: boolean }>;\n\n  dispose(): void;\n}\n\n/**\n * The VimState class holds permanent state that carries over from action\n * to action.\n *\n * Actions defined in actions.ts are only allowed to mutate a VimState in order to\n * indicate what they want to do.\n *\n * Each ModeHandler holds a VimState, so there is one for each open editor.\n */\nexport class VimState implements vscode.Disposable {\n  private static readonly logger = Logger.get('VimState');\n\n  /**\n   * The column the cursor wants to be at, or Number.POSITIVE_INFINITY if it should always\n   * be the rightmost column.\n   *\n   * Example: If you go to the end of a 20 character column, this value\n   * will be 20, even if you press j and the next column is only 5 characters.\n   * This is because if the third column is 25 characters, the cursor will go\n   * back to the 20th column.\n   */\n  public desiredColumn = 0;\n\n  public historyTracker: HistoryTracker;\n\n  public easyMotion: IEasyMotion;\n\n  public readonly documentUri: vscode.Uri;\n\n  public editor: vscode.TextEditor;\n\n  public get document(): vscode.TextDocument {\n    return this.editor.document;\n  }\n\n  /**\n   * Are multiple cursors currently present?\n   */\n  public get isMultiCursor(): boolean {\n    return this._cursors.length > 1;\n  }\n\n  /**\n   * Is the multicursor something like visual block \"multicursor\", where\n   * natively in vim there would only be one cursor whose changes were applied\n   * to all lines after edit.\n   */\n  public isFakeMultiCursor = false;\n\n  /**\n   * Tracks movements that can be repeated with ; (e.g. t, T, f, and F).\n   */\n  public lastSemicolonRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  /**\n   * Tracks movements that can be repeated with , (e.g. t, T, f, and F).\n   */\n  public lastCommaRepeatableMovement: IBaseMovement | undefined = undefined;\n\n  // TODO: move into ModeHandler\n  public lastMovementFailed: boolean = false;\n\n  /**\n   * Keep track of whether the last command that ran is able to be repeated\n   * with the dot command.\n   */\n  public lastCommandDotRepeatable: boolean = true;\n\n  public isRunningDotCommand = false;\n  public isReplayingMacro: boolean = false;\n\n  /**\n   * The last visual selection before running the dot command\n   */\n  public dotCommandPreviousVisualSelection: vscode.Selection | undefined = undefined;\n\n  public surround: SurroundState | undefined = undefined;\n\n  /**\n   * Used for `<C-o>` in insert mode, which allows you run one normal mode\n   * command, then go back to insert mode.\n   */\n  public returnToInsertAfterCommand = false;\n  public actionCount = 0;\n\n  /**\n   * Every time we invoke a VSCode command which might trigger a view update.\n   * We should postpone its view updating phase to avoid conflicting with our internal view updating mechanism.\n   * This array is used to cache every VSCode view updating event and they will be triggered once we run the inhouse `viewUpdate`.\n   */\n  public postponedCodeViewChanges: ViewChange[] = [];\n\n  /**\n   * The cursor position (start, stop) when this action finishes.\n   */\n  public get cursorStartPosition(): Position {\n    return this.cursors[0].start;\n  }\n  public set cursorStartPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor start position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStart(value);\n  }\n\n  public get cursorStopPosition(): Position {\n    return this.cursors[0].stop;\n  }\n  public set cursorStopPosition(value: Position) {\n    if (!value.isValid(this.editor)) {\n      VimState.logger.warn(`invalid cursor stop position. ${value.toString()}.`);\n    }\n    this.cursors[0] = this.cursors[0].withNewStop(value);\n  }\n\n  /**\n   * The position of every cursor. Will never be empty.\n   */\n  private _cursors: Cursor[] = [new Cursor(new Position(0, 0), new Position(0, 0))];\n\n  public get cursors(): Cursor[] {\n    return this._cursors;\n  }\n  public set cursors(value: Cursor[]) {\n    if (value.length === 0) {\n      VimState.logger.warn('Tried to set VimState.cursors to an empty array');\n      return;\n    }\n\n    const map = new Map<string, Cursor>();\n    for (const cursor of value) {\n      if (!cursor.isValid(this.editor)) {\n        VimState.logger.warn(`invalid cursor position. ${cursor.toString()}.`);\n      }\n\n      // use a map to ensure no two cursors are at the same location.\n      map.set(cursor.toString(), cursor);\n    }\n\n    this._cursors = [...map.values()];\n  }\n\n  /**\n   * Initial state of cursors prior to any action being performed\n   */\n  private _cursorsInitialState!: Cursor[];\n  public get cursorsInitialState(): Cursor[] {\n    return this._cursorsInitialState;\n  }\n  public set cursorsInitialState(cursors: Cursor[]) {\n    this._cursorsInitialState = [...cursors];\n  }\n\n  /**\n   * Stores last visual mode as well as what was selected for `gv`\n   */\n  public lastVisualSelection:\n    | {\n        mode: Mode.Visual | Mode.VisualLine | Mode.VisualBlock;\n        start: Position;\n        end: Position;\n      }\n    | undefined = undefined;\n\n  /**\n   * The current mode and its associated state.\n   */\n  public modeData: ModeData = { mode: Mode.Normal };\n\n  public get currentMode(): Mode {\n    return this.modeData.mode;\n  }\n\n  private inputMethodSwitcher?: IInputMethodSwitcher;\n  /**\n   * The mode Vim is currently including pseudo-modes like OperatorPendingMode\n   * This is to be used only by the Remappers when getting the remappings so don't\n   * use it anywhere else.\n   */\n  public get currentModeIncludingPseudoModes(): Mode {\n    return this.recordedState.getOperatorState(this.currentMode) === 'pending'\n      ? Mode.OperatorPendingMode\n      : this.currentMode;\n  }\n\n  public async setModeData(modeData: ModeData): Promise<void> {\n    if (modeData === undefined) {\n      // TODO: remove this once we're sure this is no longer an issue (#6500, #6464)\n      throw new Error('Tried setting modeData to undefined');\n    }\n\n    await this.inputMethodSwitcher?.switchInputMethod(this.currentMode, modeData.mode);\n    if (this.returnToInsertAfterCommand && modeData.mode === Mode.Insert) {\n      this.returnToInsertAfterCommand = false;\n    }\n\n    if (modeData.mode === Mode.SearchInProgressMode) {\n      globalState.searchState = modeData.commandLine.getSearchState();\n    }\n\n    if (configuration.smartRelativeLine) {\n      this.editor.options.lineNumbers =\n        modeData.mode === Mode.Insert\n          ? vscode.TextEditorLineNumbersStyle.On\n          : vscode.TextEditorLineNumbersStyle.Relative;\n    }\n\n    this.modeData = modeData;\n  }\n\n  public async setCurrentMode(mode: Mode): Promise<void> {\n    if (mode === undefined) {\n      // TODO: remove this once we're sure this is no longer an issue (#6500, #6464)\n      throw new Error('Tried setting currentMode to undefined');\n    }\n\n    await this.setModeData(\n      mode === Mode.Replace\n        ? {\n            mode,\n            replaceState: new ReplaceState(\n              this.cursors.map((cursor) => cursor.stop),\n              this.recordedState.count\n            ),\n          }\n        : mode === Mode.CommandlineInProgress\n        ? {\n            mode,\n            commandLine: new ExCommandLine('', this.modeData.mode),\n          }\n        : mode === Mode.SearchInProgressMode\n        ? {\n            mode,\n            commandLine: new SearchCommandLine(this, '', SearchDirection.Forward),\n            firstVisibleLineBeforeSearch: this.editor.visibleRanges[0].start.line,\n          }\n        : mode === Mode.Insert\n        ? {\n            mode,\n            highSurrogate: undefined,\n          }\n        : { mode }\n    );\n  }\n\n  /**\n   * The currently active `RegisterMode`.\n   *\n   * When setting, `undefined` means \"default for current `Mode`\".\n   */\n  public set currentRegisterMode(registerMode: RegisterMode | undefined) {\n    this._currentRegisterMode = registerMode;\n  }\n  public get currentRegisterMode(): RegisterMode {\n    if (this._currentRegisterMode) {\n      return this._currentRegisterMode;\n    }\n    switch (this.currentMode) {\n      case Mode.VisualLine:\n        return RegisterMode.LineWise;\n      case Mode.VisualBlock:\n        return RegisterMode.BlockWise;\n      default:\n        return RegisterMode.CharacterWise;\n    }\n  }\n  private _currentRegisterMode: RegisterMode | undefined;\n\n  public recordedState = new RecordedState();\n\n  /** The macro currently being recorded, if one exists. */\n  public macro: RecordedState | undefined;\n\n  public lastInvokedMacro: RecordedState | undefined;\n\n  public nvim?: INVim;\n\n  public constructor(editor: vscode.TextEditor, easyMotion: IEasyMotion) {\n    this.editor = editor;\n    this.documentUri = editor?.document.uri ?? vscode.Uri.file(''); // TODO: this is needed for some badly written tests\n    this.historyTracker = new HistoryTracker(this);\n    this.easyMotion = easyMotion;\n  }\n\n  async load() {\n    if (SUPPORT_NVIM) {\n      const m = await import('../neovim/neovim');\n      this.nvim = new m.NeovimWrapper();\n    }\n\n    if (SUPPORT_IME_SWITCHER) {\n      const ime = await import('../actions/plugins/imswitcher');\n      this.inputMethodSwitcher = new ime.InputMethodSwitcher();\n    }\n  }\n\n  dispose() {\n    this.nvim?.dispose();\n  }\n}\n\nexport interface ViewChange {\n  command: string;\n  args: any;\n}\n","import * as vscode from 'vscode';\nimport { Mode } from './mode/mode';\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { VimError } from './error';\n\nclass StatusBarImpl implements vscode.Disposable {\n  // Displays the current state (mode, recording macro, etc.) and messages to the user\n  private readonly statusBarItem: vscode.StatusBarItem;\n\n  // Displays the keys you've typed so far when they haven't yet resolved to a command\n  private readonly recordedStateStatusBarItem: vscode.StatusBarItem;\n\n  private previousMode: Mode | undefined = undefined;\n  private showingDefaultMessage = true;\n\n  public lastMessageTime: Date | undefined;\n\n  constructor() {\n    this.statusBarItem = vscode.window.createStatusBarItem(\n      'primary',\n      vscode.StatusBarAlignment.Left,\n      Number.MIN_SAFE_INTEGER // Furthest right on the left\n    );\n    this.statusBarItem.name = 'Vim Command Line';\n    this.statusBarItem.show();\n\n    this.recordedStateStatusBarItem = vscode.window.createStatusBarItem(\n      'showcmd',\n      vscode.StatusBarAlignment.Right,\n      Number.MAX_SAFE_INTEGER // Furthest left on the right\n    );\n    this.recordedStateStatusBarItem.name = 'Vim Pending Command Keys';\n    this.recordedStateStatusBarItem.show();\n  }\n\n  dispose() {\n    this.statusBarItem.dispose();\n    this.recordedStateStatusBarItem.dispose();\n  }\n\n  public updateShowCmd(vimState: VimState) {\n    this.recordedStateStatusBarItem.text = configuration.showcmd\n      ? statusBarCommandText(vimState)\n      : '';\n  }\n\n  /**\n   * Updates the status bar text\n   * @param isError If true, text rendered in red\n   */\n  public setText(vimState: VimState, text: string, isError = false) {\n    const hasModeChanged = vimState.currentMode !== this.previousMode;\n\n    // Text\n    this.updateText(text);\n\n    // StatusBarItem color\n    if (!configuration.statusBarColorControl) {\n      this.statusBarItem.color = isError\n        ? new vscode.ThemeColor('statusBarItem.errorForeground')\n        : undefined;\n      this.statusBarItem.backgroundColor = isError\n        ? new vscode.ThemeColor('statusBarItem.errorBackground')\n        : undefined;\n    }\n\n    // StatusBar color\n    const shouldUpdateColor = configuration.statusBarColorControl && hasModeChanged;\n    if (shouldUpdateColor) {\n      this.updateColor(vimState.currentMode);\n    }\n\n    this.previousMode = vimState.currentMode;\n    this.showingDefaultMessage = false;\n    this.lastMessageTime = new Date();\n  }\n\n  public displayError(vimState: VimState, error: VimError) {\n    StatusBar.setText(vimState, error.toString(), true);\n  }\n\n  public getText() {\n    return this.statusBarItem.text.replace(/\\^M/g, '\\n');\n  }\n\n  /**\n   * Clears any messages from the status bar, leaving the default info, such as\n   * the current mode and macro being recorded.\n   * @param force If true, will clear even high priority messages like errors.\n   */\n  public clear(vimState: VimState, force = true) {\n    if (!this.showingDefaultMessage && !force) {\n      return;\n    }\n\n    const text: string[] = [];\n\n    if (\n      configuration.showmodename ||\n      vimState.currentMode === Mode.CommandlineInProgress ||\n      vimState.currentMode === Mode.SearchInProgressMode\n    ) {\n      text.push(statusBarText(vimState));\n      if (vimState.isMultiCursor) {\n        text.push(' MULTI CURSOR ');\n      }\n    }\n\n    if (vimState.macro) {\n      const macroText = 'Recording @' + vimState.macro.registerName;\n      text.push(macroText);\n    }\n\n    StatusBar.setText(vimState, text.join(' '));\n\n    this.showingDefaultMessage = true;\n  }\n\n  private updateText(text: string) {\n    const escaped = text.replace(/\\n/g, '^M');\n    this.statusBarItem.text = escaped || '';\n  }\n\n  private updateColor(mode: Mode) {\n    let foreground: string | undefined;\n    let background: string | undefined;\n\n    const colorToSet = configuration.statusBarColors[Mode[mode].toLowerCase()];\n\n    if (colorToSet !== undefined) {\n      if (typeof colorToSet === 'string') {\n        background = colorToSet;\n      } else {\n        [background, foreground] = colorToSet;\n      }\n    }\n\n    const workbenchConfiguration = configuration.getConfiguration('workbench');\n    const currentColorCustomizations: {\n      [index: string]: string;\n    } = workbenchConfiguration.get('colorCustomizations') ?? {};\n\n    const colorCustomizations = { ...currentColorCustomizations };\n\n    // If colors are undefined, return to VSCode defaults\n    if (background !== undefined) {\n      colorCustomizations['statusBar.background'] = background;\n      colorCustomizations['statusBar.noFolderBackground'] = background;\n      colorCustomizations['statusBar.debuggingBackground'] = background;\n    }\n\n    if (foreground !== undefined) {\n      colorCustomizations['statusBar.foreground'] = foreground;\n      colorCustomizations['statusBar.debuggingForeground'] = foreground;\n    }\n\n    if (currentColorCustomizations !== colorCustomizations) {\n      workbenchConfiguration.update('colorCustomizations', colorCustomizations, true);\n    }\n  }\n}\n\nexport const StatusBar = new StatusBarImpl();\n\nexport function statusBarText(vimState: VimState) {\n  const cursorChar =\n    vimState.recordedState.actionKeys[vimState.recordedState.actionKeys.length - 1] === '<C-r>'\n      ? '\"'\n      : '|';\n  switch (vimState.modeData.mode) {\n    case Mode.Normal:\n      return '-- NORMAL --';\n    case Mode.Insert:\n      return '-- INSERT --';\n    case Mode.Visual:\n      return '-- VISUAL --';\n    case Mode.VisualBlock:\n      return '-- VISUAL BLOCK --';\n    case Mode.VisualLine:\n      return '-- VISUAL LINE --';\n    case Mode.Replace:\n      return '-- REPLACE --';\n    case Mode.EasyMotionMode:\n      return '-- EASYMOTION --';\n    case Mode.EasyMotionInputMode:\n      return '-- EASYMOTION INPUT --';\n    case Mode.SurroundInputMode:\n      return '-- SURROUND INPUT --';\n    case Mode.Disabled:\n      return '-- VIM: DISABLED --';\n    case Mode.SearchInProgressMode:\n      return vimState.modeData.commandLine.display(cursorChar);\n    case Mode.CommandlineInProgress:\n      return vimState.modeData.commandLine.display(cursorChar);\n    default:\n      return '';\n  }\n}\n\nexport function statusBarCommandText(vimState: VimState): string {\n  switch (vimState.currentMode) {\n    case Mode.SurroundInputMode:\n      return vimState.surround && vimState.surround.replacement\n        ? vimState.surround.replacement\n        : '';\n    case Mode.EasyMotionMode:\n      return `Target key: ${vimState.easyMotion.accumulation}`;\n    case Mode.EasyMotionInputMode:\n      if (!vimState.easyMotion) {\n        return '';\n      }\n\n      const searchCharCount = vimState.easyMotion.searchAction.searchCharCount;\n      const message =\n        searchCharCount > 0\n          ? `Search for ${searchCharCount} character(s): `\n          : 'Search for characters: ';\n      return message + vimState.easyMotion.searchAction.searchString;\n    case Mode.Visual: {\n      // TODO: holy shit, this is SO much more complicated than it should be because\n      // our representation of a visual selection is so weird and inconsistent\n      let [start, end] = [vimState.cursorStartPosition, vimState.cursorStopPosition];\n      let wentOverEOL = false;\n      if (start.isAfter(end)) {\n        start = start.getRightThroughLineBreaks();\n        [start, end] = [end, start];\n      } else if (end.isAfter(start) && end.character === 0) {\n        end = end.getLeftThroughLineBreaks(true);\n        wentOverEOL = true;\n      }\n      const lines = end.line - start.line + 1;\n      if (lines > 1) {\n        return `${lines} ${vimState.recordedState.pendingCommandString}`;\n      } else {\n        const chars = Math.max(end.character - start.character, 1) + (wentOverEOL ? 1 : 0);\n        return `${chars} ${vimState.recordedState.pendingCommandString}`;\n      }\n    }\n    case Mode.VisualLine:\n      return `${\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1\n      } ${vimState.recordedState.pendingCommandString}`;\n    case Mode.VisualBlock: {\n      const lines =\n        Math.abs(vimState.cursorStopPosition.line - vimState.cursorStartPosition.line) + 1;\n      const chars =\n        Math.abs(vimState.cursorStopPosition.character - vimState.cursorStartPosition.character) +\n        1;\n      return `${lines}x${chars} ${vimState.recordedState.pendingCommandString}`;\n    }\n    case Mode.Insert:\n    case Mode.Replace:\n      return vimState.recordedState.pendingCommandString;\n    case Mode.Normal:\n    case Mode.Disabled:\n      return vimState.recordedState.commandString;\n    default:\n      return '';\n  }\n}\n","import * as vscode from 'vscode';\nimport Queue from 'queue';\nimport { Logger } from './util/logger';\nimport { extensionVersion } from './configuration/configuration';\n\nclass TaskQueue {\n  private readonly logger = Logger.get('TaskQueue');\n  private readonly taskQueue = new Queue({ autostart: true, concurrency: 1 });\n\n  constructor() {\n    this.taskQueue.addListener('error', (err, task) => {\n      if (err instanceof Error) {\n        const reportButton = 'Report bug';\n        const stack = err.stack;\n\n        // TODO: this is a bit janky - should probably create custom ContextualError class or find a library\n        // tslint:disable:no-string-literal\n        const context = err['context'];\n\n        vscode.window\n          .showErrorMessage(err.message, reportButton)\n          .then((picked: string | undefined) => {\n            if (picked === reportButton) {\n              let body = `**To Reproduce**\\nSteps to reproduce the behavior:\\n\\n1.  Go to '...'\\n2.  Click on '....'\\n3.  Scroll down to '....'\\n4.  See error\\n\\n**VSCodeVim version**: ${extensionVersion}`;\n              if (stack) {\n                body += `\\n\\n<details><summary>Stack trace</summary>\\n\\n\\`\\`\\`\\n${stack}\\n\\`\\`\\`\\n\\n</details>`;\n              }\n              if (context) {\n                body += `\\n\\n<details><summary>Additional context</summary>\\n\\n\\`\\`\\``;\n                for (const prop in context) {\n                  if (context.hasOwnProperty(prop)) {\n                    body += `\\n${prop}: ${JSON.stringify(context[prop], undefined, 2)}`;\n                  }\n                }\n                body += `\\n\\`\\`\\`\\n\\n</details>`;\n              }\n              vscode.commands.executeCommand(\n                'vscode.open',\n                vscode.Uri.parse(\n                  `https://github.com/VSCodeVim/Vim/issues/new?title=${err.message}&body=${body}`\n                )\n              );\n            }\n          });\n      } else {\n        this.logger.error(`Error running task due to an unknown error: ${err}.`);\n      }\n    });\n  }\n\n  /**\n   * Adds a task to the task queue.\n   */\n  public enqueueTask(task: () => Promise<void>): void {\n    this.taskQueue.push(task);\n  }\n}\n\nexport let taskQueue = new TaskQueue();\n","import * as vscode from 'vscode';\n\nimport { configuration } from './configuration/configuration';\nimport { VimState } from './state/vimState';\nimport { visualBlockGetTopLeftPosition, visualBlockGetBottomRightPosition } from './mode/mode';\nimport { Cursor } from './common/motion/cursor';\nimport { Position } from 'vscode';\nimport { Logger } from './util/logger';\nimport { clamp } from './util/util';\n\n/**\n * Collection of helper functions around vscode.window.activeTextEditor\n */\nexport class TextEditor {\n  private static readonly whitespaceRegExp = new RegExp('\\\\s+');\n  private static readonly logger = Logger.get('TextEditor');\n\n  /**\n   * @deprecated Use InsertTextTransformation (or InsertTextVSCodeTransformation) instead.\n   */\n  static async insert(\n    editor: vscode.TextEditor,\n    text: string,\n    at?: Position,\n    letVSCodeHandleKeystrokes?: boolean\n  ): Promise<void> {\n    // If we insert \"blah(\" with default:type, VSCode will insert the closing ).\n    // We *probably* don't want that to happen if we're inserting a lot of text.\n    letVSCodeHandleKeystrokes ??= text.length === 1;\n\n    if (!letVSCodeHandleKeystrokes) {\n      await editor.edit((editBuilder) => {\n        if (!at) {\n          at = editor.selection.active;\n        }\n\n        editBuilder.insert(at, text);\n      });\n    } else {\n      await vscode.commands.executeCommand('default:type', { text });\n    }\n  }\n\n  /**\n   * @deprecated. Use ReplaceTextTransformation instead.\n   */\n  static async replace(\n    editor: vscode.TextEditor,\n    range: vscode.Range,\n    text: string\n  ): Promise<boolean> {\n    return editor.edit((editBuilder) => {\n      editBuilder.replace(range, text);\n    });\n  }\n\n  /** @deprecated Use vimState.document.lineCount */\n  static getLineCount(textEditor?: vscode.TextEditor): number {\n    textEditor ??= vscode.window.activeTextEditor;\n    return textEditor?.document.lineCount ?? -1;\n  }\n\n  public static getLineLength(line: number): number {\n    if (line < 0 || line >= TextEditor.getLineCount()) {\n      this.logger.warn(`getLineLength() called with out-of-bounds line ${line}`);\n      return 0;\n    }\n\n    return vscode.window.activeTextEditor!.document.lineAt(line).text.length;\n  }\n\n  /** @deprecated Use `vimState.document.lineAt()` directly */\n  static getLine(lineNumber: number): vscode.TextLine {\n    return vscode.window.activeTextEditor!.document.lineAt(lineNumber);\n  }\n\n  static getCharAt(document: vscode.TextDocument, position: Position): string {\n    position = document.validatePosition(position);\n    return document.lineAt(position).text[position.character];\n  }\n\n  /**\n   * Retrieves the word at the given position.\n   *\n   * Respects `iskeyword`:\n   *    - Will go right (but not over line boundaries) until it finds a \"real\" word\n   *    - Will settle for a \"fake\" word only if it hits the line end\n   */\n  static getWord(document: vscode.TextDocument, position: Position): string | undefined {\n    const line = document.lineAt(position).text;\n\n    // Skip over whitespace\n    let firstNonBlank = position.character;\n    while (this.whitespaceRegExp.test(line[firstNonBlank])) {\n      firstNonBlank++;\n      if (firstNonBlank === line.length) {\n        // Hit end of line without finding a non-whitespace character\n        return undefined;\n      }\n    }\n\n    // Now skip over word separators and whitespace to find a \"real\" word\n    let start = firstNonBlank;\n    while (\n      configuration.iskeyword.includes(line[start]) ||\n      this.whitespaceRegExp.test(line[start])\n    ) {\n      start++;\n      if (start === line.length) {\n        // No keyword found - just settle for the word we're on\n        start = firstNonBlank;\n        break;\n      }\n    }\n\n    const foundRealWord = !configuration.iskeyword.includes(line[start]);\n    const includeInWord = (char: string) =>\n      !this.whitespaceRegExp.test(char) && configuration.iskeyword.includes(char) !== foundRealWord;\n\n    // Expand left and right to find the whole word\n    let end = start;\n    while (start > 0 && includeInWord(line[start - 1])) {\n      start--;\n    }\n    while (end < line.length && includeInWord(line[end + 1])) {\n      end++;\n    }\n\n    return line.substring(start, end + 1);\n  }\n\n  static getTabCharacter(editor: vscode.TextEditor): string {\n    if (editor.options.insertSpaces) {\n      // This will always be a number when we're getting it from the options\n      const tabSize = editor.options.tabSize as number;\n      return ' '.repeat(tabSize);\n    }\n    return '\\t';\n  }\n\n  /**\n   * @returns the number of visible columns that the given line begins with\n   */\n  static getIndentationLevel(line: string, tabSize: number): number {\n    let visibleColumn = 0;\n    for (const char of line) {\n      switch (char) {\n        case '\\t':\n          visibleColumn += tabSize;\n          break;\n        case ' ':\n          visibleColumn += 1;\n          break;\n        default:\n          return visibleColumn;\n      }\n    }\n\n    return visibleColumn;\n  }\n\n  /**\n   * @returns `line` with its indentation replaced with `screenCharacters` visible columns of whitespace\n   */\n  static setIndentationLevel(line: string, screenCharacters: number, expandtab: boolean): string {\n    const tabSize = configuration.tabstop;\n\n    if (screenCharacters < 0) {\n      screenCharacters = 0;\n    }\n\n    const indentString = expandtab\n      ? ' '.repeat(screenCharacters)\n      : '\\t'.repeat(screenCharacters / tabSize) + ' '.repeat(screenCharacters % tabSize);\n\n    return line.replace(/^\\s*/, indentString);\n  }\n\n  static getDocumentBegin(): Position {\n    return new Position(0, 0);\n  }\n\n  static getDocumentEnd(document: vscode.TextDocument): Position {\n    const line = Math.max(document.lineCount, 1) - 1;\n    return document.lineAt(line).range.end;\n  }\n\n  /**\n   * @returns the Position of the first character on the given line which is not whitespace.\n   * If it's all whitespace, will return the Position of the EOL character.\n   */\n  public static getFirstNonWhitespaceCharOnLine(\n    document: vscode.TextDocument,\n    line: number\n  ): Position {\n    line = clamp(line, 0, document.lineCount - 1);\n    return new Position(line, document.lineAt(line).firstNonWhitespaceCharacterIndex);\n  }\n\n  /**\n   * Iterate over every line in the block defined by the two positions (Range) passed in.\n   * If no range is given, the primary cursor will be used as the block.\n   *\n   * This is intended for visual block mode.\n   */\n  public static *iterateLinesInBlock(\n    vimState: VimState,\n    cursor?: Cursor,\n    options: { reverse?: boolean } = { reverse: false }\n  ): Iterable<{ line: string; start: Position; end: Position }> {\n    const { reverse } = options;\n\n    cursor ??= vimState.cursors[0];\n\n    const topLeft = visualBlockGetTopLeftPosition(cursor.start, cursor.stop);\n    const bottomRight = visualBlockGetBottomRightPosition(cursor.start, cursor.stop);\n\n    const [itrStart, itrEnd] = reverse\n      ? [bottomRight.line, topLeft.line]\n      : [topLeft.line, bottomRight.line];\n\n    const runToLineEnd = vimState.desiredColumn === Number.POSITIVE_INFINITY;\n\n    for (\n      let lineIndex = itrStart;\n      reverse ? lineIndex >= itrEnd : lineIndex <= itrEnd;\n      reverse ? lineIndex-- : lineIndex++\n    ) {\n      const line = vimState.document.lineAt(lineIndex).text;\n      const endCharacter = runToLineEnd\n        ? line.length + 1\n        : Math.min(line.length, bottomRight.character + 1);\n\n      yield {\n        line: line.substring(topLeft.character, endCharacter),\n        start: new Position(lineIndex, topLeft.character),\n        end: new Position(lineIndex, endCharacter),\n      };\n    }\n  }\n\n  /**\n   * Iterates through words on the same line, starting from the current position.\n   */\n  public static *iterateWords(\n    document: vscode.TextDocument,\n    start: Position\n  ): Iterable<{ start: Position; end: Position; word: string }> {\n    const text = document.lineAt(start).text;\n    if (/\\s/.test(text[start.character])) {\n      start = start.nextWordStart(document);\n    }\n    let wordEnd = start.nextWordEnd(document, { inclusive: true });\n    do {\n      const word = text.substring(start.character, wordEnd.character + 1);\n      yield {\n        start,\n        end: wordEnd,\n        word,\n      };\n\n      if (wordEnd.getRight().isLineEnd()) {\n        return;\n      }\n      start = start.nextWordStart(document);\n      wordEnd = start.nextWordEnd(document, { inclusive: true });\n    } while (true);\n  }\n}\n\n/**\n * Directions in the view for editor scroll command.\n */\nexport type EditorScrollDirection = 'up' | 'down';\n\n/**\n * Units for editor scroll 'by' argument\n */\nexport type EditorScrollByUnit = 'line' | 'wrappedLine' | 'page' | 'halfPage';\n\n/**\n * Positions in the view for cursor move command.\n */\nexport type CursorMovePosition =\n  | 'left'\n  | 'right'\n  | 'up'\n  | 'down'\n  | 'wrappedLineStart'\n  | 'wrappedLineFirstNonWhitespaceCharacter'\n  | 'wrappedLineColumnCenter'\n  | 'wrappedLineEnd'\n  | 'wrappedLineLastNonWhitespaceCharacter'\n  | 'viewPortTop'\n  | 'viewPortCenter'\n  | 'viewPortBottom'\n  | 'viewPortIfOutside';\n\n/**\n * Units for Cursor move 'by' argument\n */\nexport type CursorMoveByUnit = 'line' | 'wrappedLine' | 'character' | 'halfLine';\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\n\n/**\n * Get the end of the current paragraph.\n */\nexport function getCurrentParagraphEnd(pos: Position, trimWhite: boolean = false): Position {\n  const lastLine = TextEditor.getLineCount() - 1;\n\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go down until we are.\n  while (line < lastLine && isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  // Go until we're outside of the paragraph, or at the end of the document.\n  while (line < lastLine && !isLineBlank(line, trimWhite)) {\n    line++;\n  }\n\n  return pos.with({ line }).getLineEnd();\n}\n\n/**\n * Get the beginning of the current paragraph.\n */\nexport function getCurrentParagraphBeginning(pos: Position, trimWhite: boolean = false): Position {\n  let line = pos.line;\n\n  // If we're not in a paragraph yet, go up until we are.\n  while (line > 0 && isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  // Go until we're outside of the paragraph, or at the beginning of the document.\n  while (line > 0 && !isLineBlank(line, trimWhite)) {\n    line--;\n  }\n\n  return new Position(line, 0);\n}\n\nfunction isLineBlank(line: number, trimWhite: boolean = false): boolean {\n  const text = TextEditor.getLine(line).text;\n  return (trimWhite ? text.trim() : text) === '';\n}\n","import { Position } from 'vscode';\nimport { TextEditor } from '../textEditor';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nconst sentenceEndRegex = /[\\.!\\?]{1}([ \\n\\t]+|$)/g;\n\nexport function getSentenceBegin(position: Position, args: { forward: boolean }): Position {\n  if (args.forward) {\n    return getNextSentenceBegin(position);\n  } else {\n    return getPreviousSentenceBegin(position);\n  }\n}\n\nexport function getSentenceEnd(pos: Position): Position {\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const allPositions = getAllPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = allPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getPreviousSentenceBegin(pos: Position): Position {\n  const paragraphBegin = getCurrentParagraphBeginning(pos);\n  for (let currentLine = pos.line; currentLine >= paragraphBegin.line; currentLine--) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.reverse().find((index) => {\n      const newPositionBeforeThis = new Position(currentLine, index)\n        .getRightThroughLineBreaks()\n        .compareTo(pos);\n\n      return newPositionBeforeThis && (index < pos.character || currentLine < pos.line);\n    });\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  if (paragraphBegin.line + 1 === pos.line || paragraphBegin.line === pos.line) {\n    return paragraphBegin;\n  } else {\n    return new Position(paragraphBegin.line + 1, 0);\n  }\n}\n\nfunction getNextSentenceBegin(pos: Position): Position {\n  // A paragraph and section boundary is also a sentence boundary.\n  const paragraphEnd = getCurrentParagraphEnd(pos);\n  for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n    const endPositions = getAllEndPositions(TextEditor.getLine(currentLine).text, sentenceEndRegex);\n    const newCharacter = endPositions.find(\n      (index) => index > pos.character || currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter).getRightThroughLineBreaks();\n    }\n  }\n\n  return getFirstNonWhitespaceInParagraph(pos, paragraphEnd, false);\n}\n\nfunction getFirstNonWhitespaceInParagraph(\n  pos: Position,\n  paragraphEnd: Position,\n  inclusive: boolean\n): Position {\n  // If the cursor is at an empty line, it's the end of a paragraph and the begin of another paragraph\n  // Find the first non-whitespace character.\n  if (TextEditor.getLine(pos.line).text) {\n    return paragraphEnd;\n  } else {\n    for (let currentLine = pos.line; currentLine <= paragraphEnd.line; currentLine++) {\n      const nonWhitePositions = getAllPositions(TextEditor.getLine(currentLine).text, /\\S/g);\n      const newCharacter = nonWhitePositions.find(\n        (index) =>\n          (index > pos.character && !inclusive) ||\n          (index >= pos.character && inclusive) ||\n          currentLine !== pos.line\n      );\n\n      if (newCharacter !== undefined) {\n        return new Position(currentLine, newCharacter);\n      }\n    }\n  }\n\n  // Only happens at end of document\n  return pos;\n}\n","import { Cursor } from '../common/motion/cursor';\nimport { Mode } from '../mode/mode';\nimport { RegisterMode } from '../register/register';\nimport { VimState } from '../state/vimState';\nimport { TextEditor } from '../textEditor';\nimport { RegisterAction } from '../actions/base';\nimport { BaseMovement, IMovement, failedMovement } from '../actions/baseMotion';\nimport {\n  MoveAroundDoubleQuotes,\n  MoveAroundParentheses,\n  MoveAroundSingleQuotes,\n  MoveAroundSquareBracket,\n  MoveAroundBacktick,\n  MoveAroundTag,\n  ExpandingSelection,\n  MoveAroundCurlyBrace,\n} from '../actions/motion';\nimport { ChangeOperator } from '../actions/operator';\nimport { configuration } from '../configuration/configuration';\nimport { getCurrentParagraphBeginning, getCurrentParagraphEnd } from './paragraph';\nimport { Position, TextDocument } from 'vscode';\nimport { WordType } from './word';\n\nexport abstract class TextObject extends BaseMovement {\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualBlock];\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    const res = await this.execAction(position, vimState);\n    // Since we need to handle leading spaces, we cannot use MoveWordBegin.execActionForOperator\n    // In normal mode, the character on the stop position will be the first character after the operator executed\n    // and we do left-shifting in operator-pre-execution phase, here we need to right-shift the stop position accordingly.\n    res.stop = new Position(res.stop.line, res.stop.character + 1);\n\n    return res;\n  }\n\n  public abstract override execAction(position: Position, vimState: VimState): Promise<IMovement>;\n}\n\n@RegisterAction\nexport class SelectWord extends TextObject {\n  keys = ['a', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = TextEditor.getCharAt(vimState.document, position);\n\n    if (currentChar === undefined) {\n      start = position;\n      stop = position.nextWordEnd(vimState.document);\n    } else if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document).getRight();\n      stop = position.nextWordEnd(vimState.document);\n    } else {\n      stop = position.nextWordStart(vimState.document);\n      // If the next word is not at the beginning of the next line, we want to pretend it is.\n      // This is because 'aw' has two fundamentally different behaviors distinguished by whether\n      // the next word is directly after the current word, as described in the following comment.\n      // The only case that's not true is in cases like #1350.\n      if (stop.isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line))) {\n        stop = stop.getLineBegin();\n      }\n      stop = stop.getLeftThroughLineBreaks().getLeftIfEOL();\n      // If we aren't separated from the next word by whitespace(like in \"horse ca|t,dog\" or at the end of the line)\n      // then we delete the spaces to the left of the current word. Otherwise, we delete to the right.\n      // Also, if the current word is the leftmost word, we only delete from the start of the word to the end.\n      if (\n        stop.isEqual(position.nextWordEnd(vimState.document, { inclusive: true })) &&\n        !position\n          .prevWordStart(vimState.document, { inclusive: true })\n          .isEqual(TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, stop.line)) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.prevWordEnd(vimState.document).getRight();\n      } else {\n        start = position.prevWordStart(vimState.document, { inclusive: true });\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor position is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordStart(vimState.document, { inclusive: true });\n        } else {\n          stop = position.prevWordEnd(vimState.document).getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectABigWord extends TextObject {\n  keys = ['a', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (currentChar === undefined) {\n      start = position;\n      stop = position.nextWordEnd(vimState.document);\n    } else if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n      stop = position.nextWordEnd(vimState.document, { wordType: WordType.Big });\n    } else {\n      // Check 'aw' code for much of the reasoning behind this logic.\n      const nextWord = position.nextWordStart(vimState.document, { wordType: WordType.Big });\n      if (\n        (nextWord.line > position.line || nextWord.isAtDocumentEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        if (position.prevWordEnd(vimState.document, { wordType: WordType.Big }).isLineBeginning()) {\n          start = position.prevWordEnd(vimState.document, { wordType: WordType.Big });\n        } else {\n          start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        }\n        stop = position.getLineEnd();\n      } else if (\n        (nextWord.isEqual(\n          TextEditor.getFirstNonWhitespaceCharOnLine(vimState.document, nextWord.line)\n        ) ||\n          nextWord.isLineEnd()) &&\n        vimState.recordedState.count === 0\n      ) {\n        start = position.prevWordEnd(vimState.document).getRight();\n        stop = position.getLineEnd();\n      } else {\n        start = position.prevWordStart(vimState.document, {\n          wordType: WordType.Big,\n          inclusive: true,\n        });\n        stop = position.nextWordStart(vimState.document, { wordType: WordType.Big }).getLeft();\n      }\n    }\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordStart(vimState.document, { wordType: WordType.Big });\n        } else {\n          stop = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n/**\n * This is a custom action that I (johnfn) added. It selects procedurally\n * larger blocks. e.g. if you had \"blah (foo [bar 'ba|z'])\" then it would\n * select 'baz' first. If you pressed af again, it'd then select [bar 'baz'],\n * and if you did it a third time it would select \"(foo [bar 'baz'])\".\n *\n * Very similar is the now built-in `editor.action.smartSelect.expand`\n */\n@RegisterAction\nexport class SelectAnExpandingBlock extends ExpandingSelection {\n  keys = ['a', 'f'];\n  override modes = [Mode.Visual, Mode.VisualLine];\n\n  public override async execAction(\n    position: Position,\n    vimState: VimState,\n    firstIteration: boolean,\n    lastIteration: boolean\n  ): Promise<IMovement> {\n    const blocks = [\n      new MoveAroundDoubleQuotes(),\n      new MoveAroundSingleQuotes(),\n      new MoveAroundBacktick(),\n      new MoveAroundCurlyBrace(),\n      new MoveAroundParentheses(),\n      new MoveAroundSquareBracket(),\n      new MoveAroundTag(),\n    ];\n    // ideally no state would change as we test each of the possible expansions\n    // a deep copy of vimState could work here but may be expensive\n    let ranges: IMovement[] = [];\n    for (const block of blocks) {\n      const cursorPos = new Position(position.line, position.character);\n      const cursorStartPos = new Position(\n        vimState.cursorStartPosition.line,\n        vimState.cursorStartPosition.character\n      );\n      ranges.push(await block.execAction(cursorPos, vimState, firstIteration, lastIteration));\n      vimState.cursorStartPosition = cursorStartPos;\n    }\n\n    ranges = ranges.filter((range) => {\n      return !range.failed;\n    });\n\n    let smallestRange: Cursor | undefined;\n\n    for (const iMotion of ranges) {\n      const currentSelectedRange = new Cursor(\n        vimState.cursorStartPosition,\n        vimState.cursorStopPosition\n      );\n      if (iMotion.failed) {\n        continue;\n      }\n\n      const range = new Cursor(iMotion.start, iMotion.stop);\n      let contender: Cursor | undefined;\n\n      if (\n        range.start.isBefore(currentSelectedRange.start) &&\n        range.stop.isAfter(currentSelectedRange.stop)\n      ) {\n        if (!smallestRange) {\n          contender = range;\n        } else {\n          if (range.start.isAfter(smallestRange.start) && range.stop.isBefore(smallestRange.stop)) {\n            contender = range;\n          }\n        }\n      }\n\n      if (contender) {\n        const areTheyEqual =\n          contender.equals(new Cursor(vimState.cursorStartPosition, vimState.cursorStopPosition)) ||\n          (vimState.currentMode === Mode.VisualLine &&\n            contender.start.line === vimState.cursorStartPosition.line &&\n            contender.stop.line === vimState.cursorStopPosition.line);\n\n        if (!areTheyEqual) {\n          smallestRange = contender;\n        }\n      }\n    }\n    if (!smallestRange) {\n      return {\n        start: vimState.cursorStartPosition,\n        stop: vimState.cursorStopPosition,\n      };\n    } else {\n      // revert relevant state changes\n      vimState.cursorStartPosition = new Position(\n        smallestRange.start.line,\n        smallestRange.start.character\n      );\n      vimState.cursorStopPosition = new Position(\n        smallestRange.stop.line,\n        smallestRange.stop.character\n      );\n      vimState.recordedState.operatorPositionDiff = undefined;\n      return {\n        start: smallestRange.start,\n        stop: smallestRange.stop,\n      };\n    }\n  }\n}\n\n@RegisterAction\nexport class SelectInnerWord extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'w'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (currentChar === undefined) {\n      start = position;\n      stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n    } else if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document).getRight();\n      stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n    } else {\n      start = position.prevWordStart(vimState.document, { inclusive: true });\n      stop = position.nextWordEnd(vimState.document, { inclusive: true });\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordEnd(vimState.document).getRight();\n        } else {\n          stop = position.prevWordStart(vimState.document, { inclusive: true });\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerBigWord extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'W'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n    const currentChar = vimState.document.lineAt(position).text[position.character];\n\n    if (currentChar === undefined) {\n      start = position;\n      stop = position.nextWordStart(vimState.document).getLeftThroughLineBreaks();\n    } else if (/\\s/.test(currentChar)) {\n      start = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n      stop = position.nextWordStart(vimState.document, { wordType: WordType.Big }).getLeft();\n    } else {\n      start = position.prevWordStart(vimState.document, {\n        wordType: WordType.Big,\n        inclusive: true,\n      });\n      stop = position.nextWordEnd(vimState.document, {\n        wordType: WordType.Big,\n        inclusive: true,\n      });\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting words in reverser order.\n        if (/\\s/.test(currentChar)) {\n          stop = position.prevWordEnd(vimState.document, { wordType: WordType.Big }).getRight();\n        } else {\n          stop = position.prevWordStart(vimState.document, { wordType: WordType.Big });\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectSentence extends TextObject {\n  keys = ['a', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getSentenceEnd();\n    } else {\n      const nextSentenceBegin = currentSentenceBegin.getSentenceBegin({ forward: true });\n\n      // If the sentence has no trailing white spaces, `as` should include its leading white spaces.\n      if (nextSentenceBegin.isEqual(currentSentenceBegin.getSentenceEnd())) {\n        start = currentSentenceBegin\n          .getSentenceBegin({ forward: false })\n          .getSentenceEnd()\n          .getRight();\n        stop = nextSentenceBegin;\n      } else {\n        start = currentSentenceBegin;\n        stop = nextSentenceBegin.getLeft();\n      }\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin\n            .getSentenceBegin({ forward: false })\n            .getSentenceEnd()\n            .getRight();\n        } else {\n          stop = currentSentenceBegin;\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerSentence extends TextObject {\n  keys = ['i', 's'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position;\n    let stop: Position;\n\n    const currentSentenceBegin = position.getSentenceBegin({ forward: false });\n    const currentSentenceNonWhitespaceEnd = currentSentenceBegin.getSentenceEnd();\n\n    if (currentSentenceNonWhitespaceEnd.isBefore(position)) {\n      // The cursor is on a trailing white space.\n      start = currentSentenceNonWhitespaceEnd.getRight();\n      stop = currentSentenceBegin.getSentenceBegin({ forward: true }).getLeft();\n    } else {\n      start = currentSentenceBegin;\n      stop = currentSentenceNonWhitespaceEnd;\n    }\n\n    if (\n      vimState.currentMode === Mode.Visual &&\n      !vimState.cursorStopPosition.isEqual(vimState.cursorStartPosition)\n    ) {\n      start = vimState.cursorStartPosition;\n\n      if (vimState.cursorStopPosition.isBefore(vimState.cursorStartPosition)) {\n        // If current cursor postion is before cursor start position, we are selecting sentences in reverser order.\n        if (currentSentenceNonWhitespaceEnd.isAfter(vimState.cursorStopPosition)) {\n          stop = currentSentenceBegin;\n        } else {\n          stop = currentSentenceNonWhitespaceEnd.getRight();\n        }\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectParagraph extends TextObject {\n  keys = ['a', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, it can be both the start of next paragraph and the end of previous paragraph\n      start = getCurrentParagraphEnd(getCurrentParagraphBeginning(position, true), true);\n    } else {\n      if (currentParagraphBegin.isLineBeginning() && currentParagraphBegin.isLineEnd()) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n    }\n\n    // Include additional blank lines.\n    let stop = getCurrentParagraphEnd(position, true);\n    while (\n      stop.line < vimState.document.lineCount - 1 &&\n      vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n    ) {\n      stop = stop.with({ character: 0 }).getDown();\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectInnerParagraph extends TextObject {\n  keys = ['i', 'p'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    vimState.currentRegisterMode = RegisterMode.LineWise;\n\n    let start: Position;\n    let stop: Position;\n\n    if (vimState.document.lineAt(position).isEmptyOrWhitespace) {\n      // The cursor is at an empty line, so white lines are the paragraph.\n      start = position.getLineBegin();\n      stop = position.getLineEnd();\n      while (start.line > 0 && vimState.document.lineAt(start.getUp()).isEmptyOrWhitespace) {\n        start = start.getUp();\n      }\n      while (\n        stop.line < vimState.document.lineCount - 1 &&\n        vimState.document.lineAt(stop.getDown()).isEmptyOrWhitespace\n      ) {\n        stop = stop.with({ character: 0 }).getDown();\n      }\n    } else {\n      const currentParagraphBegin = getCurrentParagraphBeginning(position, true);\n      stop = getCurrentParagraphEnd(position, true);\n      if (vimState.document.lineAt(currentParagraphBegin).isEmptyOrWhitespace) {\n        start = currentParagraphBegin.getRightThroughLineBreaks();\n      } else {\n        start = currentParagraphBegin;\n      }\n\n      // Exclude additional blank lines.\n      while (stop.line > 0 && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n        stop = stop.getUp().getLineEnd();\n      }\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntire extends TextObject {\n  keys = ['a', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    return {\n      start: TextEditor.getDocumentBegin(),\n      stop: TextEditor.getDocumentEnd(vimState.document),\n    };\n  }\n}\n\n@RegisterAction\nexport class SelectEntireIgnoringLeadingTrailing extends TextObject {\n  keys = ['i', 'e'];\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    let start: Position = TextEditor.getDocumentBegin();\n    let stop: Position = TextEditor.getDocumentEnd(vimState.document);\n\n    while (start.line < stop.line && vimState.document.lineAt(start).isEmptyOrWhitespace) {\n      start = start.getDown();\n    }\n\n    while (stop.line > start.line && vimState.document.lineAt(stop).isEmptyOrWhitespace) {\n      stop = stop.getUp();\n    }\n    stop = stop.getLineEnd();\n\n    return {\n      start,\n      stop,\n    };\n  }\n}\n\nabstract class IndentObjectMatch extends TextObject {\n  override setsDesiredColumnToEOL = true;\n\n  protected includeLineAbove = false;\n  protected includeLineBelow = false;\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const isChangeOperator = vimState.recordedState.operator instanceof ChangeOperator;\n    const firstValidLineNumber = IndentObjectMatch.findFirstValidLine(vimState.document, position);\n    const firstValidLine = vimState.document.lineAt(firstValidLineNumber);\n    const cursorIndent = firstValidLine.firstNonWhitespaceCharacterIndex;\n\n    let startLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      -1\n    );\n    let endLineNumber = IndentObjectMatch.findRangeStartOrEnd(\n      vimState.document,\n      firstValidLineNumber,\n      cursorIndent,\n      1\n    );\n\n    // Adjust the start line as needed.\n    if (this.includeLineAbove) {\n      startLineNumber -= 1;\n    }\n    // Check for OOB.\n    if (startLineNumber < 0) {\n      startLineNumber = 0;\n    }\n\n    // Adjust the end line as needed.\n    if (this.includeLineBelow) {\n      endLineNumber += 1;\n    }\n    // Check for OOB.\n    if (endLineNumber > vimState.document.lineCount - 1) {\n      endLineNumber = vimState.document.lineCount - 1;\n    }\n\n    // If initiated by a change operation, adjust the cursor to the indent level\n    // of the block.\n    let startCharacter = 0;\n    if (isChangeOperator) {\n      startCharacter = vimState.document.lineAt(startLineNumber).firstNonWhitespaceCharacterIndex;\n    }\n    // TextEditor.getLineMaxColumn throws when given line 0, which we don't\n    // care about here since it just means this text object wouldn't work on a\n    // single-line document.\n    let endCharacter: number;\n    if (\n      endLineNumber === vimState.document.lineCount - 1 ||\n      vimState.currentMode === Mode.Visual ||\n      vimState.currentMode === Mode.VisualLine\n    ) {\n      endCharacter = TextEditor.getLineLength(endLineNumber);\n    } else {\n      endCharacter = 0;\n      endLineNumber++;\n    }\n    return {\n      start: new Position(startLineNumber, startCharacter),\n      stop: new Position(endLineNumber, endCharacter),\n    };\n  }\n\n  public override async execActionForOperator(\n    position: Position,\n    vimState: VimState\n  ): Promise<IMovement> {\n    return this.execAction(position, vimState);\n  }\n\n  /**\n   * Searches up from the cursor for the first non-empty line.\n   */\n  public static findFirstValidLine(document: TextDocument, cursorPosition: Position): number {\n    for (let i = cursorPosition.line; i >= 0; i--) {\n      if (!document.lineAt(i).isEmptyOrWhitespace) {\n        return i;\n      }\n    }\n\n    return cursorPosition.line;\n  }\n\n  /**\n   * Searches up or down from a line finding the first with a lower indent level.\n   */\n  public static findRangeStartOrEnd(\n    document: TextDocument,\n    startIndex: number,\n    cursorIndent: number,\n    step: -1 | 1\n  ): number {\n    let i = startIndex;\n    let ret = startIndex;\n    const end = step === 1 ? document.lineCount : -1;\n\n    for (; i !== end; i += step) {\n      const line = document.lineAt(i);\n      if (line.firstNonWhitespaceCharacterIndex < cursorIndent && !line.isEmptyOrWhitespace) {\n        break;\n      }\n\n      ret = i;\n    }\n\n    return ret;\n  }\n}\n\n@RegisterAction\nclass InsideIndentObject extends IndentObjectMatch {\n  keys = ['i', 'i'];\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n}\n\n@RegisterAction\nclass InsideIndentObjectAbove extends IndentObjectMatch {\n  keys = ['a', 'i'];\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override includeLineAbove = true;\n}\n\n@RegisterAction\nclass InsideIndentObjectBoth extends IndentObjectMatch {\n  keys = ['a', 'I'];\n  override modes = [Mode.Normal, Mode.Visual, Mode.VisualLine, Mode.VisualBlock];\n  override includeLineAbove = true;\n  override includeLineBelow = true;\n}\n\nabstract class SelectArgument extends TextObject {\n  override modes = [Mode.Normal, Mode.Visual];\n\n  private static openingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectOpeningDelimiters;\n  }\n  private static closingDelimiterCharacters(): string[] {\n    return configuration.argumentObjectClosingDelimiters;\n  }\n  private static separatorCharacters(): string[] {\n    return configuration.argumentObjectSeparators;\n  }\n\n  // SelectArgument supports two select types: inner and around.\n  //\n  // Inner will adjust start/stop positions, so that they are inside\n  // the delimiters (excluding the delimiters themselves).\n  // Around will adjust start/stop positions, so that ONE of them includes\n  // a separator character (optionally including extra whitespace).\n  protected selectAround = false;\n\n  // Requirement is that below example still works as expected, i.e.\n  // when we have nested pairs of parens\n  //\n  //        ( a, b, (void*) | c(void*, void*), a)\n  //\n  // Warning: For now, mismatched opening and closing delimiters, e.g.\n  // in (foo] will still be matched by this movement.\n  //\n  // Procedure:\n  //\n  // 1   Find boundaries left/right (i.e. where the argument starts/ends)\n  // 1.1 Walk left until we find a comma or an opening paren, that does not\n  //     have a matching closed one. This way we can ignore pairs\n  //     of parentheses which are part of the current argument.\n  // 1.2 Vice versa for walking right.\n  // 2   Depending on our mode (inner or around), improve the start/stop\n  //     locations for most consistent behaviour, especially in case of\n  //     multi-line statements.\n\n  public async execAction(position: Position, vimState: VimState): Promise<IMovement> {\n    const failure = failedMovement(vimState);\n\n    let leftSearchStartPosition = position;\n    let rightSearchStartPosition = position;\n\n    const charAtPos = TextEditor.getCharAt(vimState.document, position);\n\n    // When the cursor is on a delimiter already, pre-advance the cursor,\n    // so that our search actually spans a range. We will advance to the next argument,\n    // in case of opening delimiters or separators, and advance to the\n    // previous on closing delimiters.\n    if (\n      SelectArgument.separatorCharacters().includes(charAtPos) ||\n      SelectArgument.openingDelimiterCharacters().includes(charAtPos)\n    ) {\n      rightSearchStartPosition = position.getRightThroughLineBreaks(true);\n    } else if (SelectArgument.closingDelimiterCharacters().includes(charAtPos)) {\n      leftSearchStartPosition = position.getLeftThroughLineBreaks(true);\n    }\n\n    // Early abort, if no delimiters (i.e. (), [], etc.) surround us.\n    // This prevents applying the movement to surrounding separators across the buffer.\n    if (\n      SelectInnerArgument.findLeftArgumentBoundary(\n        vimState.document,\n        leftSearchStartPosition,\n        true\n      ) === undefined ||\n      SelectInnerArgument.findRightArgumentBoundary(\n        vimState.document,\n        rightSearchStartPosition,\n        true\n      ) === undefined\n    ) {\n      return failure;\n    }\n\n    const leftArgumentBoundary = SelectInnerArgument.findLeftArgumentBoundary(\n      vimState.document,\n      leftSearchStartPosition\n    );\n    if (leftArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    const rightArgumentBoundary = SelectInnerArgument.findRightArgumentBoundary(\n      vimState.document,\n      rightSearchStartPosition\n    );\n    if (rightArgumentBoundary === undefined) {\n      return failure;\n    }\n\n    let start: Position;\n    let stop: Position;\n\n    if (this.selectAround) {\n      const isLeftOnOpening: boolean = SelectArgument.openingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, leftArgumentBoundary)\n      );\n      const isRightOnClosing: boolean = SelectArgument.closingDelimiterCharacters().includes(\n        TextEditor.getCharAt(vimState.document, rightArgumentBoundary)\n      );\n\n      // Edge-case:\n      // Ensure we do not select anything if we have an empty argument list, e.g. \"()\"\n      const isEmptyArgumentList =\n        leftArgumentBoundary.getRight().isEqual(rightArgumentBoundary) &&\n        isLeftOnOpening &&\n        isRightOnClosing;\n      if (isEmptyArgumentList) {\n        return failure;\n      }\n\n      // Only when we are in the first argument we outset the right boundary\n      // until the first non-whitespace, so we do not end up with whitespace\n      // at the beginning of the parens.\n      const isInFirstArgument = isLeftOnOpening && !isRightOnClosing;\n      if (isInFirstArgument) {\n        stop = rightArgumentBoundary.getRight();\n        // Walk right until non-whitespace\n        while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop.getRight()))) {\n          stop = stop.getRight();\n        }\n      } else {\n        // In any other case, we inset\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n\n      // In case the left boundary is on a opening delimiter, move that position inwards\n      if (isLeftOnOpening) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n      } else {\n        start = leftArgumentBoundary;\n      }\n    } else {\n      // Inset the start once to get off the boundary and then keep\n      // going until the first non whitespace.\n      // This ensures that indented argument-lists keep the indentation.\n      start = leftArgumentBoundary.getRightThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, start))) {\n        start = start.getRightThroughLineBreaks(false);\n      }\n\n      // Same procedure for stop.\n      stop = rightArgumentBoundary.getLeftThroughLineBreaks(false);\n      while (/\\s/.test(TextEditor.getCharAt(vimState.document, stop))) {\n        stop = stop.getLeftThroughLineBreaks(false);\n      }\n\n      // Edge-case: Seems there is only whitespace in this argument.\n      // Omit any weird handling and just clear all whitespace.\n      if (stop.isBeforeOrEqual(start)) {\n        start = leftArgumentBoundary.getRightThroughLineBreaks(true);\n        stop = rightArgumentBoundary.getLeftThroughLineBreaks(true);\n      }\n    }\n\n    // Handle case when cursor is not inside the anticipated movement range\n    if (position.isBefore(start)) {\n      vimState.recordedState.operatorPositionDiff = start.subtract(position);\n    }\n    vimState.cursorStartPosition = start;\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  private static findLeftArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let closedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (closedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.openingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          // We have found the left most delimiter or the first proper delimiter\n          // in our cursor's list 'depth' and thus can abort.\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        closedParensCount++;\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        closedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentBegin()) {\n        break;\n      }\n\n      walkingPosition = walkingPosition.getLeftThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n\n  private static findRightArgumentBoundary(\n    document: TextDocument,\n    position: Position,\n    ignoreSeparators: boolean = false\n  ): Position | undefined {\n    let delimiterPosition: Position | undefined;\n    let walkingPosition = position;\n    let openedParensCount = 0;\n\n    while (true) {\n      const char = TextEditor.getCharAt(document, walkingPosition);\n      if (openedParensCount === 0) {\n        let isOnBoundary: boolean = SelectArgument.closingDelimiterCharacters().includes(char);\n        if (!ignoreSeparators) {\n          isOnBoundary ||= SelectArgument.separatorCharacters().includes(char);\n        }\n\n        if (isOnBoundary) {\n          delimiterPosition = walkingPosition;\n          break;\n        }\n      }\n      if (SelectArgument.openingDelimiterCharacters().includes(char)) {\n        openedParensCount++;\n      }\n      if (SelectArgument.closingDelimiterCharacters().includes(char)) {\n        openedParensCount--;\n      }\n\n      if (walkingPosition.isAtDocumentEnd()) {\n        break;\n      }\n\n      // We need to include the EOL so that isAtDocumentEnd actually\n      // becomes true.\n      walkingPosition = walkingPosition.getRightThroughLineBreaks(true);\n    }\n\n    return delimiterPosition;\n  }\n}\n\n@RegisterAction\nexport class SelectInnerArgument extends SelectArgument {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['i', 'a'];\n}\n\n@RegisterAction\nexport class SelectAroundArgument extends SelectArgument {\n  override modes = [Mode.Normal, Mode.Visual];\n  keys = ['a', 'a'];\n  override selectAround = true;\n}\n","export function getAllPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    positions.push(result.index);\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n\nexport function getAllEndPositions(line: string, regex: RegExp): number[] {\n  const positions: number[] = [];\n  let result = regex.exec(line);\n\n  while (result) {\n    if (result[0].length) {\n      positions.push(result.index + result[0].length - 1);\n    }\n\n    // Handles the case where an empty string match causes lastIndex not to advance,\n    // which gets us in an infinite loop.\n    if (result.index === regex.lastIndex) {\n      regex.lastIndex++;\n    }\n    result = regex.exec(line);\n  }\n\n  return positions;\n}\n","import * as _ from 'lodash';\nimport { Position, TextDocument } from 'vscode';\nimport { configuration } from '../configuration/configuration';\nimport { getAllPositions, getAllEndPositions } from './util';\n\nexport enum WordType {\n  Normal,\n  Big,\n  CamelCase,\n  FileName,\n}\n\nconst nonBigWordCharRegex = makeWordRegex('');\nconst nonFileNameRegex = makeWordRegex('\"\\'`;<>{}[]()');\n\nfunction regexForWordType(wordType: WordType): RegExp {\n  switch (wordType) {\n    case WordType.Normal:\n      return makeUnicodeWordRegex(configuration.iskeyword);\n    case WordType.Big:\n      return nonBigWordCharRegex;\n    case WordType.CamelCase:\n      return makeCamelCaseWordRegex(configuration.iskeyword);\n    case WordType.FileName:\n      return nonFileNameRegex;\n  }\n}\n\n/**\n * Get the position of the word counting from the position specified.\n * @param text The string to search from.\n * @param pos The position of text to search from.\n * @returns The character position of the word to the left relative to the text and the pos.\n *          undefined if there is no word to the left of the postion.\n */\nexport function getWordLeftInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getWordLeftOnLine(text, pos, wordType);\n}\n\nexport function getWordRightInText(\n  text: string,\n  pos: number,\n  wordType: WordType\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType)).find((index) => index > pos);\n}\n\nexport function prevWordStart(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine >= 0; currentLine--) {\n    const newCharacter = getWordLeftOnLine(\n      document.lineAt(currentLine).text,\n      pos.character,\n      wordType,\n      currentLine !== pos.line,\n      inclusive\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction getWordLeftOnLine(\n  text: string,\n  pos: number,\n  wordType: WordType,\n  forceFirst: boolean = false,\n  inclusive: boolean = false\n): number | undefined {\n  return getAllPositions(text, regexForWordType(wordType))\n    .reverse()\n    .find((index) => (index < pos && !inclusive) || (index <= pos && inclusive) || forceFirst);\n}\n\nexport function nextWordStart(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n    const positions = getAllPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(document.lineCount - 1, 0).getLineEnd();\n}\n\nexport function nextWordEnd(\n  document: TextDocument,\n  pos: Position,\n  wordType: WordType,\n  inclusive: boolean = false\n): Position {\n  for (let currentLine = pos.line; currentLine < document.lineCount; currentLine++) {\n    const positions = getAllEndPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    const newCharacter = positions.find(\n      (index) =>\n        (index > pos.character && !inclusive) ||\n        (index >= pos.character && inclusive) ||\n        currentLine !== pos.line\n    );\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(document.lineCount - 1, 0).getLineEnd();\n}\n\nexport function prevWordEnd(document: TextDocument, pos: Position, wordType: WordType): Position {\n  for (let currentLine = pos.line; currentLine > -1; currentLine--) {\n    let positions = getAllEndPositions(\n      document.lineAt(currentLine).text,\n      regexForWordType(wordType)\n    );\n    // if one line is empty, use the 0 position as the default value\n    if (positions.length === 0) {\n      positions.push(0);\n    }\n    // reverse the list to find the biggest element smaller than pos.character\n    positions = positions.reverse();\n    const index = positions.findIndex((i) => i < pos.character || currentLine !== pos.line);\n    let newCharacter = 0;\n    if (index === -1) {\n      if (currentLine > -1) {\n        continue;\n      }\n      newCharacter = positions[positions.length - 1];\n    } else {\n      newCharacter = positions[index];\n    }\n\n    if (newCharacter !== undefined) {\n      return new Position(currentLine, newCharacter);\n    }\n  }\n\n  return new Position(0, 0);\n}\n\nfunction makeWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments = [`([^\\\\s${escaped}]+)`, `[${escaped}]+`, `$^`];\n\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeCamelCaseWordRegex(characterSet: string): RegExp {\n  const escaped = characterSet && _.escapeRegExp(characterSet).replace(/-/g, '\\\\-');\n  const segments: string[] = [];\n\n  // Older browsers don't support lookbehind - in this case, use an inferior regex rather than crashing\n  let supportsLookbehind = true;\n  try {\n    // tslint:disable-next-line\n    new RegExp('(?<=x)');\n  } catch {\n    supportsLookbehind = false;\n  }\n\n  // prettier-ignore\n  const firstSegment =\n      '(' +                                             // OPEN: group for matching camel case words\n      `[^\\\\s${escaped}_]` +                             //   words can start with any non-keyword non-underscore character\n      '(?:' +                                           //   OPEN: group for characters after initial char\n      `(?:${supportsLookbehind ? '(?<=[A-Z_])' : ''}` + //     If first char was a capital\n      `[A-Z](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all caps\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[0-9_])' : ''}` + //     If first char was a digit\n      `[0-9](?=[\\\\sA-Z0-9${escaped}_]))+` +             //       the word can continue with all digits\n      '|' +                                             //     OR\n      `(?:${supportsLookbehind ? '(?<=[_])' : ''}` +    //     If first char was an underscore\n      `[_](?=[\\\\s${escaped}_]))+`  +                    //       the word can continue with all underscores\n      '|' +                                             //     OR\n      `[^\\\\sA-Z0-9${escaped}_]*` +                      //     Continue with regular characters\n      ')' +                                             //   END: group for characters after initial char\n      ')' +                                             // END: group for matching camel case words\n      '';\n\n  segments.push(firstSegment);\n  segments.push(`[${escaped}]+`);\n  segments.push(`$^`);\n\n  // it can be difficult to grok the behavior of the above regex\n  // feel free to check out https://regex101.com/r/mkVeiH/1 as a live example\n  return new RegExp(segments.join('|'), 'g');\n}\n\nfunction makeUnicodeWordRegex(keywordChars: string): RegExp {\n  // Distinct categories of characters\n  enum CharKind {\n    Punctuation,\n    Superscript,\n    Subscript,\n    Braille,\n    Ideograph,\n    Hiragana,\n    Katakana,\n    Hangul,\n  }\n\n  // List of printable characters (code point intervals) and their character kinds.\n  // Latin alphabets (e.g., ASCII alphabets and numbers,  Latin-1 Supplement, European Latin) are excluded.\n  // Imported from utf_class_buf in src/mbyte.c of Vim.\n  const symbolTable: Array<[[number, number], CharKind]> = [\n    [[0x00a1, 0x00bf], CharKind.Punctuation], // Latin-1 punctuation\n    [[0x037e, 0x037e], CharKind.Punctuation], // Greek question mark\n    [[0x0387, 0x0387], CharKind.Punctuation], // Greek ano teleia\n    [[0x055a, 0x055f], CharKind.Punctuation], // Armenian punctuation\n    [[0x0589, 0x0589], CharKind.Punctuation], // Armenian full stop\n    [[0x05be, 0x05be], CharKind.Punctuation],\n    [[0x05c0, 0x05c0], CharKind.Punctuation],\n    [[0x05c3, 0x05c3], CharKind.Punctuation],\n    [[0x05f3, 0x05f4], CharKind.Punctuation],\n    [[0x060c, 0x060c], CharKind.Punctuation],\n    [[0x061b, 0x061b], CharKind.Punctuation],\n    [[0x061f, 0x061f], CharKind.Punctuation],\n    [[0x066a, 0x066d], CharKind.Punctuation],\n    [[0x06d4, 0x06d4], CharKind.Punctuation],\n    [[0x0700, 0x070d], CharKind.Punctuation], // Syriac punctuation\n    [[0x0964, 0x0965], CharKind.Punctuation],\n    [[0x0970, 0x0970], CharKind.Punctuation],\n    [[0x0df4, 0x0df4], CharKind.Punctuation],\n    [[0x0e4f, 0x0e4f], CharKind.Punctuation],\n    [[0x0e5a, 0x0e5b], CharKind.Punctuation],\n    [[0x0f04, 0x0f12], CharKind.Punctuation],\n    [[0x0f3a, 0x0f3d], CharKind.Punctuation],\n    [[0x0f85, 0x0f85], CharKind.Punctuation],\n    [[0x104a, 0x104f], CharKind.Punctuation], // Myanmar punctuation\n    [[0x10fb, 0x10fb], CharKind.Punctuation], // Georgian punctuation\n    [[0x1361, 0x1368], CharKind.Punctuation], // Ethiopic punctuation\n    [[0x166d, 0x166e], CharKind.Punctuation], // Canadian Syl. punctuation\n    [[0x169b, 0x169c], CharKind.Punctuation],\n    [[0x16eb, 0x16ed], CharKind.Punctuation],\n    [[0x1735, 0x1736], CharKind.Punctuation],\n    [[0x17d4, 0x17dc], CharKind.Punctuation], // Khmer punctuation\n    [[0x1800, 0x180a], CharKind.Punctuation], // Mongolian punctuation\n    [[0x200c, 0x2027], CharKind.Punctuation], // punctuation and symbols\n    [[0x202a, 0x202e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2030, 0x205e], CharKind.Punctuation], // punctuation and symbols\n    [[0x2060, 0x27ff], CharKind.Punctuation], // punctuation and symbols\n    [[0x2070, 0x207f], CharKind.Superscript], // superscript\n    [[0x2080, 0x2094], CharKind.Subscript], // subscript\n    [[0x20a0, 0x27ff], CharKind.Punctuation], // all kinds of symbols\n    [[0x2800, 0x28ff], CharKind.Braille], // braille\n    [[0x2900, 0x2998], CharKind.Punctuation], // arrows, brackets, etc.\n    [[0x29d8, 0x29db], CharKind.Punctuation],\n    [[0x29fc, 0x29fd], CharKind.Punctuation],\n    [[0x2e00, 0x2e7f], CharKind.Punctuation], // supplemental punctuation\n    [[0x3001, 0x3020], CharKind.Punctuation], // ideographic punctuation\n    [[0x3030, 0x3030], CharKind.Punctuation],\n    [[0x303d, 0x303d], CharKind.Punctuation],\n    [[0x3040, 0x309f], CharKind.Hiragana], // Hiragana\n    [[0x30a0, 0x30ff], CharKind.Katakana], // Katakana\n    [[0x3300, 0x9fff], CharKind.Ideograph], // CJK Ideographs\n    [[0xac00, 0xd7a3], CharKind.Hangul], // Hangul Syllables\n    [[0xf900, 0xfaff], CharKind.Ideograph], // CJK Ideographs\n    [[0xfd3e, 0xfd3f], CharKind.Punctuation],\n    [[0xfe30, 0xfe6b], CharKind.Punctuation], // punctuation forms\n    [[0xff00, 0xff0f], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff1a, 0xff20], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff3b, 0xff40], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0xff5b, 0xff65], CharKind.Punctuation], // half/fullwidth ASCII\n    [[0x20000, 0x2a6df], CharKind.Ideograph], // CJK Ideographs\n    [[0x2a700, 0x2b73f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2b740, 0x2b81f], CharKind.Ideograph], // CJK Ideographs\n    [[0x2f800, 0x2fa1f], CharKind.Ideograph], // CJK Ideographs\n  ];\n\n  const codePointRangePatterns: string[][] = [];\n  for (const kind in CharKind) {\n    if (!isNaN(Number(kind))) {\n      codePointRangePatterns[kind] = [];\n    }\n  }\n\n  for (const [[first, last], kind] of symbolTable) {\n    if (first === last) {\n      // '\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}`);\n    } else {\n      // '\\u{hhhh}-\\u{hhhh}'\n      codePointRangePatterns[kind].push(`\\\\u{${first.toString(16)}}-\\\\u{${last.toString(16)}}`);\n    }\n  }\n\n  // Symbols in vim.iskeyword or editor.wordSeparators\n  // are treated as CharKind.Punctuation\n  const escapedKeywordChars = _.escapeRegExp(keywordChars).replace(/-/g, '\\\\-');\n  codePointRangePatterns[Number(CharKind.Punctuation)].push(escapedKeywordChars);\n\n  const codePointRanges = codePointRangePatterns.map((patterns) => patterns.join(''));\n  const symbolSegments = codePointRanges.map((range) => `([${range}]+)`);\n\n  // wordSegment matches word characters.\n  // A word character is a symbol which is neither\n  // - space\n  // - a symbol listed in the table\n  // - a keyword (vim.iskeyword)\n  const wordSegment = `([^\\\\s${codePointRanges.join('')}]+)`;\n\n  // https://regex101.com/r/X1agK6/2\n  const segments = symbolSegments.concat(wordSegment, '$^');\n  return new RegExp(segments.join('|'), 'ug');\n}\n","import * as vscode from 'vscode';\nimport { Logger } from '../util/logger';\nimport {\n  isTextTransformation,\n  TextTransformations,\n  Transformation,\n  isMultiCursorTextTransformation,\n  InsertTextVSCodeTransformation,\n  areAllSameTransformation,\n  overlappingTransformations,\n} from './transformations';\nimport { ExCommandLine } from '../cmd_line/commandLine';\nimport { PositionDiff } from '../common/motion/position';\nimport { Mode } from '../mode/mode';\nimport { Register } from '../register/register';\nimport { RecordedState } from '../state/recordedState';\nimport { TextEditor } from '../textEditor';\nimport { Cursor } from '../common/motion/cursor';\nimport { VimState } from '../state/vimState';\nimport { Transformer } from './transformer';\nimport { Globals } from '../globals';\nimport { keystrokesExpressionParser } from '../vimscript/expression';\n\nexport interface IModeHandler {\n  vimState: VimState;\n\n  updateView(args?: { drawSelection: boolean; revealRange: boolean }): Promise<void>;\n  runMacro(recordedMacro: RecordedState): Promise<void>;\n  handleMultipleKeyEvents(keys: string[]): Promise<void>;\n  rerunRecordedState(recordedState: RecordedState): Promise<void>;\n}\n\nconst logger = Logger.get('Parser');\n\nexport async function executeTransformations(\n  modeHandler: IModeHandler,\n  transformations: Transformation[]\n) {\n  if (transformations.length === 0) {\n    return;\n  }\n\n  const vimState = modeHandler.vimState;\n\n  const textTransformations: TextTransformations[] = transformations.filter((x) =>\n    isTextTransformation(x)\n  ) as any;\n  const multicursorTextTransformations: InsertTextVSCodeTransformation[] = transformations.filter(\n    (x) => isMultiCursorTextTransformation(x)\n  ) as any;\n\n  const otherTransformations = transformations.filter(\n    (x) => !isTextTransformation(x) && !isMultiCursorTextTransformation(x)\n  );\n\n  const accumulatedPositionDifferences: { [key: number]: PositionDiff[] } = {};\n\n  const doTextEditorEdit = (command: TextTransformations, edit: vscode.TextEditorEdit) => {\n    switch (command.type) {\n      case 'insertText':\n        edit.insert(command.position, command.text);\n        break;\n      case 'replaceText':\n        edit.replace(command.range, command.text);\n        break;\n      case 'deleteRange':\n        edit.delete(command.range);\n        break;\n      case 'moveCursor':\n        break;\n      default:\n        logger.warn(`Unhandled text transformation type: ${command.type}.`);\n        break;\n    }\n\n    if (command.diff) {\n      if (command.cursorIndex === undefined) {\n        throw new Error('No cursor index - this should never ever happen!');\n      }\n\n      if (!accumulatedPositionDifferences[command.cursorIndex]) {\n        accumulatedPositionDifferences[command.cursorIndex] = [];\n      }\n\n      accumulatedPositionDifferences[command.cursorIndex].push(command.diff);\n    }\n  };\n\n  if (textTransformations.length > 0) {\n    const overlapping = overlappingTransformations(textTransformations);\n    if (overlapping !== undefined) {\n      const msg = `Transformations overlapping: ${JSON.stringify(overlapping)}`;\n      logger.warn(msg);\n      if (Globals.isTesting) {\n        throw new Error(msg);\n      }\n\n      // TODO: Select one transformation for every cursor and run them all\n      // in parallel. Repeat till there are no more transformations.\n      for (const transformation of textTransformations) {\n        await vimState.editor.edit((edit) => doTextEditorEdit(transformation, edit));\n      }\n    } else {\n      // This is the common case!\n\n      /**\n       * batch all text operations together as a single operation\n       * (this is primarily necessary for multi-cursor mode, since most\n       * actions will trigger at most one text operation).\n       */\n      try {\n        await vimState.editor.edit((edit) => {\n          for (const command of textTransformations) {\n            doTextEditorEdit(command, edit);\n          }\n        });\n      } catch (e) {\n        // Messages like \"TextEditor(vs.editor.ICodeEditor:1,$model8) has been disposed\" can be ignored.\n        // They occur when the user switches to a new tab while an action is running.\n        if (e.name !== 'DISPOSED') {\n          e.context = {\n            currentMode: Mode[vimState.currentMode],\n            cursors: vimState.cursors.map((cursor) => cursor.toString()),\n            actionsRunPressedKeys: vimState.recordedState.actionsRunPressedKeys,\n            actionsRun: vimState.recordedState.actionsRun.map((action) => action.constructor.name),\n            textTransformations,\n          };\n          throw e;\n        }\n      }\n    }\n  }\n\n  if (multicursorTextTransformations.length > 0) {\n    if (areAllSameTransformation(multicursorTextTransformations)) {\n      /**\n       * Apply the transformation only once instead of to each cursor\n       * if they are all the same.\n       *\n       * This lets VSCode do multicursor snippets, auto braces and\n       * all the usual jazz VSCode does on text insertion.\n       */\n      const { text } = multicursorTextTransformations[0];\n\n      // await vscode.commands.executeCommand('default:type', { text });\n      await TextEditor.insert(vimState.editor, text);\n    } else {\n      logger.warn(`Unhandled multicursor transformations. Not all transformations are the same!`);\n    }\n  }\n\n  for (const transformation of otherTransformations) {\n    switch (transformation.type) {\n      case 'insertTextVSCode':\n        await TextEditor.insert(vimState.editor, transformation.text);\n        vimState.cursors[0] = Cursor.FromVSCodeSelection(vimState.editor.selection);\n        break;\n\n      case 'replayRecordedState':\n        await modeHandler.rerunRecordedState(transformation.recordedState.clone());\n        break;\n\n      case 'macro':\n        const recordedMacro = (await Register.get(transformation.register))?.text;\n        if (!recordedMacro) {\n          return;\n        } else if (typeof recordedMacro === 'string') {\n          // A string was set to the register. We need to execute the characters as if they were typed (in normal mode).\n          const keystrokes = keystrokesExpressionParser.parse(recordedMacro);\n          if (!keystrokes.status) {\n            throw new Error(`Failed to execute macro: ${recordedMacro}`);\n          }\n\n          vimState.isReplayingMacro = true;\n\n          vimState.recordedState = new RecordedState();\n          await modeHandler.handleMultipleKeyEvents(keystrokes.value);\n\n          // Set the executed register as the registerName, otherwise the last action register is used.\n          vimState.recordedState.registerName = transformation.register;\n\n          vimState.lastInvokedMacro = vimState.recordedState;\n          vimState.isReplayingMacro = false;\n\n          if (vimState.lastMovementFailed) {\n            // movement in last invoked macro failed then we should stop all following repeating macros.\n            // Besides, we should reset `lastMovementFailed`.\n            vimState.lastMovementFailed = false;\n            return;\n          }\n        } else {\n          vimState.isReplayingMacro = true;\n\n          vimState.recordedState = new RecordedState();\n          if (transformation.register === ':') {\n            await new ExCommandLine(recordedMacro.commandString, vimState.currentMode).run(\n              vimState\n            );\n          } else if (transformation.replay === 'contentChange') {\n            await modeHandler.runMacro(recordedMacro);\n          } else {\n            let keyStrokes: string[] = [];\n            for (const action of recordedMacro.actionsRun) {\n              keyStrokes = keyStrokes.concat(action.keysPressed);\n            }\n            await modeHandler.handleMultipleKeyEvents(keyStrokes);\n          }\n\n          // TODO: Copied from `BaseAction.execCount`. This is all terrible.\n          for (const t of vimState.recordedState.transformer.transformations) {\n            if (isTextTransformation(t) && t.cursorIndex === undefined) {\n              t.cursorIndex = 0;\n            }\n          }\n\n          await executeTransformations(\n            modeHandler,\n            vimState.recordedState.transformer.transformations\n          );\n\n          vimState.isReplayingMacro = false;\n          vimState.lastInvokedMacro = recordedMacro;\n\n          if (vimState.lastMovementFailed) {\n            // movement in last invoked macro failed then we should stop all following repeating macros.\n            // Besides, we should reset `lastMovementFailed`.\n            vimState.lastMovementFailed = false;\n            return;\n          }\n        }\n        break;\n\n      case 'contentChange':\n        for (const change of transformation.changes) {\n          await TextEditor.insert(vimState.editor, change.text);\n          vimState.cursorStopPosition = vimState.editor.selection.start;\n        }\n        const newPos = vimState.cursorStopPosition.add(vimState.document, transformation.diff);\n        vimState.editor.selection = new vscode.Selection(newPos, newPos);\n        break;\n\n      case 'vscodeCommand':\n        await vscode.commands.executeCommand(transformation.command, ...transformation.args);\n        break;\n\n      default:\n        logger.warn(`Unhandled text transformation type: ${transformation.type}.`);\n        break;\n    }\n  }\n\n  const selections = vimState.editor.selections.map((sel) => {\n    let range = Cursor.FromVSCodeSelection(sel);\n    if (range.start.isBefore(range.stop)) {\n      range = range.withNewStop(range.stop.getLeftThroughLineBreaks(true));\n    }\n    return new vscode.Selection(range.start, range.stop);\n  });\n  const firstTransformation = transformations[0];\n  const manuallySetCursorPositions =\n    (firstTransformation.type === 'deleteRange' ||\n      firstTransformation.type === 'replaceText' ||\n      firstTransformation.type === 'insertText') &&\n    firstTransformation.manuallySetCursorPositions;\n\n  // We handle multiple cursors in a different way in visual block mode, unfortunately.\n  // TODO - refactor that out!\n  if (vimState.currentMode !== Mode.VisualBlock && !manuallySetCursorPositions) {\n    vimState.cursors = selections.map((sel, idx) => {\n      const diffs = accumulatedPositionDifferences[idx] ?? [];\n      if (vimState.recordedState.operatorPositionDiff) {\n        diffs.push(vimState.recordedState.operatorPositionDiff);\n      }\n\n      return diffs.reduce(\n        (cursor, diff) =>\n          new Cursor(\n            cursor.start.add(vimState.document, diff),\n            cursor.stop.add(vimState.document, diff)\n          ),\n        Cursor.FromVSCodeSelection(sel)\n      );\n    });\n\n    vimState.recordedState.operatorPositionDiff = undefined;\n  } else if (accumulatedPositionDifferences[0]?.length > 0) {\n    const diff = accumulatedPositionDifferences[0][0];\n    vimState.cursorStopPosition = vimState.cursorStopPosition.add(vimState.document, diff);\n    vimState.cursorStartPosition = vimState.cursorStartPosition.add(vimState.document, diff);\n  }\n\n  vimState.recordedState.transformer = new Transformer();\n}\n","import { Position, Range, TextDocumentContentChangeEvent } from 'vscode';\nimport { RecordedState } from '../state/recordedState';\nimport { PositionDiff } from './../common/motion/position';\n\n/**\n * This file contains definitions of objects that represent text\n * additions/deletions/replacements on the document. You'll add them\n * to vimState.recordedState.transformer.transformations and then they will be applied\n * later on.\n *\n * We do it in this way so they can all be processed in parallel and merged\n * if necessary.\n */\n\n/**\n * Represents inserting text at a position in the document.\n */\nexport interface InsertTextTransformation {\n  /**\n   * Type of this insertion (used for type checking with discriminated\n   * union types).\n   */\n  type: 'insertText';\n\n  /**\n   * Text content of this insertion.\n   */\n  text: string;\n\n  /**\n   * The location to insert the text.\n   */\n  position: Position;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface ReplaceTextTransformation {\n  type: 'replaceText';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Range of characters to replace.\n   */\n  range: Range;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\n/**\n * Represents inserting a character and allowing visual studio to do\n * its post-character stuff if it wants. (e.g., if you type \"(\" this\n * will automatically add the closing \")\").\n */\nexport interface InsertTextVSCodeTransformation {\n  type: 'insertTextVSCode';\n\n  /**\n   * Text to insert.\n   */\n  text: string;\n\n  /**\n   * Whether this transformation was created in multicursor mode.\n   */\n  isMultiCursor?: boolean;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n}\n\n/**\n * Represents deleting a range of characters.\n */\nexport interface DeleteTextRangeTransformation {\n  type: 'deleteRange';\n\n  /**\n   * Range of characters to delete.\n   */\n  range: Range;\n\n  /**\n   * A position diff that will be added to the position of the cursor after\n   * the replace transformation has been applied.\n   *\n   * If you don't know what this is, just ignore it. You probably don't need it.\n   */\n  diff?: PositionDiff;\n\n  /**\n   * The index of the cursor that this transformation applies to.\n   */\n  cursorIndex?: number;\n\n  /**\n   * Please don't use this! It's a hack.\n   */\n  manuallySetCursorPositions?: boolean;\n}\n\nexport interface MoveCursorTransformation {\n  type: 'moveCursor';\n\n  cursorIndex?: number;\n\n  /**\n   * Move the cursor this much.\n   */\n  diff: PositionDiff;\n}\n\n/**\n * Replays a RecordedState. Used for `.`, primarily.\n */\nexport interface Dot {\n  type: 'replayRecordedState';\n  recordedState: RecordedState;\n}\n\nexport interface VSCodeCommandTransformation {\n  type: 'vscodeCommand';\n  command: string;\n  args: any[];\n}\n\n/**\n * Represents macro\n */\nexport interface Macro {\n  type: 'macro';\n  register: string;\n  replay: 'contentChange' | 'keystrokes';\n}\n\n/**\n * Represents updating document content changes\n */\nexport interface ContentChangeTransformation {\n  type: 'contentChange';\n  changes: TextDocumentContentChangeEvent[];\n  diff: PositionDiff;\n}\n\nexport type Transformation =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | ReplaceTextTransformation\n  | DeleteTextRangeTransformation\n  | MoveCursorTransformation\n  | Dot\n  | Macro\n  | ContentChangeTransformation\n  | VSCodeCommandTransformation;\n\n/**\n * Text Transformations\n *\n * Using these indicates that you want Visual Studio Code to execute your text\n * actions as a batch operation. It's a bit tricky because we defer cursor updating\n * behavior to whatever the batch operation returns, so if you update the cursor in your\n * Action, VSCode will override whatever you did.\n *\n * If your cursor isn't ending up in the right place, you can adjust it by passing along\n * a PositionDiff.\n *\n * (There are a LOT of weird edge cases with cursor behavior that we don't want to have to reimplement. Trust\n * me... I tried.)\n */\nexport type TextTransformations =\n  | InsertTextTransformation\n  | InsertTextVSCodeTransformation\n  | DeleteTextRangeTransformation\n  | MoveCursorTransformation\n  | ReplaceTextTransformation;\n\nexport const isTextTransformation = (x: Transformation): x is TextTransformations => {\n  return (\n    x.type === 'insertText' ||\n    x.type === 'replaceText' ||\n    x.type === 'deleteRange' ||\n    x.type === 'moveCursor'\n  );\n};\nexport const isMultiCursorTextTransformation = (x: Transformation): boolean => {\n  return (x.type === 'insertTextVSCode' && x.isMultiCursor) ?? false;\n};\n\nconst getRangeFromTextTransformation = (transformation: TextTransformations): Range | undefined => {\n  switch (transformation.type) {\n    case 'insertText':\n      return new Range(\n        transformation.position,\n        transformation.position.advancePositionByText(transformation.text)\n      );\n    case 'replaceText':\n      // TODO: Do we need to do the same sort of thing here as for insertText?\n      return transformation.range;\n    case 'deleteRange':\n      return transformation.range;\n    case 'moveCursor':\n      return undefined;\n  }\n\n  throw new Error('Unhandled text transformation: ' + transformation);\n};\n\nexport function overlappingTransformations(\n  transformations: TextTransformations[]\n): [TextTransformations, TextTransformations] | undefined {\n  for (let i = 0; i < transformations.length; i++) {\n    for (let j = i + 1; j < transformations.length; j++) {\n      const first = transformations[i];\n      const second = transformations[j];\n\n      const firstRange = getRangeFromTextTransformation(first);\n      const secondRange = getRangeFromTextTransformation(second);\n\n      if (!firstRange || !secondRange) {\n        continue;\n      }\n\n      const intersection = firstRange.intersection(secondRange);\n      if (intersection && !intersection.start.isEqual(intersection.end)) {\n        return [first, second];\n      }\n    }\n  }\n\n  return undefined;\n}\n\nexport const areAllSameTransformation = (transformations: Transformation[]): boolean => {\n  const firstTransformation = transformations[0];\n\n  return transformations.every((t) => {\n    return Object.entries(t).every(([key, value]) => {\n      return firstTransformation[key] === value;\n    });\n  });\n};\n\nexport function stringify(transformation: Transformation): string {\n  if (transformation.type === 'replayRecordedState') {\n    return `Replay: ${transformation.recordedState.actionsRun\n      .map((x) => x.keysPressed.join(''))\n      .join('')}`;\n  } else {\n    return JSON.stringify(transformation);\n  }\n}\n","import { Position, Range } from 'vscode';\nimport { PositionDiff } from '../common/motion/position';\nimport { Logger } from '../util/logger';\nimport { stringify, Transformation } from './transformations';\n\n/**\n * This class is (ideally) responsible for managing all changes made to document state, via @see Transformation.\n * Currently, changes are queued up within Actions and then executed (more or less) all at once.\n *\n * NOTE: This whole system is heavily WIP as I work through a large piecemeal refactor.\n */\nexport class Transformer {\n  public readonly transformations: Transformation[] = [];\n\n  private logger = Logger.get('Transformer');\n\n  public addTransformation(transformation: Transformation): void {\n    this.logger.debug(`Adding Transformation ${stringify(transformation)}`);\n    this.transformations.push(transformation);\n  }\n\n  public insert(position: Position, text: string, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'insertText', position, text, diff });\n  }\n\n  public delete(range: Range, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'deleteRange', range, diff });\n  }\n\n  public replace(range: Range, text: string, diff?: PositionDiff): void {\n    this.addTransformation({ type: 'replaceText', range, text, diff });\n  }\n\n  public moveCursor(diff: PositionDiff, cursorIndex?: number): void {\n    this.addTransformation({ type: 'moveCursor', diff, cursorIndex });\n  }\n\n  public vscodeCommand(command: string, ...args: any[]): void {\n    this.addTransformation({ type: 'vscodeCommand', command, args });\n  }\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\n/**\n * A thin wrapper around `vscode.env.clipboard`\n */\nexport class Clipboard {\n  private static readonly logger = Logger.get('Clipboard');\n\n  public static async Copy(text: string): Promise<void> {\n    try {\n      await vscode.env.clipboard.writeText(text);\n    } catch (e) {\n      this.logger.error(`Error copying to clipboard. err=${e}`);\n    }\n  }\n\n  public static async Paste(): Promise<string> {\n    return vscode.env.clipboard.readText();\n  }\n}\n","import { Range, DecorationOptions } from 'vscode';\n\n/**\n * Alias for the types of arrays that can be passed to a TextEditor's setDecorations method\n */\nexport type EditorDecorationArray = Range[] | DecorationOptions[];\n\n/**\n * Decorations associated with search/substitute operations\n */\nexport type SearchDecorations = {\n  searchHighlight?: EditorDecorationArray;\n  searchMatch?: EditorDecorationArray;\n  substitutionAppend?: EditorDecorationArray;\n  substitutionReplace?: EditorDecorationArray;\n};\n\n/**\n * @returns a DecorationOptions object representing the given range. If the\n * given range is empty, the range of the returned object will be extended one\n * character to the right. If the given range cannot be extended right, or\n * represents the end of a line (possibly containing EOL characters), the\n * returned object will specify an after element with the width of a single\n * character.\n */\nexport function ensureVisible(range: Range): DecorationOptions {\n  return (range.isEmpty || range.end.isLineBeginning()) && range.start.isLineEnd()\n    ? {\n        // range is at EOL, possibly containing EOL char(s).\n        range: range.with(undefined, range.start),\n        renderOptions: {\n          after: {\n            color: 'transparent',\n            contentText: '$', // non-whitespace character to set width.\n          },\n        },\n      }\n    : range.isEmpty\n    ? { range: range.with(undefined, range.end.translate(0, 1)) } // extend range one character right\n    : { range };\n}\n\n/**\n * @returns a version of the input string suitable for use as the contentText of a decoration's before or after element\n */\nexport function formatDecorationText(\n  text: string,\n  tabsize: number,\n  newlineReplacement: string | ((substring: string, ...args: any[]) => string) = '\\u23ce' // \"\" RETURN SYMBOL\n) {\n  // surround with zero-width space to prevent trimming\n  return `\\u200b${text\n    // vscode collapses whitespace in decorations; modify text to prevent this.\n    .replace(/ /g, '\\u00a0') // \" \" NO-BREAK SPACE\n    .replace(/\\t/g, '\\u00a0'.repeat(tabsize))\n    // Decorations can't change the apparent # of lines in the editor, so we must settle for a single-line version of our text\n    .replace(/\\r\\n|[\\r\\n]/g, newlineReplacement as any)}\\u200b`;\n}\n\n/**\n * @returns search decorations for the given ranges, taking into account the current match\n */\nexport function getDecorationsForSearchMatchRanges(\n  ranges: Range[],\n  currentMatchIndex?: number\n): SearchDecorations {\n  const searchHighlight: DecorationOptions[] = [];\n  const searchMatch: DecorationOptions[] = [];\n\n  for (let i = 0; i < ranges.length; i++) {\n    (i === currentMatchIndex ? searchMatch : searchHighlight).push(ensureVisible(ranges[i]));\n  }\n\n  return { searchHighlight, searchMatch };\n}\n","import { VimError, ErrorCode } from '../error';\nimport { configuration } from '../configuration/configuration';\n\nclass ExternalCommand {\n  private previousExternalCommand: string | undefined;\n\n  /**\n   * Expands the given command by replacing any '!' with the previous external\n   * command. The '!' can be escaped if there is a backslash preceeding the\n   * '!', then the backslash is removed and the '!' is kept.\n   *\n   * If a '!' is present but there is no previous external command, then a\n   * VimError is thrown.\n   * @param command the command to expand\n   */\n  private expandCommand(command: string): string {\n    const result: string[] = [];\n\n    for (let i = 0; i < command.length; i++) {\n      if (command[i] === '!') {\n        if (i > 0 && command[i - 1] === '\\\\') {\n          // escape the '!' and keep it\n          result.pop();\n          result.push('!');\n        } else if (!this.previousExternalCommand) {\n          // no previous command available to substitute\n          throw VimError.fromCode(ErrorCode.NoPreviousCommand);\n        } else {\n          result.push(this.previousExternalCommand);\n        }\n      } else {\n        result.push(command[i]);\n      }\n    }\n    return result.join('');\n  }\n\n  /**\n   * Executes `command` and returns the output.\n   * @param command the command to run\n   * @param stdin string to pipe into stdin\n   */\n  private async execute(command: string, stdin: string): Promise<string> {\n    const output: string[] = [];\n    const options = {\n      shell: configuration.shell || undefined,\n    };\n\n    try {\n      const exec = (await import('../util/child_process')).exec;\n\n      const promise = exec(command, options);\n      const process = promise.child;\n\n      if (process.stdin !== null) {\n        process.stdin.on('error', () => {\n          // Make write EPIPE errors silent (e.g. when writing to program not expecting stdin)\n        });\n        process.stdin.write(stdin);\n        process.stdin.end();\n      }\n\n      if (process.stdout !== null) {\n        process.stdout.on('data', (chunk) => output.push(chunk));\n      }\n      if (process.stderr !== null) {\n        process.stderr.on('data', (chunk) => output.push(chunk));\n      }\n\n      await promise;\n    } catch (e) {\n      // exec throws an error if exit code != 0\n      // keep going and read the output anyway (just like vim)\n    }\n    return output.join('');\n  }\n\n  /**\n   * Runs the given command and returns the output (stdout and stderr).\n   * Optionally, `stdin` can be piped into stdin during execution.\n   *\n   * @param command the command to run\n   * @param stdin string to pipe into stdin, by default the empty string\n   */\n  public async run(command: string, stdin: string = ''): Promise<string> {\n    command = this.expandCommand(command);\n    this.previousExternalCommand = command;\n    // combines stdout and stderr (compatible for all platforms)\n    command += ' 2>&1';\n\n    let output = await this.execute(command, stdin);\n    // vim behavior, trim newlines\n    if (output.endsWith('\\r\\n')) {\n      output = output.slice(0, -2);\n    } else if (output.endsWith('\\n')) {\n      output = output.slice(0, -1);\n    }\n\n    return output;\n  }\n}\n\nexport const externalCommand = new ExternalCommand();\n","import { ILogger } from 'src/platform/common/logger';\nimport { LoggerImpl } from 'platform/loggerImpl';\nimport { IConfiguration } from 'src/configuration/iconfiguration';\n\nexport class Logger {\n  private static readonly cache = new Map<string, ILogger>();\n  private static configuration: IConfiguration | undefined = undefined;\n\n  static get(prefix: string): ILogger {\n    let logger = Logger.cache.get(prefix);\n    if (logger === undefined) {\n      logger = LoggerImpl.get(prefix);\n      if (Logger.configuration) {\n        logger.configChanged(Logger.configuration);\n      }\n      Logger.cache.set(prefix, logger);\n    }\n\n    return logger;\n  }\n\n  static configChanged(configuration: IConfiguration) {\n    Logger.configuration = configuration;\n    for (const logger of this.cache.values()) {\n      logger.configChanged(configuration);\n    }\n  }\n}\n","import * as vscode from 'vscode';\nimport * as path from 'path';\nimport untildify = require('untildify');\n\n/**\n * A interface to the path in the node.js.\n */\ninterface Path {\n  normalize(p: string): string;\n  join(...paths: string[]): string;\n  resolve(...pathSegments: string[]): string;\n  isAbsolute(p: string): boolean;\n  relative(from: string, to: string): string;\n  dirname(p: string): string;\n  basename(p: string, ext?: string): string;\n  extname(p: string): string;\n  sep: string;\n  delimiter: string;\n}\n\n/**\n * Separate a partial path or full path into dirname and the basename.\n * @param searchPath The path to separate.\n * @param sep The separator of the searchPath.\n * @return A two-element array where the first element is the dirname and the second\n * is the basename.\n */\nexport function separatePath(searchPath: string, sep: string) {\n  // Special handle for UNC path on windows\n  if (sep === path.win32.sep) {\n    if (searchPath[0] === sep && searchPath[1] === sep) {\n      const idx = searchPath.indexOf(sep, 2);\n      if (idx === -1) {\n        // If there isn't a complete UNC path,\n        // return the incomplete UNC as baseName\n        // e.g. \\\\test-server is an incomplete path\n        // and \\\\test-server\\ is a complete path\n        return [searchPath, ''];\n      }\n    }\n  }\n\n  const baseNameIndex = searchPath.lastIndexOf(sep) + 1;\n  const baseName = searchPath.slice(baseNameIndex);\n  const dirName = searchPath.slice(0, baseNameIndex);\n  return [dirName, baseName];\n}\n\n/**\n * The comment is used conjunction with getPathDetails.\n */\ninterface PathDetails {\n  /**\n   * A full absolute path resolved from directory of the currently active document.\n   * If the active document is an untitled document, full path will be dirName of\n   * the input partialPath.\n   */\n  fullPath: string;\n  /**\n   * A full absolute path of the directory of fullPath.\n   * If the active document is an untitled document, full path will be the input partialPath.\n   */\n  fullDirPath: string;\n  /**\n   * The dir name of partialPath.\n   * If the partialPath is an absolute path, this will be equal to fullDirPat\n   * If partialPath is ./abc/xyz.txt, baseName will be './abc/'\n   * If partialPath is /abc/xyz.txt, baseName will be '/abc/'\n   */\n  dirName: string;\n  /**\n   * A base name of the partialPath.\n   * If partialPath is ./abc/xyz.txt, baseName will be 'xyz.txt'\n   * If partialPath is /abc/xyz.txt, baseName will be 'xyz.txt'\n   */\n  baseName: string;\n  /**\n   * An updated partialPath which has its / changed to \\ on Windows.\n   */\n  partialPath: string;\n  /**\n   * The correct node js path for the partial path. This will be either\n   * path.win32 or path.posix for further processing.\n   */\n  path: Path;\n}\n\n/**\n * Get path detail.\n *\n * If the currently active document is an untitled document, we will assume the partialPath\n * is a Windows path only when the VS Code is running on Windows, and not remote session; else, posix path.\n *\n * If the currently active document is not an untitled document, we will assume the partialPath\n * is a Windows path when the current uri is local file where the first character of fsPath of the\n * current uri is not \"/\"; otherwise, posix path. fsPath can return C:\\path\\avc.txt or \\\\drive\\location\\abc.txt\n * on Windows.\n *\n * This is to maximize usability of the combination of Windows and posix machine using remote while browsing\n * file on both local and remote.\n *\n * @param partialPath A string of relative path to the directory of the currentUri,\n * or an absolute path in the environment of the currentUri.\n * ~/ can be used only if active document is local document, or local untitled document.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return A PathDetail.\n */\nexport function getPathDetails(\n  partialPath: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n): PathDetails {\n  let isWindows: boolean;\n  if (currentUri.scheme === 'untitled') {\n    // Assume remote server is nix only\n    isWindows = path === path.win32 && !isRemote;\n  } else {\n    // Assuming other schemes return full path\n    // e.g. 'file' and 'vscode-remote' both return full path\n    // Also only scheme that support Windows is 'file', so we can\n    // safely check if fsPath returns '/' as the first character\n    // (fsPath in 'vscode-remote' on Windows return \\ as separator instead of /)\n    isWindows = currentUri.scheme === 'file' && currentUri.fsPath[0] !== '/';\n  }\n\n  const p = isWindows ? path.win32 : path.posix;\n  if (isWindows) {\n    // normalize / to \\ on windows\n    partialPath = partialPath.replace(/\\//g, '\\\\');\n  }\n  const updatedPartialPath = partialPath;\n\n  if (currentUri.scheme === 'file' || (currentUri.scheme === 'untitled' && !isRemote)) {\n    // We can untildify when the scheme is 'file' or 'untitled' on local fs because\n    // because we only support opening files mounted locally.\n    partialPath = untildify(partialPath);\n  }\n\n  const [dirName, baseName] = separatePath(partialPath, p.sep);\n  let fullDirPath: string;\n  if (p.isAbsolute(dirName)) {\n    fullDirPath = dirName;\n  } else {\n    fullDirPath = p.join(\n      // On Windows machine:\n      // fsPath returns Windows drive path (C:\\xxx\\) or UNC path (\\\\server\\xxx)\n      // fsPath returns path with \\ as separator even if 'vscode-remote' is connect to a linux box\n      //\n      // path will return /home/user for example even 'vscode-remote' is used on windows\n      // as we relied of our isWindows detection\n      separatePath(isWindows ? currentUri.fsPath : currentUri.path, p.sep)[0],\n      dirName\n    );\n  }\n\n  const fullPath = p.join(fullDirPath, baseName);\n  return {\n    fullPath,\n    fullDirPath,\n    dirName,\n    baseName,\n    partialPath: updatedPartialPath,\n    path: p,\n  };\n}\n\n/**\n * Resolve the absolutePath to Uri.\n *\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * This is used to determine we should consider absolutePath a Windows path.\n * @param currentUri A uri to resolve the absolutePath to Uri.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @return null if the absolutePath is invalid. A uri resolved with the currentUri.\n */\nexport function resolveUri(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean\n) {\n  const isWindows = sep === path.win32.sep;\n  if (isWindows && !/^(\\\\\\\\.+\\\\)|([a-zA-Z]:\\\\)/.test(absolutePath)) {\n    // if it is windows and but don't have either\n    // UNC path or the windows drive\n    return null;\n  }\n  if (!isWindows && absolutePath[0] !== sep) {\n    // if it is not windows, but the absolute path doesn't begin with /\n    return null;\n  }\n\n  const isLocalUntitled = !isRemote && currentUri.scheme === 'untitled';\n  return isWindows\n    ? // Create new local Uri when it's on windows.\n      // Only local resource is support (vscode-remote doesn't have windows path)\n      // UNC path like //server1/folder should also work.\n      vscode.Uri.file(absolutePath)\n    : currentUri.with({\n        // search local file with currently active document is a local untitled doc\n        scheme: isLocalUntitled ? 'file' : currentUri.scheme,\n        path: absolutePath,\n      });\n}\n\n/**\n * Get the name of the items in a directory.\n * @param absolutePath A string of absolute path.\n * @param sep The separator of the absolutePath.\n * @param currentUri A uri of the currently active document.\n * @param isRemote A boolean to indicate if the current instance is in remote.\n * @param addCurrentAndUp A boolean to indicate if .{$sep} and ..${sep} should be add to the result\n * @return A Promise which resolves to an array of string. The array can be empty if the path specified is actual\n * empty, of if the absolutePath specified is invalid, or if any error occurred during directory reading.\n * The string in the array will have sep appended if it is a directory.\n */\nexport async function readDirectory(\n  absolutePath: string,\n  sep: string,\n  currentUri: vscode.Uri,\n  isRemote: boolean,\n  addCurrentAndUp: boolean\n) {\n  try {\n    const directoryUri = resolveUri(absolutePath, sep, currentUri, isRemote);\n    if (directoryUri === null) {\n      return [];\n    }\n    const directoryResult = await vscode.workspace.fs.readDirectory(directoryUri);\n    return (\n      directoryResult\n        // Add the separator at the end to the path if it is a directory\n        .map((d) => d[0] + (d[1] === vscode.FileType.Directory ? sep : ''))\n        // Add ./ and ../ to the result if specified\n        .concat(addCurrentAndUp ? [`.${sep}`, `..${sep}`] : [])\n    );\n  } catch {\n    return [];\n  }\n}\n\nexport function join(...paths: string[]): string {\n  return path.join(...paths);\n}\n","export enum SpecialKeys {\n  ExtensionEnable = '<ExtensionEnable>',\n  ExtensionDisable = '<ExtensionDisable>',\n  TimeoutFinished = '<TimeoutFinished>',\n}\n","import { Mode } from '../mode/mode';\nimport { StatusBar } from '../statusBar';\nimport { VimState } from '../state/vimState';\nimport { configuration } from '../configuration/configuration';\nimport { Position } from 'vscode';\n\n/**\n * Escapes substrings that would be interpreted as css icon markdown in certain\n * ui labels, including the status bar.\n */\nexport function escapeCSSIcons(text: string): string {\n  // regex from iconLabel implementation at\n  // https://github.com/microsoft/vscode/blob/9b75bd1f813e683bf46897d85387089ec083fb24/src/vs/base/browser/ui/iconLabel/iconLabels.ts#L9\n  return text.replace(/\\\\?\\$\\([A-Za-z0-9\\-]+(?:~[A-Za-z]+)?\\)/g, '\\\\$&');\n}\n\n/**\n * Shows the number of lines you just changed (with `dG`, for instance), if it\n * crosses a configured threshold.\n * @param numLinesChanged The number of lines changed\n */\nexport function reportLinesChanged(numLinesChanged: number, vimState: VimState) {\n  if (numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${numLinesChanged} more lines`);\n  } else if (-numLinesChanged > configuration.report) {\n    StatusBar.setText(vimState, `${Math.abs(numLinesChanged)} fewer lines`);\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the number of lines you just yanked, if it crosses a configured threshold.\n * @param numLinesYanked The number of lines yanked\n */\nexport function reportLinesYanked(numLinesYanked: number, vimState: VimState) {\n  if (numLinesYanked > configuration.report) {\n    if (vimState.currentMode === Mode.VisualBlock) {\n      StatusBar.setText(vimState, `block of ${numLinesYanked} lines yanked`);\n    } else {\n      StatusBar.setText(vimState, `${numLinesYanked} lines yanked`);\n    }\n  } else {\n    StatusBar.clear(vimState);\n  }\n}\n\n/**\n * Shows the active file's path and line count as well as position in the file as a percentage.\n * Triggered via `<C-g>` or `:f[ile]`.\n */\nexport function reportFileInfo(position: Position, vimState: VimState) {\n  const doc = vimState.document;\n  const fileName = doc.isUntitled ? '[No Name]' : doc.fileName;\n  const modified = doc.isDirty ? ' [Modified]' : '';\n\n  if (doc.lineCount === 1 && doc.lineAt(0).text.length === 0) {\n    // TODO: Vim behaves slightly differently - seems this is only shown for new buffer that hasn't been saved to disk\n    StatusBar.setText(vimState, `\"${fileName}\"${modified} --No lines in buffer--`);\n  } else {\n    const progress = Math.floor(((position.line + 1) / doc.lineCount) * 100);\n    StatusBar.setText(\n      vimState,\n      `\"${fileName}\"${modified} ${doc.lineCount} line${\n        doc.lineCount > 1 ? 's' : ''\n      } --${progress}%--`\n    );\n  }\n}\n\n/**\n * Shows the number of matches and current match index of a search.\n * @param matchIdx Index of current match, starting at 0\n * @param numMatches Total number of matches\n * @param vimState The current `VimState`\n */\nexport function reportSearch(matchIdx: number, numMatches: number, vimState: VimState) {\n  StatusBar.setText(vimState, `match ${matchIdx + 1} of ${numMatches}`);\n}\n","import * as vscode from 'vscode';\nimport { Cursor } from '../common/motion/cursor';\nimport { VimState } from '../state/vimState';\n\n/**\n * We used to have an issue where we would do something like execute a VSCode\n * command, and would encounter race conditions because the cursor positions\n * wouldn't yet be updated. So we waited for a selection change event, but\n * this doesn't seem to be necessary any more.\n *\n * @deprecated Calls to this should probably be replaced with calls to `ModeHandler::syncCursors()` or something...\n */\nexport function getCursorsAfterSync(editor: vscode.TextEditor): Cursor[] {\n  return editor.selections.map((x) => Cursor.FromVSCodeSelection(x));\n}\n\nexport function clamp(num: number, min: number, max: number) {\n  return Math.min(Math.max(num, min), max);\n}\n\nexport function scrollView(vimState: VimState, offset: number) {\n  if (offset !== 0) {\n    vimState.postponedCodeViewChanges.push({\n      command: 'editorScroll',\n      args: {\n        to: offset > 0 ? 'up' : 'down',\n        by: 'line',\n        value: Math.abs(offset),\n        revealCursor: false,\n        select: false,\n      },\n    });\n  }\n}\n\nexport function assertDefined<X>(x: X | undefined, err: string): asserts x {\n  if (x === undefined) {\n    throw new Error(err);\n  }\n}\n\nexport function isHighSurrogate(charCode: number): boolean {\n  return 0xd800 <= charCode && charCode <= 0xdbff;\n}\n\nexport function isLowSurrogate(charCode: number): boolean {\n  return 0xdc00 <= charCode && charCode <= 0xdfff;\n}\n","import * as vscode from 'vscode';\nimport { Logger } from './logger';\n\ntype ContextValue = boolean | string;\n\n/**\n * Wrapper around VS Code's `setContext`.\n * The API call takes several milliseconds to seconds to complete,\n * so let's cache the values and only call the API when necessary.\n */\nexport abstract class VSCodeContext {\n  private static readonly cache: Map<string, ContextValue> = new Map();\n\n  public static async set(key: string, value: ContextValue): Promise<void> {\n    const prev = this.get(key);\n    if (prev !== value) {\n      Logger.get('vscode-context').debug(`Setting key='${key}' to value='${value}'`);\n      this.cache.set(key, value);\n      await vscode.commands.executeCommand('setContext', key, value);\n    }\n  }\n\n  public static get(key: string): ContextValue | undefined {\n    return this.cache.get(key);\n  }\n}\n","import { ErrorCode, VimError } from '../error';\nimport { VimState } from '../state/vimState';\nimport { LineRange } from './lineRange';\n\nexport abstract class ExCommand {\n  /**\n   * If this returns true and Neovim integration is enabled, we'll send this command to Neovim.\n   */\n  public neovimCapable(): boolean {\n    return false;\n  }\n\n  public readonly isRepeatableWithDot: boolean = true;\n\n  abstract execute(vimState: VimState): Promise<void>;\n\n  async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    // By default, throw E481 (\"No range allowed\")\n    throw VimError.fromCode(ErrorCode.NoRangeAllowed);\n  }\n}\n","import { all, alt, optWhitespace, Parser, regexp, seq, string, succeed } from 'parsimmon';\nimport { AsciiCommand } from '../cmd_line/commands/ascii';\nimport { BangCommand } from '../cmd_line/commands/bang';\nimport { Breakpoints } from '../cmd_line/commands/breakpoints';\nimport { BufferDeleteCommand } from '../cmd_line/commands/bufferDelete';\nimport { CloseCommand } from '../cmd_line/commands/close';\nimport { CopyCommand } from '../cmd_line/commands/copy';\nimport { DeleteCommand } from '../cmd_line/commands/delete';\nimport { DigraphsCommand } from '../cmd_line/commands/digraph';\nimport { FileCommand } from '../cmd_line/commands/file';\nimport { FileInfoCommand } from '../cmd_line/commands/fileInfo';\nimport { GotoCommand } from '../cmd_line/commands/goto';\nimport { GotoLineCommand } from '../cmd_line/commands/gotoLine';\nimport { HistoryCommand } from '../cmd_line/commands/history';\nimport { ClearJumpsCommand, JumpsCommand } from '../cmd_line/commands/jumps';\nimport { CenterCommand, LeftCommand, RightCommand } from '../cmd_line/commands/leftRightCenter';\nimport { DeleteMarksCommand, MarksCommand } from '../cmd_line/commands/marks';\nimport { NohlCommand } from '../cmd_line/commands/nohl';\nimport { OnlyCommand } from '../cmd_line/commands/only';\nimport { PrintCommand } from '../cmd_line/commands/print';\nimport { PutExCommand } from '../cmd_line/commands/put';\nimport { QuitCommand } from '../cmd_line/commands/quit';\nimport { ReadCommand } from '../cmd_line/commands/read';\nimport { RegisterCommand } from '../cmd_line/commands/register';\nimport { RetabCommand } from '../cmd_line/commands/retab';\nimport { SetCommand } from '../cmd_line/commands/set';\nimport { ShCommand } from '../cmd_line/commands/sh';\nimport { ShiftCommand } from '../cmd_line/commands/shift';\nimport { SmileCommand } from '../cmd_line/commands/smile';\nimport { SortCommand } from '../cmd_line/commands/sort';\nimport { SubstituteCommand } from '../cmd_line/commands/substitute';\nimport { TabCommand } from '../cmd_line/commands/tab';\nimport { TerminalCommand } from '../cmd_line/commands/terminal';\nimport { UndoCommand } from '../cmd_line/commands/undo';\nimport { VsCodeCommand } from '../cmd_line/commands/vscode';\nimport { WallCommand } from '../cmd_line/commands/wall';\nimport { WriteCommand } from '../cmd_line/commands/write';\nimport { WriteQuitCommand } from '../cmd_line/commands/writequit';\nimport { WriteQuitAllCommand } from '../cmd_line/commands/writequitall';\nimport { YankCommand } from '../cmd_line/commands/yank';\nimport { ErrorCode, VimError } from '../error';\nimport { VimState } from '../state/vimState';\nimport { StatusBar } from '../statusBar';\nimport { ExCommand } from './exCommand';\nimport { LineRange } from './lineRange';\nimport { nameAbbrevParser } from './parserUtils';\n\ntype ArgParser = Parser<ExCommand>;\n\n/**\n * A list of all builtin ex commands and their argument parsers\n * Each element is [[abbrev, rest], argParser]\n * If argParser is undefined, it's yet to be implemented (PRs are welcome!)\n *\n * This list comes directly from nvim's `:help index` (except a few additions, which are commented)\n */\nexport const builtinExCommands: ReadonlyArray<[[string, string], ArgParser | undefined]> = [\n  [['', ''], succeed(new GotoLineCommand())],\n  [['!', ''], BangCommand.argParser],\n  [['#', ''], PrintCommand.argParser({ printNumbers: true, printText: true })],\n  [['#!', ''], all.map((_) => new NoOpCommand())],\n  [['&', ''], undefined],\n  [['*', ''], undefined],\n  [['<', ''], ShiftCommand.argParser('<')],\n  [['=', ''], PrintCommand.argParser({ printNumbers: true, printText: false })],\n  [['>', ''], ShiftCommand.argParser('>')],\n  [['@', ''], undefined],\n  [['@@', ''], undefined],\n  [['N', 'ext'], undefined],\n  [['a', 'ppend'], undefined],\n  [['ab', 'breviate'], undefined],\n  [['abc', 'lear'], undefined],\n  [['abo', 'veleft'], undefined],\n  [['al', 'l'], undefined],\n  [['am', 'enu'], undefined],\n  [['an', 'oremenu'], undefined],\n  [['ar', 'gs'], undefined],\n  [['arga', 'dd'], undefined],\n  [['argd', 'elete'], undefined],\n  [['argdo', ''], undefined],\n  [['arge', 'dit'], undefined],\n  [['argg', 'lobal'], undefined],\n  [['argl', 'ocal'], undefined],\n  [['argu', 'ment'], undefined],\n  [['as', 'cii'], succeed(new AsciiCommand())],\n  [['au', 'tocmd'], undefined],\n  [['aug', 'roup'], undefined],\n  [['aun', 'menu'], undefined],\n  [['b', 'uffer'], undefined],\n  [['bN', 'ext'], TabCommand.argParsers.bprev],\n  [['ba', 'll'], undefined],\n  [['bad', 'd'], undefined],\n  [['balt', ''], undefined],\n  [['bd', 'elete'], BufferDeleteCommand.argParser],\n  [['be', 'have'], undefined],\n  [['bel', 'owright'], undefined],\n  [['bf', 'irst'], TabCommand.argParsers.bfirst],\n  [['bl', 'ast'], TabCommand.argParsers.blast],\n  [['bm', 'odified'], undefined],\n  [['bn', 'ext'], TabCommand.argParsers.bnext],\n  [['bo', 'tright'], undefined],\n  [['bp', 'revious'], TabCommand.argParsers.bprev],\n  [['br', 'ewind'], TabCommand.argParsers.bfirst],\n  [['brea', 'k'], undefined],\n  [['breaka', 'dd'], Breakpoints.argParsers.add],\n  [['breakd', 'el'], Breakpoints.argParsers.del],\n  [['breakl', 'ist'], Breakpoints.argParsers.list],\n  [['bro', 'wse'], undefined],\n  [['bufdo', ''], undefined],\n  [['buffers', ''], undefined],\n  [['bun', 'load'], undefined],\n  [['bw', 'ipeout'], undefined],\n  [['c', 'hange'], undefined],\n  [['cN', 'ext'], undefined],\n  [['cNf', 'ile'], undefined],\n  [['ca', 'bbrev'], undefined],\n  [['cabc', 'lear'], undefined],\n  [['cabo', 've'], undefined],\n  [['cad', 'dbuffer'], undefined],\n  [['cadde', 'xpr'], undefined],\n  [['caddf', 'ile'], undefined],\n  [['caf', 'ter'], undefined],\n  [['cal', 'l'], undefined],\n  [['cat', 'ch'], undefined],\n  [['cb', 'uffer'], undefined],\n  [['cbef', 'ore'], undefined],\n  [['cbel', 'ow'], undefined],\n  [['cbo', 'ttom'], undefined],\n  [['cc', ''], undefined],\n  [['ccl', 'ose'], undefined],\n  [['cd', ''], undefined],\n  [['cdo', ''], undefined],\n  [['ce', 'nter'], CenterCommand.argParser],\n  [['cex', 'pr'], undefined],\n  [['cf', 'ile'], undefined],\n  [['cfd', 'o'], undefined],\n  [['cfir', 'st'], undefined],\n  [['cg', 'etfile'], undefined],\n  [['cgetb', 'uffer'], undefined],\n  [['cgete', 'xpr'], undefined],\n  [['changes', ''], undefined],\n  [['chd', 'ir'], undefined],\n  [['che', 'ckpath'], undefined],\n  [['checkh', 'ealth'], undefined],\n  [['checkt', 'ime'], undefined],\n  [['chi', 'story'], undefined],\n  [['cl', 'ist'], undefined],\n  [['cla', 'st'], undefined],\n  [['cle', 'arjumps'], succeed(new ClearJumpsCommand())],\n  [['clo', 'se'], CloseCommand.argParser],\n  [['cm', 'ap'], undefined],\n  [['cmapc', 'lear'], undefined],\n  [['cme', 'nu'], undefined],\n  [['cn', 'ext'], undefined],\n  [['cnew', 'er'], undefined],\n  [['cnf', 'ile'], undefined],\n  [['cno', 'remap'], undefined],\n  [['cnorea', 'bbrev'], undefined],\n  [['cnoreme', 'nu'], undefined],\n  [['co', 'py'], CopyCommand.argParser],\n  [['col', 'der'], undefined],\n  [['colo', 'rscheme'], undefined],\n  [['com', 'mand'], undefined],\n  [['comc', 'lear'], undefined],\n  [['comp', 'iler'], undefined],\n  [['con', 'tinue'], undefined],\n  [['conf', 'irm'], undefined],\n  [['cons', 't'], undefined],\n  [['cope', 'n'], undefined],\n  [['cp', 'revious'], undefined],\n  [['cpf', 'ile'], undefined],\n  [['cq', 'uit'], undefined],\n  [['cr', 'ewind'], undefined],\n  [['cs', 'cope'], undefined],\n  [['cst', 'ag'], undefined],\n  [['cu', 'nmap'], undefined],\n  [['cuna', 'bbrev'], undefined],\n  [['cunme', 'nu'], undefined],\n  [['cw', 'indow'], undefined],\n  [['d', 'elete'], DeleteCommand.argParser],\n  [['deb', 'ug'], undefined],\n  [['debugg', 'reedy'], undefined],\n  [['delc', 'ommand'], undefined],\n  [['delf', 'unction'], undefined],\n  [['delm', 'arks'], DeleteMarksCommand.argParser],\n  [['di', 'splay'], RegisterCommand.argParser],\n  [['dif', 'fupdate'], undefined],\n  [['diffg', 'et'], undefined],\n  [['diffo', 'ff'], undefined],\n  [['diffp', 'atch'], undefined],\n  [['diffpu', 't'], undefined],\n  [['diffs', 'plit'], undefined],\n  [['diffthis', ''], undefined],\n  [['dig', 'raphs'], DigraphsCommand.argParser],\n  [['dj', 'ump'], undefined],\n  [['dl', ''], undefined],\n  [['dli', 'st'], undefined],\n  [['do', 'autocmd'], undefined],\n  [['doautoa', 'll'], undefined],\n  [['dr', 'op'], undefined],\n  [['ds', 'earch'], undefined],\n  [['dsp', 'lit'], undefined],\n  [['e', 'dit'], FileCommand.argParsers.edit],\n  [['ea', 'rlier'], undefined],\n  [['ec', 'ho'], undefined],\n  [['echoe', 'rr'], undefined],\n  [['echoh', 'l'], undefined],\n  [['echom', 'sg'], undefined],\n  [['echon', ''], undefined],\n  [['el', 'se'], undefined],\n  [['elsei', 'f'], undefined],\n  [['em', 'enu'], undefined],\n  [['en', 'dif'], undefined],\n  [['endf', 'unction'], undefined],\n  [['endfo', 'r'], undefined],\n  [['endt', 'ry'], undefined],\n  [['endw', 'hile'], undefined],\n  [['ene', 'w'], FileCommand.argParsers.enew],\n  [['ev', 'al'], undefined],\n  [['ex', ''], FileCommand.argParsers.edit],\n  [['exe', 'cute'], undefined],\n  [['exi', 't'], WriteQuitCommand.argParser],\n  [['exu', 'sage'], undefined],\n  [['f', 'ile'], FileInfoCommand.argParser],\n  [['files', ''], undefined],\n  [['filet', 'ype'], undefined],\n  [['filt', 'er'], undefined],\n  [['fin', 'd'], undefined],\n  [['fina', 'lly'], undefined],\n  [['fini', 'sh'], undefined],\n  [['fir', 'st'], undefined],\n  [['fo', 'ld'], undefined],\n  [['foldc', 'lose'], undefined],\n  [['foldd', 'oopen'], undefined],\n  [['folddoc', 'losed'], undefined],\n  [['foldo', 'pen'], undefined],\n  [['for', ''], undefined],\n  [['fu', 'nction'], undefined],\n  [['g', 'lobal'], undefined],\n  [['go', 'to'], GotoCommand.argParser],\n  [['gr', 'ep'], undefined],\n  [['grepa', 'dd'], undefined],\n  [['gu', 'i'], undefined],\n  [['gv', 'im'], undefined],\n  [['h', 'elp'], undefined],\n  [['ha', 'rdcopy'], undefined],\n  [['helpc', 'lose'], undefined],\n  [['helpg', 'rep'], undefined],\n  [['helpt', 'ags'], undefined],\n  [['hi', 'ghlight'], undefined],\n  [['hid', 'e'], undefined],\n  [['his', 'tory'], HistoryCommand.argParser],\n  [['i', 'nsert'], undefined],\n  [['ia', 'bbrev'], undefined],\n  [['iabc', 'lear'], undefined],\n  [['if', ''], undefined],\n  [['ij', 'ump'], undefined],\n  [['il', 'ist'], undefined],\n  [['im', 'ap'], undefined],\n  [['imapc', 'lear'], undefined],\n  [['ime', 'nu'], undefined],\n  [['ino', 'remap'], undefined],\n  [['inorea', 'bbrev'], undefined],\n  [['inoreme', 'nu'], undefined],\n  [['int', 'ro'], undefined],\n  [['is', 'earch'], undefined],\n  [['isp', 'lit'], undefined],\n  [['iu', 'nmap'], undefined],\n  [['iuna', 'bbrev'], undefined],\n  [['iunme', 'nu'], undefined],\n  [['j', 'oin'], undefined],\n  [['ju', 'mps'], succeed(new JumpsCommand())],\n  [['k', ''], undefined],\n  [['kee', 'pmarks'], undefined],\n  [['keepa', 'lt'], undefined],\n  [['keepj', 'umps'], undefined],\n  [['keepp', 'atterns'], undefined],\n  [['l', 'ist'], PrintCommand.argParser({ printNumbers: false, printText: true })],\n  [['lN', 'ext'], undefined],\n  [['lNf', 'ile'], undefined],\n  [['la', 'st'], undefined],\n  [['lab', 'ove'], undefined],\n  [['lad', 'dexpr'], undefined],\n  [['laddb', 'uffer'], undefined],\n  [['laddf', 'ile'], undefined],\n  [['laf', 'ter'], undefined],\n  [['lan', 'guage'], undefined],\n  [['lat', 'er'], undefined],\n  [['lb', 'uffer'], undefined],\n  [['lbef', 'ore'], undefined],\n  [['lbel', 'ow'], undefined],\n  [['lbo', 'ttom'], undefined],\n  [['lc', 'd'], undefined],\n  [['lch', 'dir'], undefined],\n  [['lcl', 'ose'], undefined],\n  [['lcs', 'cope'], undefined],\n  [['ld', 'o'], undefined],\n  [['le', 'ft'], LeftCommand.argParser],\n  [['lefta', 'bove'], undefined],\n  [['let', ''], undefined],\n  [['lex', 'pr'], undefined],\n  [['lf', 'ile'], undefined],\n  [['lfd', 'o'], undefined],\n  [['lfir', 'st'], undefined],\n  [['lg', 'etfile'], undefined],\n  [['lgetb', 'uffer'], undefined],\n  [['lgete', 'xpr'], undefined],\n  [['lgr', 'ep'], undefined],\n  [['lgrepa', 'dd'], undefined],\n  [['lh', 'elpgrep'], undefined],\n  [['lhi', 'story'], undefined],\n  [['ll', ''], undefined],\n  [['lla', 'st'], undefined],\n  [['lli', 'st'], undefined],\n  [['lm', 'ap'], undefined],\n  [['lmak', 'e'], undefined],\n  [['lmapc', 'lear'], undefined],\n  [['ln', 'oremap'], undefined],\n  [['lne', 'xt'], undefined],\n  [['lnew', 'er'], undefined],\n  [['lnf', 'ile'], undefined],\n  [['lo', 'adview'], undefined],\n  [['loadk', 'eymap'], undefined],\n  [['loc', 'kmarks'], undefined],\n  [['lockv', 'ar'], undefined],\n  [['lol', 'der'], undefined],\n  [['lope', 'n'], undefined],\n  [['lp', 'revious'], undefined],\n  [['lpf', 'ile'], undefined],\n  [['lr', 'ewind'], undefined],\n  [['ls', ''], undefined],\n  [['lt', 'ag'], undefined],\n  [['lu', 'nmap'], undefined],\n  [['lua', ''], undefined],\n  [['luad', 'o'], undefined],\n  [['luaf', 'ile'], undefined],\n  [['lv', 'imgrep'], undefined],\n  [['lvimgrepa', 'dd'], undefined],\n  [['lw', 'indow'], undefined],\n  [['m', 'ove'], undefined],\n  [['ma', 'rk'], undefined],\n  [['mak', 'e'], undefined],\n  [['map', ''], undefined],\n  [['mapc', 'lear'], undefined],\n  [['marks', ''], MarksCommand.argParser],\n  [['mat', 'ch'], undefined],\n  [['me', 'nu'], undefined],\n  [['menut', 'ranslate'], undefined],\n  [['mes', 'sages'], undefined],\n  [['mk', 'exrc'], undefined],\n  [['mks', 'ession'], undefined],\n  [['mksp', 'ell'], undefined],\n  [['mkv', 'imrc'], undefined],\n  [['mkvie', 'w'], undefined],\n  [['mod', 'e'], undefined],\n  [['n', 'ext'], undefined],\n  [['new', ''], FileCommand.argParsers.new],\n  [['nm', 'ap'], undefined],\n  [['nmapc', 'lear'], undefined],\n  [['nme', 'nu'], undefined],\n  [['nn', 'oremap'], undefined],\n  [['nnoreme', 'nu'], undefined],\n  [['no', 'remap'], undefined],\n  [['noa', 'utocmd'], undefined],\n  [['noh', 'lsearch'], succeed(new NohlCommand())],\n  [['norea', 'bbrev'], undefined],\n  [['noreme', 'nu'], undefined],\n  [['norm', 'al'], undefined],\n  [['nos', 'wapfile'], undefined],\n  [['nu', 'mber'], PrintCommand.argParser({ printNumbers: true, printText: true })],\n  [['nun', 'map'], undefined],\n  [['nunme', 'nu'], undefined],\n  [['ol', 'dfiles'], undefined],\n  [['om', 'ap'], undefined],\n  [['omapc', 'lear'], undefined],\n  [['ome', 'nu'], undefined],\n  [['on', 'ly'], succeed(new OnlyCommand())],\n  [['ono', 'remap'], undefined],\n  [['onoreme', 'nu'], undefined],\n  [['opt', 'ions'], undefined],\n  [['ou', 'nmap'], undefined],\n  [['ounme', 'nu'], undefined],\n  [['ow', 'nsyntax'], undefined],\n  [['p', 'rint'], PrintCommand.argParser({ printNumbers: false, printText: true })],\n  [['pa', 'ckadd'], undefined],\n  [['packl', 'oadall'], undefined],\n  [['pc', 'lose'], undefined],\n  [['pe', 'rl'], undefined],\n  [['ped', 'it'], undefined],\n  [['perld', 'o'], undefined],\n  [['perlf', 'ile'], undefined],\n  [['po', 'p'], undefined],\n  [['popu', 'p'], undefined],\n  [['pp', 'op'], undefined],\n  [['pre', 'serve'], undefined],\n  [['prev', 'ious'], undefined],\n  [['prof', 'ile'], undefined],\n  [['profd', 'el'], undefined],\n  [['ps', 'earch'], undefined],\n  [['pt', 'ag'], undefined],\n  [['ptN', 'ext'], undefined],\n  [['ptf', 'irst'], undefined],\n  [['ptj', 'ump'], undefined],\n  [['ptl', 'ast'], undefined],\n  [['ptn', 'ext'], undefined],\n  [['ptp', 'revious'], undefined],\n  [['ptr', 'ewind'], undefined],\n  [['pts', 'elect'], undefined],\n  [['pu', 't'], PutExCommand.argParser],\n  [['pw', 'd'], undefined],\n  [['py', 'thon'], undefined],\n  [['py3', ''], undefined],\n  [['py3d', 'o'], undefined],\n  [['py3f', 'ile'], undefined],\n  [['pyd', 'o'], undefined],\n  [['pyf', 'ile'], undefined],\n  [['python3', ''], undefined],\n  [['pythonx', ''], undefined],\n  [['pyx', ''], undefined],\n  [['pyxd', 'o'], undefined],\n  [['pyxf', 'ile'], undefined],\n  [['q', 'uit'], QuitCommand.argParser(false)],\n  [['qa', 'll'], QuitCommand.argParser(true)],\n  [['quita', 'll'], QuitCommand.argParser(true)],\n  [['r', 'ead'], ReadCommand.argParser],\n  [['rec', 'over'], undefined],\n  [['red', 'o'], undefined],\n  [['redi', 'r'], undefined],\n  [['redr', 'aw'], undefined],\n  [['redraws', 'tatus'], undefined],\n  [['redrawt', 'abline'], undefined],\n  [['reg', 'isters'], RegisterCommand.argParser],\n  [['res', 'ize'], undefined],\n  [['ret', 'ab'], RetabCommand.argParser],\n  [['retu', 'rn'], undefined],\n  [['rew', 'ind'], undefined],\n  [['ri', 'ght'], RightCommand.argParser],\n  [['rightb', 'elow'], undefined],\n  [['rsh', 'ada'], undefined],\n  [['ru', 'ntime'], undefined],\n  [['rub', 'y'], undefined],\n  [['rubyd', 'o'], undefined],\n  [['rubyf', 'ile'], undefined],\n  [['rund', 'o'], undefined],\n  [['s', 'ubstitute'], SubstituteCommand.argParser],\n  [['sN', 'ext'], undefined],\n  [['sa', 'rgument'], undefined],\n  [['sal', 'l'], undefined],\n  [['san', 'dbox'], undefined],\n  [['sav', 'eas'], undefined],\n  [['sb', 'uffer'], undefined],\n  [['sbN', 'ext'], undefined],\n  [['sba', 'll'], undefined],\n  [['sbf', 'irst'], undefined],\n  [['sbl', 'ast'], undefined],\n  [['sbm', 'odified'], undefined],\n  [['sbn', 'ext'], undefined],\n  [['sbp', 'revious'], undefined],\n  [['sbr', 'ewind'], undefined],\n  [['scr', 'iptnames'], undefined],\n  [['scripte', 'ncoding'], undefined],\n  [['scs', 'cope'], undefined],\n  [['se', 't'], SetCommand.argParser],\n  [['setf', 'iletype'], undefined],\n  [['setg', 'lobal'], undefined],\n  [['setl', 'ocal'], undefined],\n  [['sf', 'ind'], undefined],\n  [['sfir', 'st'], undefined],\n  [['sh', 'ell'], succeed(new ShCommand())], // Taken from Vim; not in nvim\n  [['sig', 'n'], undefined],\n  [['sil', 'ent'], undefined],\n  [['sl', 'eep'], undefined],\n  [['sla', 'st'], undefined],\n  [['sm', 'agic'], undefined],\n  [['smap', ''], undefined],\n  [['smapc', 'lear'], undefined],\n  [['sme', 'nu'], undefined],\n  [['smile', ''], succeed(new SmileCommand())], // Taken from Vim; not in nvim\n  [['sn', 'ext'], undefined],\n  [['sno', 'magic'], undefined],\n  [['snor', 'emap'], undefined],\n  [['snoreme', 'nu'], undefined],\n  [['so', 'urce'], undefined],\n  [['sor', 't'], SortCommand.argParser],\n  [['sp', 'lit'], FileCommand.argParsers.split],\n  [['spe', 'llgood'], undefined],\n  [['spelld', 'ump'], undefined],\n  [['spelli', 'nfo'], undefined],\n  [['spellr', 'epall'], undefined],\n  [['spellra', 're'], undefined],\n  [['spellu', 'ndo'], undefined],\n  [['spellw', 'rong'], undefined],\n  [['spr', 'evious'], undefined],\n  [['sre', 'wind'], undefined],\n  [['st', 'op'], undefined],\n  [['sta', 'g'], undefined],\n  [['star', 'tinsert'], undefined],\n  [['startg', 'replace'], undefined],\n  [['startr', 'eplace'], undefined],\n  [['stj', 'ump'], undefined],\n  [['stopi', 'nsert'], undefined],\n  [['sts', 'elect'], undefined],\n  [['sun', 'hide'], undefined],\n  [['sunm', 'ap'], undefined],\n  [['sunme', 'nu'], undefined],\n  [['sus', 'pend'], undefined],\n  [['sv', 'iew'], undefined],\n  [['sw', 'apname'], undefined],\n  [['sy', 'ntax'], undefined],\n  [['sync', 'bind'], undefined],\n  [['synti', 'me'], undefined],\n  [['t', ''], CopyCommand.argParser],\n  [['tN', 'ext'], undefined],\n  [['ta', 'g'], undefined],\n  [['tab', ''], undefined],\n  [['tabN', 'ext'], TabCommand.argParsers.bprev],\n  [['tabc', 'lose'], TabCommand.argParsers.tabclose],\n  [['tabdo', ''], undefined],\n  [['tabe', 'dit'], TabCommand.argParsers.tabnew],\n  [['tabf', 'ind'], undefined],\n  [['tabfir', 'st'], TabCommand.argParsers.bfirst],\n  [['tabl', 'ast'], TabCommand.argParsers.blast],\n  [['tabm', 'ove'], TabCommand.argParsers.tabmove],\n  [['tabn', 'ext'], TabCommand.argParsers.bnext],\n  [['tabnew', ''], TabCommand.argParsers.tabnew],\n  [['tabo', 'nly'], TabCommand.argParsers.tabonly],\n  [['tabp', 'revious'], TabCommand.argParsers.bprev],\n  [['tabr', 'ewind'], TabCommand.argParsers.bfirst],\n  [['tabs', ''], undefined],\n  [['tags', ''], undefined],\n  [['tc', 'd'], undefined],\n  [['tch', 'dir'], undefined],\n  [['te', 'rminal'], TerminalCommand.argParser],\n  [['tf', 'irst'], undefined],\n  [['th', 'row'], undefined],\n  [['tj', 'ump'], undefined],\n  [['tl', 'ast'], undefined],\n  [['tm', 'enu'], undefined],\n  [['tma', 'p'], undefined],\n  [['tmapc', 'lear'], undefined],\n  [['tn', 'ext'], undefined],\n  [['tno', 'remap'], undefined],\n  [['to', 'pleft'], undefined],\n  [['tp', 'revious'], undefined],\n  [['tr', 'ewind'], undefined],\n  [['try', ''], undefined],\n  [['ts', 'elect'], undefined],\n  [['tu', 'nmenu'], undefined],\n  [['tunma', 'p'], undefined],\n  [['u', 'ndo'], UndoCommand.argParser],\n  [['una', 'bbreviate'], undefined],\n  [['undoj', 'oin'], undefined],\n  [['undol', 'ist'], undefined],\n  [['unh', 'ide'], undefined],\n  [['unl', 'et'], undefined],\n  [['unlo', 'ckvar'], undefined],\n  [['unm', 'ap'], undefined],\n  [['unme', 'nu'], undefined],\n  [['uns', 'ilent'], undefined],\n  [['up', 'date'], WriteCommand.argParser],\n  [['v', 'global'], undefined],\n  [['ve', 'rsion'], undefined],\n  [['verb', 'ose'], undefined],\n  [['vert', 'ical'], undefined],\n  [['vi', 'sual'], undefined],\n  [['vie', 'w'], undefined],\n  [['vim', 'grep'], undefined],\n  [['vimgrepa', 'dd'], undefined],\n  [['viu', 'sage'], undefined],\n  [['vm', 'ap'], undefined],\n  [['vmapc', 'lear'], undefined],\n  [['vme', 'nu'], undefined],\n  [['vn', 'oremap'], undefined],\n  [['vne', 'w'], FileCommand.argParsers.vnew],\n  [['vnoreme', 'nu'], undefined],\n  [['vs', 'plit'], FileCommand.argParsers.vsplit],\n  [['vsc', 'ode'], VsCodeCommand.argParser], // Special: run VS Code command\n  [['vu', 'nmap'], undefined],\n  [['vunme', 'nu'], undefined],\n  [['w', 'rite'], WriteCommand.argParser],\n  [['wN', 'ext'], undefined],\n  [['wa', 'll'], WallCommand.argParser],\n  [['wh', 'ile'], undefined],\n  [['wi', 'nsize'], undefined],\n  [['winc', 'md'], undefined],\n  [['windo', ''], undefined],\n  [['winp', 'os'], undefined],\n  [['wn', 'ext'], undefined],\n  [['wp', 'revious'], undefined],\n  [['wq', ''], WriteQuitCommand.argParser],\n  [['wqa', 'll'], WriteQuitAllCommand.argParser],\n  [['wsh', 'ada'], undefined],\n  [['wu', 'ndo'], undefined],\n  [['x', 'it'], WriteQuitCommand.argParser],\n  [['xa', 'll'], WriteQuitAllCommand.argParser],\n  [['xm', 'ap'], undefined],\n  [['xmapc', 'lear'], undefined],\n  [['xme', 'nu'], undefined],\n  [['xn', 'oremap'], undefined],\n  [['xnoreme', 'nu'], undefined],\n  [['xu', 'nmap'], undefined],\n  [['xunme', 'nu'], undefined],\n  [['y', 'ank'], YankCommand.argParser],\n  [['z', ''], undefined],\n  [['~', ''], undefined],\n];\n\nclass UnimplementedCommand extends ExCommand {\n  name: string;\n\n  public override neovimCapable(): boolean {\n    // If the user has neovim integration enabled, don't stop them from using these commands\n    return true;\n  }\n\n  constructor(name: string) {\n    super();\n    this.name = name;\n  }\n\n  async execute(vimState: VimState): Promise<void> {\n    StatusBar.setText(\n      vimState,\n      `Command :${this.name} is not yet implemented (PRs are welcome!)`,\n      true\n    );\n  }\n\n  override async executeWithRange(vimState: VimState, range: LineRange): Promise<void> {\n    await this.execute(vimState);\n  }\n}\n\nexport class NoOpCommand extends ExCommand {\n  async execute(vimState: VimState): Promise<void> {\n    // nothing\n  }\n}\n\nfunction nameParser(\n  name: [string, string],\n  argParser: ArgParser | undefined\n): Parser<Parser<ExCommand>> {\n  argParser ??= all.result(new UnimplementedCommand(name[1] ? `${name[0]}[${name[1]}]` : name[0]));\n\n  const fullName = name[0] + name[1];\n  const p = nameAbbrevParser(name[0], name[1]).result(argParser);\n  return fullName === '' || /[a-z]$/i.test(fullName) ? p.notFollowedBy(regexp(/[a-z]/i)) : p;\n}\n\nexport const commandNameParser: Parser<Parser<ExCommand> | undefined> = alt(\n  ...[...builtinExCommands]\n    .reverse()\n    .map(([name, argParser]) => nameParser(name, argParser?.skip(optWhitespace)))\n);\n\nexport const exCommandParser: Parser<{ lineRange: LineRange | undefined; command: ExCommand }> =\n  optWhitespace\n    .then(string(':').skip(optWhitespace).many())\n    .then(\n      seq(\n        LineRange.parser.fallback(undefined),\n        optWhitespace,\n        commandNameParser.fallback(undefined),\n        all\n      )\n    )\n    .map(([lineRange, whitespace, parseArgs, args]) => {\n      if (parseArgs === undefined) {\n        throw VimError.fromCode(\n          ErrorCode.NotAnEditorCommand,\n          `${lineRange?.toString() ?? ''}${whitespace}${args}`\n        );\n      }\n      const result = seq(parseArgs, optWhitespace.then(all)).parse(args);\n      if (result.status === false || result.value[1]) {\n        // TODO: All possible parsing errors are lumped into \"trailing characters\", which is wrong\n        // TODO: Implement `:help :bar`\n        // TODO: Implement `:help :comment`\n        throw VimError.fromCode(ErrorCode.TrailingCharacters);\n      }\n      return { lineRange, command: result.value[0] };\n    });\n","import { alt, any, Parser, regexp, string, noneOf } from \"parsimmon\";\nimport { configuration } from \"../configuration/configuration\";\n\nconst leaderParser = regexp(/<leader>/).map(() => configuration.leader);  // lazy evaluation of configuration.leader\nconst specialCharacters = regexp(/<(?:Esc|C-\\w|A-\\w|C-A-\\w)>/)\n\nconst specialCharacterParser = alt(specialCharacters, leaderParser);\n\n// TODO: Move to a more general location\n// TODO: Add more special characters\nconst escapedParser = string('\\\\')\n  .then(any.fallback(undefined))\n  .map((escaped) => {\n    if (escaped === undefined) {\n      return '\\\\\\\\';\n    } else if (escaped === 'n') {\n      return '\\n';\n    }\n    return '\\\\' + escaped;\n  })\n\nexport const keystrokesExpressionParser: Parser<string[]> = alt(\n  escapedParser,\n  specialCharacterParser,\n  noneOf('\"'),\n).many();\n","import { alt, any, optWhitespace, Parser, seq, string, succeed } from 'parsimmon';\nimport { Position, Range } from 'vscode';\nimport { ErrorCode, VimError } from '../error';\nimport { globalState } from '../state/globalState';\nimport { SearchState } from '../state/searchState';\nimport { VimState } from '../state/vimState';\nimport { numberParser } from './parserUtils';\nimport { Pattern, SearchDirection } from './pattern';\n\n/**\n * Specifies the start or end of a line range.\n * See :help {address}\n */\ntype LineSpecifier =\n  | {\n      // {number}\n      type: 'number';\n      num: number;\n    }\n  | {\n      // .\n      type: 'current_line';\n    }\n  | {\n      // $\n      type: 'last_line';\n    }\n  | {\n      // %\n      type: 'entire_file';\n    }\n  | {\n      // *\n      type: 'last_visual_range';\n    }\n  | {\n      // 't\n      type: 'mark';\n      mark: string;\n    }\n  | {\n      // /{pattern}[/]\n      type: 'pattern_next';\n      pattern: Pattern;\n    }\n  | {\n      // ?{pattern}[?]\n      type: 'pattern_prev';\n      pattern: Pattern;\n    }\n  | {\n      // \\/\n      type: 'last_search_pattern_next';\n    }\n  | {\n      // \\?\n      type: 'last_search_pattern_prev';\n    }\n  | {\n      // \\&\n      type: 'last_substitute_pattern_next';\n    };\n\nconst lineSpecifierParser: Parser<LineSpecifier> = alt(\n  numberParser.map((num) => {\n    return { type: 'number', num };\n  }),\n  string('.').result({ type: 'current_line' }),\n  string('$').result({ type: 'last_line' }),\n  string('%').result({ type: 'entire_file' }),\n  string('*').result({ type: 'last_visual_range' }),\n  string(\"'\")\n    .then(any)\n    .map((mark) => {\n      return { type: 'mark', mark };\n    }),\n  string('/')\n    .then(Pattern.parser({ direction: SearchDirection.Forward }))\n    .map((pattern) => {\n      return {\n        type: 'pattern_next',\n        pattern,\n      };\n    }),\n  string('?')\n    .then(Pattern.parser({ direction: SearchDirection.Backward }))\n    .map((pattern) => {\n      return {\n        type: 'pattern_prev',\n        pattern,\n      };\n    }),\n  string('\\\\/').result({ type: 'last_search_pattern_next' }),\n  string('\\\\?').result({ type: 'last_search_pattern_prev' }),\n  string('\\\\&').result({ type: 'last_substitute_pattern_next' })\n);\n\nconst offsetParser: Parser<number> = alt(\n  string('+').then(numberParser.fallback(1)),\n  string('-')\n    .then(numberParser.fallback(1))\n    .map((num) => -num),\n  numberParser\n)\n  .skip(optWhitespace)\n  .atLeast(1)\n  .map((nums) => nums.reduce((x, y) => x + y, 0));\n\nexport class Address {\n  public readonly specifier: LineSpecifier;\n  public readonly offset: number;\n\n  constructor(specifier: LineSpecifier, offset?: number) {\n    this.specifier = specifier;\n    this.offset = offset ?? 0;\n  }\n\n  public static parser: Parser<Address> = alt(\n    seq(lineSpecifierParser.skip(optWhitespace), offsetParser.fallback(0)),\n    seq(succeed({ type: 'current_line' as const }), offsetParser)\n  ).map(([specifier, offset]) => {\n    return new Address(specifier, offset);\n  });\n\n  public resolve(vimState: VimState, side: 'left' | 'right', boundsCheck = true): number {\n    const line = (() => {\n      switch (this.specifier.type) {\n        case 'number':\n          if (boundsCheck) {\n            return this.specifier.num ? this.specifier.num - 1 : 0;\n          } else {\n            return this.specifier.num - 1;\n          }\n        case 'current_line':\n          return vimState.cursorStopPosition.line;\n        case 'last_line':\n          return vimState.document.lineCount - 1;\n        case 'entire_file':\n          return vimState.document.lineCount - 1;\n        case 'last_visual_range':\n          const res =\n            side === 'left'\n              ? vimState.lastVisualSelection?.start.line\n              : vimState.lastVisualSelection?.end.line;\n          if (res === undefined) {\n            throw VimError.fromCode(ErrorCode.MarkNotSet);\n          }\n          return res;\n        case 'mark':\n          const mark = vimState.historyTracker.getMark(this.specifier.mark);\n          if (!mark || (mark.document && mark.document !== vimState.document)) {\n            throw VimError.fromCode(ErrorCode.MarkNotSet);\n          }\n          return mark.position.line;\n        case 'pattern_next':\n          const m = this.specifier.pattern.nextMatch(\n            vimState.document,\n            vimState.cursorStopPosition\n          );\n          if (m === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(\n              ErrorCode.PatternNotFound,\n              this.specifier.pattern.patternString\n            );\n          } else {\n            return m.start.line;\n          }\n        case 'pattern_prev':\n          throw new Error('Using a backward pattern in a line range is not yet supported'); // TODO\n        case 'last_search_pattern_next':\n          if (!globalState.searchState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n          }\n          const nextMatch = globalState.searchState.getNextSearchMatchPosition(\n            vimState,\n            vimState.cursorStopPosition,\n            SearchDirection.Forward\n          );\n          if (nextMatch === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(\n              ErrorCode.PatternNotFound,\n              globalState.searchState.searchString\n            );\n          }\n          return nextMatch.pos.line;\n        case 'last_search_pattern_prev':\n          if (!globalState.searchState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousRegularExpression);\n          }\n          const prevMatch = globalState.searchState.getNextSearchMatchPosition(\n            vimState,\n            vimState.cursorStopPosition,\n            SearchDirection.Backward\n          );\n          if (prevMatch === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(\n              ErrorCode.PatternNotFound,\n              globalState.searchState.searchString\n            );\n          }\n          return prevMatch.pos.line;\n        case 'last_substitute_pattern_next':\n          if (!globalState.substituteState) {\n            throw VimError.fromCode(ErrorCode.NoPreviousSubstituteRegularExpression);\n          }\n          const searchState = globalState.substituteState.searchPattern\n            ? new SearchState(\n                SearchDirection.Forward,\n                vimState.cursorStopPosition,\n                globalState.substituteState.searchPattern.patternString,\n                {}\n              )\n            : undefined;\n          const match = searchState?.getNextSearchMatchPosition(\n            vimState,\n            vimState.cursorStopPosition\n          );\n          if (match === undefined) {\n            // TODO: throw proper errors for nowrapscan\n            throw VimError.fromCode(ErrorCode.PatternNotFound, searchState?.searchString);\n          }\n          return match.pos.line;\n        default:\n          const guard: never = this.specifier;\n          throw new Error('Got unexpected LineSpecifier.type');\n      }\n    })();\n    const result = line + this.offset;\n    if (boundsCheck && (result < 0 || result > vimState.document.lineCount)) {\n      throw VimError.fromCode(ErrorCode.InvalidRange);\n    }\n    return result;\n  }\n\n  public toString(): string {\n    switch (this.specifier.type) {\n      case 'number':\n        return this.specifier.num.toString();\n      case 'current_line':\n        return '.';\n      case 'last_line':\n        return '$';\n      case 'entire_file':\n        return '%';\n      case 'last_visual_range':\n        return '*';\n      case 'mark':\n        return `'${this.specifier.mark}`;\n      case 'pattern_next':\n        return `/${this.specifier.pattern}/`;\n      case 'pattern_prev':\n        return `?${this.specifier.pattern}?`;\n      case 'last_search_pattern_next':\n        return '\\\\/';\n      case 'last_search_pattern_prev':\n        return '\\\\?';\n      case 'last_substitute_pattern_next':\n        return '\\\\&';\n      default:\n        const guard: never = this.specifier;\n        throw new Error('Got unexpected LineSpecifier.type');\n    }\n  }\n}\n\nexport class LineRange {\n  private readonly start: Address;\n  private readonly end?: Address;\n  public readonly separator?: ',' | ';';\n\n  constructor(start: Address, separator?: ',' | ';', end?: Address) {\n    this.start = start;\n    this.end = end;\n    this.separator = separator;\n  }\n\n  public static parser: Parser<LineRange> = seq(\n    Address.parser.skip(optWhitespace),\n    seq(\n      alt(string(','), string(';')).skip(optWhitespace),\n      Address.parser.fallback(undefined)\n    ).fallback(undefined)\n  ).map(([start, sepEnd]) => {\n    if (sepEnd) {\n      const [sep, end] = sepEnd;\n      return new LineRange(start, sep, end);\n    }\n    return new LineRange(start);\n  });\n\n  public resolve(vimState: VimState): { start: number; end: number } {\n    // TODO: *,4 is not a valid range\n    const end = this.end ?? this.start;\n\n    if (end.specifier.type === 'entire_file') {\n      return { start: 0, end: vimState.document.lineCount - 1 };\n    } else if (end.specifier.type === 'last_visual_range') {\n      if (vimState.lastVisualSelection === undefined) {\n        throw VimError.fromCode(ErrorCode.MarkNotSet);\n      }\n      return {\n        start: vimState.lastVisualSelection.start.line,\n        end: vimState.lastVisualSelection.end.line,\n      };\n    }\n\n    const left = this.start.resolve(vimState, 'left');\n    if (this.separator === ';') {\n      vimState.cursorStartPosition = vimState.cursorStopPosition = new Position(left, 0);\n    }\n    const right = end.resolve(vimState, 'right');\n    if (left > right) {\n      // Reverse the range to keep start < end\n      // NOTE: Vim generally makes you confirm before doing this, but we do it automatically.\n      return {\n        start: end.resolve(vimState, 'left'),\n        end: this.start.resolve(vimState, 'right'),\n      };\n    } else {\n      return {\n        start: left,\n        end: end.resolve(vimState, 'right'),\n      };\n    }\n  }\n\n  public resolveToRange(vimState: VimState): Range {\n    const { start, end } = this.resolve(vimState);\n    return new Range(new Position(start, 0), new Position(end, 0).getLineEnd());\n  }\n\n  public toString(): string {\n    return `${this.start.toString()}${this.separator ?? ''}${this.end?.toString() ?? ''}`;\n  }\n}\n","import { alt, any, Parser, regexp, seq, string, succeed, whitespace } from 'parsimmon';\n\nexport const numberParser: Parser<number> = regexp(/\\d+/).map((num) => Number.parseInt(num, 10));\n\nexport const bangParser: Parser<boolean> = string('!')\n  .fallback(undefined)\n  .map((bang) => bang !== undefined);\n\nexport function nameAbbrevParser(abbrev: string, rest: string): Parser<string> {\n  const suffixes = [...Array(rest.length + 1).keys()]\n    .reverse()\n    .map((idx) => rest.substring(0, idx));\n  return string(abbrev)\n    .then(alt(...suffixes.map(string)))\n    .map((suffix) => abbrev + suffix);\n}\n\n// TODO: `:help cmdline-special`\n// TODO: `:help filename-modifiers`\nexport const fileNameParser: Parser<string> = alt<string>(\n  string('\\\\').then(\n    any.fallback(undefined).map((escaped) => {\n      if (escaped === undefined || escaped === '\\\\') {\n        return '\\\\';\n      } else if (escaped === ' ') {\n        return ' ';\n      } else {\n        // TODO: anything else that needs escaping?\n        return `\\\\${escaped}`;\n      }\n    })\n  ),\n  regexp(/\\S/)\n)\n  .atLeast(1)\n  .map((chars) => chars.join(''));\n\n/**\n * Options for how a file should be encoded\n * See `:help ++opt`\n */\nexport type FileOpt = Array<[string, string | undefined]>;\nexport const fileOptParser: Parser<FileOpt> = string('++')\n  .then(\n    seq(\n      alt(\n        alt(string('ff'), string('fileformat')).result('ff'),\n        alt(string('enc'), string('encoding')).result('enc'),\n        alt(string('bin'), string('binary')).result('bin'),\n        alt(string('nobin'), string('nobinary')).result('nobin'),\n        string('bad'),\n        string('edit')\n      ),\n      string('=').then(regexp(/\\S+/)).fallback(undefined)\n    )\n  )\n  .sepBy(whitespace)\n  .desc('[++opt]');\n\n/**\n * A Command which will be run after opening a file\n * See `:help +cmd`\n */\nexport type FileCmd =\n  | {\n      type: 'line_number';\n      line: number;\n    }\n  | {\n      type: 'last_line';\n    };\nexport const fileCmdParser: Parser<FileCmd | undefined> = string('+')\n  .then(\n    alt<FileCmd>(\n      // Exact line number\n      numberParser.map((line) => ({ type: 'line_number', line })),\n      // TODO: Next match of pattern\n      // string('/').then(Pattern.parser({ direction: SearchDirection.Forward })),\n      // TODO: Ex command\n      // lazy(() => exCommandParser),\n      // Last line\n      succeed({ type: 'last_line' })\n    )\n  )\n  .fallback(undefined)\n  .desc('[+cmd]');\n","import { alt, any, lazy, noneOf, oneOf, Parser, seq, string, seqMap, eof } from 'parsimmon';\nimport { Position, Range, TextDocument } from 'vscode';\nimport { configuration } from '../configuration/configuration';\nimport { VimState } from '../state/vimState';\nimport { TextEditor } from '../textEditor';\nimport { LineRange } from './lineRange';\nimport { numberParser } from './parserUtils';\n\nexport function searchStringParser(args: {\n  direction: SearchDirection;\n  ignoreSmartcase?: boolean;\n}): Parser<{\n  pattern: Pattern;\n  offset: SearchOffset | undefined;\n}> {\n  return seq(\n    Pattern.parser(args),\n    lazy(() => SearchOffset.parser.fallback(undefined))\n  ).map(([pattern, offset]) => {\n    return { pattern, offset };\n  });\n}\n\nexport enum SearchDirection {\n  Forward = 1,\n  Backward = -1,\n}\n\nexport type PatternMatch = { range: Range; groups: string[] };\n\n/**\n * See `:help pattern`\n *\n * TODO(#3996): Currently, this is a thin wrapper around JavaScript's regex engine.\n *              We should either re-implement Vim's regex engine from scratch or (more likely)\n *              implement a best-effort translation from Vim's syntax to JavaScript's.\n */\nexport class Pattern {\n  public readonly patternString: string;\n  public readonly direction: SearchDirection;\n  public readonly regex: RegExp;\n  public readonly ignorecase: boolean | undefined;\n  public readonly inSelection: boolean;\n  public readonly closed: boolean; // was an ending delimiter present?\n\n  /** `true` if this pattern has an empty branch (/foo|/, for instance) */\n  private readonly emptyBranch: boolean;\n\n  private static readonly MAX_SEARCH_TIME = 1000;\n  private static readonly SPECIAL_CHARS_REGEX = /[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g;\n\n  public nextMatch(document: TextDocument, fromPosition: Position): Range | undefined {\n    if (this.emptyBranch) {\n      const pos = fromPosition.getRightThroughLineBreaks();\n      return new Range(pos, pos);\n    }\n    const haystack = document.getText();\n    this.regex.lastIndex = document.offsetAt(fromPosition) + 1;\n    const match = this.regex.exec(haystack);\n    return match\n      ? new Range(document.positionAt(match.index), document.positionAt(match.index + match.length))\n      : undefined;\n  }\n\n  /**\n   * Every range in the document that matches the search string.\n   *\n   * This might not be 100% complete - @see Pattern::MAX_SEARCH_RANGES\n   */\n  public allMatches(\n    vimState: VimState,\n    args:\n      | {\n          fromPosition: Position;\n        }\n      | {\n          lineRange: LineRange;\n        }\n  ): PatternMatch[] {\n    if (this.emptyBranch) {\n      // HACK: This pattern matches each character, but for purposes of perf when highlighting, merge them.\n      return [\n        {\n          range: new Range(new Position(0, 0), TextEditor.getDocumentEnd(vimState.document)),\n          groups: [],\n        },\n      ];\n    }\n\n    let fromPosition: Position;\n    let lineRange:\n      | {\n          start: number;\n          end: number;\n        }\n      | undefined;\n    if ('lineRange' in args) {\n      // TODO: We should be able to get away with only getting part of the document text in this case\n      lineRange = args.lineRange.resolve(vimState);\n      fromPosition = new Position(lineRange.start, 0);\n    } else {\n      fromPosition = args.fromPosition;\n    }\n\n    let haystack: string;\n    let searchOffset: number;\n    let startOffset: number;\n    if (this.inSelection && vimState.lastVisualSelection) {\n      // TODO: This is not exactly how Vim implements in-selection search (\\%V), see :help \\%V for more info.\n      const searchRange = new Range(\n        vimState.lastVisualSelection.start,\n        vimState.lastVisualSelection.end\n      );\n      haystack = vimState.document.getText(searchRange);\n      searchOffset = vimState.document.offsetAt(vimState.lastVisualSelection.start);\n      startOffset = searchRange.contains(fromPosition)\n        ? vimState.document.offsetAt(fromPosition) - searchOffset\n        : 0;\n    } else {\n      haystack = vimState.document.getText();\n      searchOffset = 0;\n      startOffset = vimState.document.offsetAt(fromPosition) - searchOffset;\n    }\n\n    this.regex.lastIndex = startOffset;\n\n    const start = Date.now();\n\n    const matchRanges = {\n      beforeWrapping: [] as PatternMatch[],\n      afterWrapping: [] as PatternMatch[],\n    };\n    let wrappedOver = false;\n    while (true) {\n      const match = this.regex.exec(haystack);\n\n      if (match) {\n        if (wrappedOver && match.index >= startOffset) {\n          // We've found our first match again\n          break;\n        }\n\n        const matchRange = new Range(\n          vimState.document.positionAt(searchOffset + match.index),\n          vimState.document.positionAt(searchOffset + match.index + match[0].length)\n        );\n        if (\n          !this.inSelection &&\n          lineRange &&\n          (matchRange.start.line < lineRange.start || matchRange.end.line > lineRange.end)\n        ) {\n          break;\n        }\n\n        (wrappedOver ? matchRanges.afterWrapping : matchRanges.beforeWrapping).push({\n          range: matchRange,\n          groups: match,\n        });\n\n        if (Date.now() - start > Pattern.MAX_SEARCH_TIME) {\n          break;\n        }\n\n        // When we find a zero-length match, nudge the search position forward to avoid getting stuck\n        if (matchRange.start.isEqual(matchRange.end)) {\n          this.regex.lastIndex++;\n        }\n      } else if (!wrappedOver) {\n        // We need to wrap around to the back if we reach the end.\n        this.regex.lastIndex = 0;\n        wrappedOver = true;\n      } else {\n        break;\n      }\n    }\n\n    return matchRanges.afterWrapping.concat(matchRanges.beforeWrapping);\n  }\n\n  private static compileRegex(regexString: string, ignoreCase?: boolean): RegExp {\n    const flags = ignoreCase ?? configuration.ignorecase ? 'gim' : 'gm';\n    try {\n      return new RegExp(regexString, flags);\n    } catch (err) {\n      // Couldn't compile the regexp, try again with special characters escaped\n      return new RegExp(regexString.replace(Pattern.SPECIAL_CHARS_REGEX, '\\\\$&'), flags);\n    }\n  }\n\n  public static parser(args: {\n    direction: SearchDirection;\n    ignoreSmartcase?: boolean;\n    delimiter?: string;\n  }): Parser<Pattern> {\n    const delimiter = args.delimiter\n      ? args.delimiter\n      : args.direction === SearchDirection.Forward\n      ? '/'\n      : '?';\n    // TODO: Some escaped characters need special treatment\n    return seqMap(\n      string('|').result(true).fallback(false), // Leading | matches everything\n      alt(\n        string('\\\\%V').map((_) => ({ inSelection: true })),\n        string('$').map(() => '(?:$(?<!\\\\r))'), // prevents matching \\r\\n as two lines\n        string('^').map(() => '(?:^(?<!\\\\r))'), // prevents matching \\r\\n as two lines\n        string('|')\n          .then(eof)\n          .map(() => ({ emptyBranch: true })), // Trailing | matches everything\n        string('\\\\')\n          .then(any.fallback(undefined))\n          .map((escaped) => {\n            if (escaped === undefined) {\n              return '\\\\\\\\';\n            } else if (escaped === delimiter) {\n              return delimiter;\n            } else if (escaped === 'c') {\n              return { ignorecase: true };\n            } else if (escaped === 'C') {\n              return { ignorecase: false };\n            } else if (escaped === '<' || escaped === '>') {\n              // TODO: not QUITE the same\n              return '\\\\b';\n            } else if (escaped === 'n') {\n              return '\\\\r?\\\\n';\n            }\n            return '\\\\' + escaped;\n          }),\n        alt(\n          // Allow unescaped delimiter inside [], and don't transform ^ or $\n          string('\\\\')\n            .then(any.fallback(undefined))\n            .map((escaped) => '\\\\' + (escaped ?? '\\\\')),\n          noneOf(']')\n        )\n          .many()\n          .wrap(string('['), string(']'))\n          .map((result) => '[' + result.join('') + ']'),\n        noneOf(delimiter)\n      ).many(),\n      string(delimiter).fallback(undefined),\n      (leadingBar, atoms, delim) => {\n        let patternString = leadingBar ? '|' : '';\n        let caseOverride: boolean | undefined;\n        let inSelection: boolean | undefined;\n        let emptyBranch: boolean = leadingBar;\n        for (const atom of atoms) {\n          if (typeof atom === 'string') {\n            patternString += atom;\n          } else {\n            if (atom.emptyBranch) {\n              emptyBranch = true;\n              patternString += '|';\n            } else if (atom.ignorecase) {\n              caseOverride = true;\n            } else if (atom.inSelection) {\n              inSelection = atom.inSelection;\n            } else if (caseOverride === undefined) {\n              caseOverride = false;\n            }\n          }\n        }\n        return {\n          patternString,\n          caseOverride,\n          inSelection,\n          closed: delim !== undefined,\n          emptyBranch,\n        };\n      }\n    ).map(({ patternString, caseOverride, inSelection, closed, emptyBranch }) => {\n      const ignoreCase = Pattern.getIgnoreCase(patternString, {\n        caseOverride,\n        ignoreSmartcase: args.ignoreSmartcase ?? false,\n      });\n      return new Pattern(\n        patternString,\n        args.direction,\n        Pattern.compileRegex(patternString, ignoreCase),\n        inSelection ?? false,\n        closed,\n        emptyBranch\n      );\n    });\n  }\n\n  private static getIgnoreCase(\n    patternString: string,\n    flags: { caseOverride?: boolean; ignoreSmartcase: boolean }\n  ): boolean {\n    if (flags.caseOverride !== undefined) {\n      return flags.caseOverride;\n    } else if (configuration.smartcase && !flags.ignoreSmartcase && /[A-Z]/.test(patternString)) {\n      return false;\n    }\n    return configuration.ignorecase;\n  }\n\n  private constructor(\n    patternString: string,\n    direction: SearchDirection,\n    regex: RegExp,\n    inSelection: boolean,\n    closed: boolean,\n    emptyBranch: boolean\n  ) {\n    this.patternString = patternString;\n    this.direction = direction;\n    // TODO: Recalculate ignorecase if relevant config changes?\n    this.regex = regex;\n    this.inSelection = inSelection;\n    this.closed = closed;\n    this.emptyBranch = emptyBranch;\n  }\n}\n\ntype SearchOffsetData =\n  | {\n      type: 'lines' | 'chars_from_start' | 'chars_from_end';\n      delta: number;\n    }\n  | {\n      type: 'pattern';\n      direction: SearchDirection;\n      pattern: Pattern;\n      offset?: SearchOffset;\n    };\n\nconst searchOffsetTypeParser = oneOf('esb')\n  .fallback(undefined)\n  .map((esb) => {\n    if (esb === undefined) {\n      return 'lines';\n    } else {\n      return esb === 'e' ? 'chars_from_end' : 'chars_from_start';\n    }\n  });\n\n/**\n * See `:help search-offset`\n */\nexport class SearchOffset {\n  private readonly data: SearchOffsetData;\n\n  public static parser: Parser<SearchOffset> = alt(\n    seq(searchOffsetTypeParser, oneOf('+-').fallback('+'), numberParser).map(\n      ([type, sign, num]) =>\n        new SearchOffset({\n          type,\n          delta: sign === '-' ? -num : num,\n        })\n    ),\n    seq(searchOffsetTypeParser, oneOf('+-')).map(\n      ([type, sign]) =>\n        new SearchOffset({\n          type,\n          delta: sign === '-' ? -1 : 1,\n        })\n    ),\n    seq(searchOffsetTypeParser).map(([type]) => new SearchOffset({ type, delta: 0 })),\n    string(';/')\n      .then(searchStringParser({ direction: SearchDirection.Forward }))\n      .map(({ pattern, offset }) => {\n        return new SearchOffset({\n          type: 'pattern',\n          direction: SearchDirection.Forward,\n          pattern,\n          offset,\n        });\n      }),\n    string(';?')\n      .then(searchStringParser({ direction: SearchDirection.Backward }))\n      .map(({ pattern, offset }) => {\n        return new SearchOffset({\n          type: 'pattern',\n          direction: SearchDirection.Backward,\n          pattern,\n          offset,\n        });\n      })\n  );\n\n  public constructor(data: SearchOffsetData) {\n    this.data = data;\n  }\n\n  public apply(match: Range): Position {\n    switch (this.data.type) {\n      case 'lines':\n        return this.data.delta === 0\n          ? match.start\n          : new Position(match.end.line + this.data.delta, 0);\n      case 'chars_from_start':\n        return match.start.getOffsetThroughLineBreaks(this.data.delta);\n      case 'chars_from_end':\n        return match.end.getOffsetThroughLineBreaks(this.data.delta - 1);\n      case 'pattern': // TODO(#3919): Support `;` offset (`:help //;`)\n      default:\n        const guard: unknown = this.data;\n        throw new Error('Unexpected SearchOffset type');\n    }\n  }\n}\n","'use strict';\nconst os = require('os');\n\nconst homeDirectory = os.homedir();\n\nmodule.exports = pathWithTilde => {\n\tif (typeof pathWithTilde !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof pathWithTilde}`);\n\t}\n\n\treturn homeDirectory ? pathWithTilde.replace(/^~(?=$|\\/|\\\\)/, homeDirectory) : pathWithTilde;\n};\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","/**\n * Extension.ts is a lightweight wrapper around ModeHandler. It converts key\n * events to their string names and passes them on to ModeHandler via\n * handleKeyEvent().\n */\nimport './src/actions/include-main';\n\n/**\n * Load configuration validator\n */\n\nimport './src/configuration/validators/inputMethodSwitcherValidator';\nimport './src/configuration/validators/remappingValidator';\n\nimport * as vscode from 'vscode';\nimport { activate as activateFunc } from './extensionBase';\n\n// tslint:disable-next-line: no-var-requires\nrequire('setimmediate');\n\nexport async function activate(context: vscode.ExtensionContext) {\n  activateFunc(context, false);\n}\n"],"names":["root","factory","exports","module","define","amd","a","i","self","diff_match_patch","this","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","DIFF_DELETE","Diff","op","text","prototype","diff_main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","length","diffs","diff_compute_","unshift","push","diff_cleanupMerge","longtext","shorttext","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","splice","subDiff","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","x","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","y1","x1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","undefined","String","fromCharCode","maxLines","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","dmp","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastEquality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","char1","char2","nonAlphaNumeric1","match","nonAlphaNumericRegex_","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","replace","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","data","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","e","accuracy","proximity","abs","score_threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","toString","ReflectOwnKeys","R","Reflect","ReflectApply","apply","target","receiver","args","Function","call","ownKeys","Object","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","value","EventEmitter","init","once","emitter","name","Promise","resolve","reject","eventListener","errorListener","removeListener","slice","arguments","err","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","type","prepend","events","existing","warning","create","newListener","emit","warned","w","count","console","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","copy","defineProperty","enumerable","get","set","arg","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","error","er","message","context","handler","len","listeners","addListener","on","prependListener","prependOnceListener","list","position","originalListener","index","spliceOne","off","removeAllListeners","key","keys","rawListeners","eventNames","ctor","superCtor","super_","constructor","writable","configurable","TempCtor","FUNC_ERROR_TEXT","HASH_UNDEFINED","PLACEHOLDER","WRAP_PARTIAL_FLAG","WRAP_ARY_FLAG","INFINITY","MAX_SAFE_INTEGER","NAN","MAX_ARRAY_LENGTH","wrapFlags","argsTag","arrayTag","boolTag","dateTag","errorTag","funcTag","genTag","mapTag","numberTag","objectTag","promiseTag","regexpTag","setTag","stringTag","symbolTag","weakMapTag","arrayBufferTag","dataViewTag","float32Tag","float64Tag","int8Tag","int16Tag","int32Tag","uint8Tag","uint8ClampedTag","uint16Tag","uint32Tag","reEmptyStringLeading","reEmptyStringMiddle","reEmptyStringTrailing","reEscapedHtml","reUnescapedHtml","reHasEscapedHtml","RegExp","source","reHasUnescapedHtml","reEscape","reEvaluate","reInterpolate","reIsDeepProp","reIsPlainProp","rePropName","reRegExpChar","reHasRegExpChar","reTrimStart","reWhitespace","reWrapComment","reWrapDetails","reSplitDetails","reAsciiWord","reForbiddenIdentifierChars","reEscapeChar","reEsTemplate","reFlags","reIsBadHex","reIsBinary","reIsHostCtor","reIsOctal","reIsUint","reLatin","reNoMatch","reUnescapedString","rsComboRange","rsComboMarksRange","rsLowerRange","rsUpperRange","rsBreakRange","rsMathOpRange","rsBreak","rsCombo","rsDigits","rsLower","rsMisc","rsFitz","rsNonAstral","rsRegional","rsSurrPair","rsUpper","rsMiscLower","rsMiscUpper","rsOptContrLower","rsOptContrUpper","reOptMod","rsModifier","rsOptVar","rsSeq","rsEmoji","rsSymbol","reApos","reComboMark","reUnicode","reUnicodeWord","reHasUnicode","reHasUnicodeWord","contextProps","templateCounter","typedArrayTags","cloneableTags","stringEscapes","freeParseFloat","parseFloat","freeParseInt","freeGlobal","g","freeSelf","freeExports","nodeType","freeModule","moduleExports","freeProcess","process","nodeUtil","require","types","binding","nodeIsArrayBuffer","isArrayBuffer","nodeIsDate","isDate","nodeIsMap","isMap","nodeIsRegExp","isRegExp","nodeIsSet","isSet","nodeIsTypedArray","isTypedArray","func","thisArg","arrayAggregator","array","setter","iteratee","accumulator","arrayEach","arrayEachRight","arrayEvery","predicate","arrayFilter","resIndex","result","arrayIncludes","baseIndexOf","arrayIncludesWith","comparator","arrayMap","arrayPush","values","offset","arrayReduce","initAccum","arrayReduceRight","arraySome","asciiSize","baseProperty","baseFindKey","collection","eachFunc","baseFindIndex","fromIndex","fromRight","strictIndexOf","baseIsNaN","baseIndexOfWith","baseMean","baseSum","object","basePropertyOf","baseReduce","current","baseTimes","baseTrim","string","trimmedEndIndex","baseUnary","baseValues","props","cacheHas","cache","has","charsStartIndex","strSymbols","chrSymbols","charsEndIndex","countHolders","placeholder","deburrLetter","escapeHtmlChar","escapeStringChar","chr","hasUnicode","test","mapToArray","map","size","forEach","overArg","transform","replaceHolders","setToArray","setToPairs","stringSize","lastIndex","unicodeSize","stringToArray","unicodeToArray","asciiToArray","unescapeHtmlChar","_","runInContext","uid","defaults","pick","arrayProto","funcProto","objectProto","coreJsData","funcToString","idCounter","maskSrcKey","exec","IE_PROTO","nativeObjectToString","objectCtorString","oldDash","reIsNative","Buffer","Symbol","Uint8Array","allocUnsafe","getPrototype","objectCreate","propertyIsEnumerable","spreadableSymbol","isConcatSpreadable","symIterator","iterator","symToStringTag","toStringTag","getNative","ctxClearTimeout","clearTimeout","ctxNow","now","ctxSetTimeout","setTimeout","nativeCeil","nativeFloor","nativeGetSymbols","nativeIsBuffer","isBuffer","nativeIsFinite","isFinite","nativeJoin","nativeKeys","nativeMax","nativeMin","nativeNow","nativeParseInt","nativeRandom","random","nativeReverse","reverse","DataView","Map","Set","WeakMap","nativeCreate","metaMap","realNames","dataViewCtorString","toSource","mapCtorString","promiseCtorString","setCtorString","weakMapCtorString","symbolProto","symbolValueOf","valueOf","symbolToString","lodash","isObjectLike","isArray","LazyWrapper","LodashWrapper","wrapperClone","baseCreate","proto","isObject","baseLodash","chainAll","__wrapped__","__actions__","__chain__","__index__","__values__","__dir__","__filtered__","__iteratees__","__takeCount__","__views__","Hash","entries","clear","entry","ListCache","MapCache","SetCache","__data__","add","Stack","arrayLikeKeys","inherited","isArr","isArg","isArguments","isBuff","isType","skipIndexes","isIndex","arraySample","baseRandom","arraySampleSize","shuffleSelf","copyArray","baseClamp","arrayShuffle","assignMergeValue","eq","baseAssignValue","assignValue","objValue","assocIndexOf","baseAggregator","baseEach","baseAssign","copyObject","baseAt","paths","skip","number","lower","upper","baseClone","bitmask","customizer","stack","isDeep","isFlat","isFull","input","initCloneArray","tag","getTag","isFunc","cloneBuffer","initCloneObject","getSymbolsIn","copySymbolsIn","keysIn","baseAssignIn","getSymbols","copySymbols","symbol","Ctor","cloneArrayBuffer","dataView","buffer","byteOffset","byteLength","cloneDataView","cloneTypedArray","regexp","cloneRegExp","initCloneByTag","stacked","subValue","getAllKeysIn","getAllKeys","baseConformsTo","baseDelay","wait","baseDifference","includes","isCommon","valuesLength","outer","computed","valuesIndex","templateSettings","getMapData","pairs","LARGE_ARRAY_SIZE","createBaseEach","baseForOwn","baseEachRight","baseForOwnRight","baseEvery","baseExtremum","isSymbol","baseFilter","baseFlatten","depth","isStrict","isFlattenable","baseFor","createBaseFor","baseForRight","baseFunctions","isFunction","baseGet","path","castPath","toKey","baseGetAllKeys","keysFunc","symbolsFunc","baseGetTag","isOwn","unmasked","getRawTag","objectToString","baseGt","other","baseHas","baseHasIn","baseIntersection","arrays","othLength","othIndex","caches","maxLength","Infinity","seen","baseInvoke","parent","last","baseIsArguments","baseIsEqual","equalFunc","objIsArr","othIsArr","objTag","othTag","objIsObj","othIsObj","isSameTag","equalArrays","convert","isPartial","equalByTag","objIsWrapped","othIsWrapped","objUnwrapped","othUnwrapped","objProps","objLength","objStacked","othStacked","skipCtor","othValue","compared","objCtor","othCtor","equalObjects","baseIsEqualDeep","baseIsMatch","matchData","noCustomizer","srcValue","COMPARE_PARTIAL_FLAG","baseIsNative","baseIteratee","identity","baseMatchesProperty","baseMatches","property","baseKeys","isPrototype","baseLt","baseMap","isArrayLike","getMatchData","matchesStrictComparable","isKey","isStrictComparable","hasIn","baseMerge","srcIndex","mergeFunc","safeGet","newValue","isTyped","isArrayLikeObject","isPlainObject","toPlainObject","baseMergeDeep","baseNth","baseOrderBy","iteratees","orders","getIteratee","criteria","comparer","sort","objCriteria","othCriteria","ordersLength","compareAscending","compareMultiple","baseSortBy","basePickBy","baseSet","basePullAll","basePullAt","indexes","previous","baseUnset","baseRepeat","baseRest","setToString","overRest","baseSample","baseSampleSize","nested","baseSetData","baseSetToString","constant","baseShuffle","baseSlice","end","baseSome","baseSortedIndex","retHighest","low","high","mid","baseSortedIndexBy","valIsNaN","valIsNull","valIsSymbol","valIsUndefined","othIsDefined","othIsNull","othIsReflexive","othIsSymbol","setLow","baseSortedUniq","baseToNumber","baseToString","baseUniq","createSet","seenIndex","baseUpdate","updater","baseWhile","isDrop","baseWrapperValue","actions","action","baseXor","baseZipObject","assignFunc","valsLength","castArrayLikeObject","castFunction","stringToPath","castRest","castSlice","id","arrayBuffer","typedArray","valIsDefined","valIsReflexive","composeArgs","partials","holders","isCurried","argsIndex","argsLength","holdersLength","leftIndex","leftLength","rangeLength","isUncurried","composeArgsRight","holdersIndex","rightIndex","rightLength","isNew","createAggregator","initializer","createAssigner","assigner","sources","guard","isIterateeCall","iterable","createCaseFirst","methodName","trailing","createCompounder","callback","words","deburr","createCtor","thisBinding","createFind","findIndexFunc","createFlow","flatRest","funcs","prereq","thru","wrapper","getFuncName","funcName","getData","isLaziable","plant","createHybrid","partialsRight","holdersRight","argPos","ary","arity","isAry","isBind","isBindKey","isFlip","getHolder","holdersCount","newHolders","createRecurry","fn","reorder","createInverter","toIteratee","baseInverter","createMathOperation","operator","defaultValue","createOver","arrayFunc","createPadding","charsLength","createRange","step","toFinite","baseRange","createRelationalOperation","toNumber","wrapFunc","isCurry","newData","setData","setWrapToString","createRound","precision","toInteger","pair","noop","createToPairs","baseToPairs","createWrap","srcBitmask","newBitmask","isCombo","mergeData","createCurry","createPartial","createBind","customDefaultsAssignIn","customDefaultsMerge","customOmitClone","arrLength","arrStacked","arrValue","flatten","otherFunc","getValue","stubArray","hasPath","hasFunc","isLength","ArrayBuffer","ctorString","isMaskable","stubFalse","otherArgs","oldArray","shortOut","reference","details","insertWrapDetails","updateWrapDetails","getWrapDetails","lastCalled","stamp","remaining","rand","memoize","quote","subString","clone","difference","differenceBy","differenceWith","findIndex","findLastIndex","head","intersection","mapped","intersectionBy","intersectionWith","pull","pullAll","pullAt","union","unionBy","unionWith","unzip","group","unzipWith","without","xor","xorBy","xorWith","zip","zipWith","chain","interceptor","wrapperAt","countBy","find","findLast","forEachRight","groupBy","invokeMap","keyBy","partition","sortBy","before","bindKey","WRAP_BIND_FLAG","debounce","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","invokeFunc","time","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","cancel","flush","defer","delay","resolver","memoized","Cache","negate","overArgs","transforms","funcsLength","partial","partialRight","rearg","gt","gte","isError","isInteger","isNumber","isString","lt","lte","toArray","next","done","iteratorToArray","remainder","toLength","isBinary","assign","assignIn","assignInWith","assignWith","at","propsIndex","propsLength","defaultsDeep","mergeWith","invert","invertBy","invoke","nativeKeysIn","isProto","baseKeysIn","merge","omit","CLONE_DEEP_FLAG","basePick","pickBy","prop","toPairs","toPairsIn","camelCase","word","toLowerCase","capitalize","upperFirst","kebabCase","lowerCase","lowerFirst","snakeCase","startCase","upperCase","toUpperCase","hasUnicodeWord","unicodeWords","asciiWords","attempt","bindAll","methodNames","flow","flowRight","method","methodOf","mixin","over","overEvery","overSome","basePropertyDeep","range","rangeRight","augend","addend","divide","dividend","divisor","multiply","multiplier","multiplicand","round","subtract","minuend","subtrahend","after","castArray","chunk","compact","cond","conforms","baseConforms","properties","curry","curryRight","drop","dropRight","dropRightWhile","dropWhile","fill","baseFill","filter","flatMap","flatMapDeep","flatMapDepth","flattenDeep","flattenDepth","flip","fromPairs","functions","functionsIn","initial","mapKeys","mapValues","matches","matchesProperty","nthArg","omitBy","orderBy","propertyOf","pullAllBy","pullAllWith","remove","rest","sampleSize","setWith","shuffle","sortedUniq","sortedUniqBy","separator","limit","spread","tail","take","takeRight","takeRightWhile","takeWhile","tap","throttle","toPath","isArrLike","unary","uniq","uniqBy","uniqWith","unset","update","updateWith","valuesIn","wrap","zipObject","zipObjectDeep","entriesIn","extend","extendWith","clamp","cloneDeep","cloneDeepWith","cloneWith","conformsTo","defaultTo","endsWith","escape","escapeRegExp","every","findKey","findLastKey","forIn","forInRight","forOwn","forOwnRight","inRange","baseInRange","isBoolean","isElement","isEmpty","isEqual","isEqualWith","isMatch","isMatchWith","isNative","isNil","isNull","isSafeInteger","isUndefined","isWeakMap","isWeakSet","strictLastIndexOf","maxBy","mean","meanBy","minBy","stubObject","stubString","stubTrue","nth","noConflict","pad","strLength","padEnd","padStart","radix","floating","temp","reduce","reduceRight","repeat","sample","some","sortedIndex","sortedIndexBy","sortedIndexOf","sortedLastIndex","sortedLastIndexBy","sortedLastIndexOf","startsWith","sum","sumBy","template","settings","isEscaping","isEvaluating","imports","importsKeys","importsValues","interpolate","reDelimiters","evaluate","sourceURL","escapeValue","interpolateValue","esTemplateValue","evaluateValue","variable","times","toLower","toSafeInteger","toUpper","trim","trimEnd","trimStart","truncate","omission","search","global","newEnd","unescape","uniqueId","each","eachRight","first","VERSION","isFilter","takeName","dropName","checkIteratee","isTaker","lodashFunc","retUnwrapped","isLazy","useLazy","isHybrid","isUnwrapped","onlyLazy","chainName","dir","isRight","view","getView","iterLength","takeCount","iterIndex","commit","toJSON","endianness","hostname","location","loadavg","uptime","freemem","totalmem","cpus","release","navigator","appVersion","networkInterfaces","getNetworkInterfaces","arch","platform","tmpdir","tmpDir","EOL","homedir","t","r","u","l","c","o","__esModule","default","p","f","v","buf","from","readUInt16BE","b","coll","h","readUIntBE","readUIntLE","readIntBE","readIntLE","E","status","furthest","expected","B","_supportsSet","S","column","L","O","k","P","U","W","to","D","M","I","N","G","flags","ignoreCase","multiline","unicode","sticky","C","J","T","Y","V","H","or","X","then","many","K","Q","Z","$","nn","tn","desc","rn","parse","tryParse","assert","tieWith","tie","atMost","atLeast","contramap","promap","mark","en","node","sepBy","sepBy1","lookahead","notFollowedBy","fallback","ap","of","un","an","cn","sn","ln","pn","hn","dn","vn","gn","mn","yn","all","alt","any","cr","createLanguage","crlf","custom","digit","digits","eof","fail","formatError","isParser","lazy","letter","letters","lf","makeFailure","makeSuccess","newline","noneOf","oneOf","optWhitespace","Parser","regex","seq","seqMap","seqObj","succeed","whitespace","Binary","bitSeq","bitSeqObj","byte","encodedString","uintBE","uint8BE","uint16BE","uint32BE","uintLE","uint8LE","uint16LE","uint32LE","intBE","int8BE","int16BE","int32BE","intLE","int8LE","int16LE","int32LE","floatBE","readFloatBE","floatLE","readFloatLE","doubleBE","readDoubleBE","doubleLE","readDoubleLE","assertPath","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","lastSlashIndex","posix","cwd","resolvedPath","resolvedAbsolute","normalize","isAbsolute","trailingSeparator","joined","relative","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","matchedSlash","basename","ext","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","base","_format","delimiter","win32","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","marker","runClearTimeout","Item","nextTick","title","browser","env","argv","version","versions","chdir","umask","inherits","Queue","concurrency","autostart","pending","session","running","jobs","timers","clearTimers","timeoutId","callOnErrorOrEnd","cb","onerror","onend","begin","methodResult","job","didTimeout","resultIndex","promise","catch","stop","setImmediate","registerImmediate","channel","messagePrefix","onGlobalMessage","nextHandle","tasksByHandle","currentlyRunningATask","doc","document","attachTo","handle","runIfPresent","postMessage","importScripts","postMessageIsAsynchronous","oldOnMessage","onmessage","canUsePostMessage","event","addEventListener","attachEvent","MessageChannel","port1","port2","createElement","documentElement","script","onreadystatechange","removeChild","appendChild","task","clearImmediate","extensionContext","previousActiveEditorUri","lastClosedModeHandler","async","getAndUpdateModeHandler","forceSyncAndUpdate","activeTextEditor","vscode","window","isClosed","curHandler","ModeHandlerMap","getOrCreate","subscriptions","vimState","editor","uri","syncCursors","updateView","drawSelection","revealRange","focusChanged","loadConfiguration","validatorResults","configuration","load","Logger","configChanged","logger","debug","numErrors","validatorResult","level","toggleExtension","isDisabled","compositionState","VSCodeContext","mh","handleKeyEvent","SpecialKeys","ExtensionDisable","reset","ExtensionEnable","overrideCommand","command","disposable","commands","registerCommand","disableExtension","executeCommand","requiresActiveEditor","registerEventListener","exitOnExtensionDisable","exitOnTests","Globals","isTesting","forceStopRecursiveRemap","remapState","isCurrentlyPerformingRecursiveRemapping","forceStopRecursiveRemapping","handleLocal","StatusBar","Register","loadFromDisk","ExCommandLine","loadHistory","SearchCommandLine","filepathComponents","fileName","setReadonlyRegister","workspace","onDidChangeConfiguration","onDidChangeTextDocument","changeEvent","contentChanges","globalState","jumpTracker","handleTextDeleted","textWasAdded","handleTextAdded","getAll","modeHandler","documentUri","currentMode","Mode","Insert","historyTracker","currentContentChanges","contentChangeHandler","isDirty","isUntitled","scheme","HistoryTracker","onDidCloseTextDocument","closedDocument","documents","textDocuments","shouldDelete","delete","onDidChangeActiveTextEditor","mhPrevious","oldFileRegister","relativePath","asRelativePath","taskQueue","enqueueTask","handleFileJump","Jump","fromStateNow","onDidChangeTextEditorSelection","textEditor","kind","TextEditorSelectionChangeKind","Mouse","selectionsHash","selections","hash","anchor","character","active","idx","selectionsChanged","ourSelections","ignoreIntermediateSelections","EasyMotionMode","handleSelectionChange","onDidChangeTextEditorVisibleRanges","lastMessageTime","CompositionState","isInComposition","composingText","insertedText","substr","replaceCharCnt","cursorStopPosition","selection","cursorStartPosition","handleMultipleKeyEvents","cmd","showInputBox","prompt","ignoreFocusOut","valueSelection","Notation","NormalizeKey","leader","boundKey","boundKeyCombinations","startInInsertMode","cursors","cursor","eolColumn","lineAt","withNewStop","with","BaseAction","isJump","createsUndoPoint","preservesDesiredColumn","keysPressed","doesActionApply","currentModeIncludingPseudoModes","OperatorPendingMode","actionType","modes","CompareKeypressSequence","couldActionApply","keysSlice","is2DArray","static","sequence","left","right","isSingleNumber","isSingleAlpha","IsControlKey","KeypressState","isCompleteAction","runsOnceForEachCountPrefix","runsOnceForEveryCursor","timesToRepeat","recordedState","transformation","transformer","transformations","isTextTransformation","cursorIndex","resultingCursors","cursorsToIterateOver","Cursor","multicursorIndex","actionMap","possibleActionsForMode","hasPotentialMatch","actionKeys","WaitingOnKeys","NoPossibleMatch","actionInstance","modeName","isIMovement","SelectionType","failedMovement","failed","BaseMovement","isRepeat","super","Normal","Visual","VisualLine","VisualBlock","setsDesiredColumnToEOL","selectionType","Concatenating","firstIteration","lastIteration","execAction","prevResult","firstMovementStart","execActionForOperator","Position","adjustPosition","getRightThroughLineBreaks","DocumentContentChangeAction","BaseCommand","cursorStart","cursorEnd","addChanges","cursorPosition","compressChanges","getTransformation","positionDiff","diff","originalLeftBoundary","rightBoundary","change","linesAffected","resultLines","translate","diffPos","lineOffset","char","replaceRange","Range","isAfter","textDiffLines","numLinesAdded","newRightBoundary","laterOf","insert","PositionDiff","exactPosition","second","rangeOffset","compressed","prev","merged","DisableExtension","SearchInProgressMode","CommandlineInProgress","Replace","EasyMotionInputMode","SurroundInputMode","setCurrentMode","Disabled","RegisterAction","EnableExtension","CommandNumber","num","operatorCount","lastAction","actionsRun","isZero","CommandRegister","register","isValidRegister","registerName","CommandRecordMacro","registerKey","toLocaleLowerCase","macro","RecordedState","isValidUppercaseRegister","newRegister","put","CommandQuitRecordMacro","existingMacro","CommandExecuteLastMacro","lastInvokedMacro","addTransformation","replay","displayError","VimError","ErrorCode","NoPreviouslyUsedRegister","CommandExecuteMacro","isFilenameRegister","InvalidRegisterName","CommandEsc","surround","isMultiCursor","allSettled","easyMotion","clearDecorations","CommandInsertAtCursor","previousActionsNumbers","prevAction","CommandReplaceAtCursorFromNormalMode","CommandOverrideCopy","sorted","getText","getRight","earlierOf","getLineBegin","getLineEnd","TextEditor","iterateLinesInBlock","editorSelection","Clipboard","Copy","CommandCmdA","desiredColumn","lineCount","MarkCommand","markName","addMark","CommandShowCommandLine","commandLineText","previousMode","modeData","mode","commandLine","CommandShowCommandHistory","showQuickPick","history","placeHolder","CommandShowSearchHistory","direction","SearchDirection","Forward","Backward","searchState","showSearchHistory","hl","nextMatch","getNextSearchMatchPosition","SearchHitBottom","SearchHitTop","searchString","pos","reportSearch","getMatchRanges","CommandDot","previousFullAction","CommandRepeatSubstitution","exCommandParser","execute","CommandGoToOtherEndOfHighlightedText","CommandGoToOtherSideOfHighlightedText","CommandUndo","newPosition","goBackHistoryStep","setText","CommandUndoOnLine","goBackHistoryStepsOnLine","CommandRedo","goForwardHistoryStep","CommandDeleteToLineEnd","isLineEnd","linesDown","getDown","getLeftThroughLineBreaks","DeleteOperator","CommandYankFullLine","getLeft","currentRegisterMode","RegisterMode","LineWise","YankOperator","CommandChangeToLineEnd","ChangeOperator","CommandClearLine","runRepeat","sneak","CommandExitVisualMode","CommandVisualMode","CommandReselectVisual","lastVisualSelection","isBeforeOrEqual","CommandVisualBlockMode","CommandExitVisualBlockMode","CommandVisualLineMode","CommandExitVisualLineMode","CommandOpenFile","fullFilePath","prevWordStart","wordType","WordType","FileName","inclusive","nextWordStart","fileInfo","filePath","FileCommand","bang","opt","file","createFileIfNotExists","GoToDeclaration","GoToDefinition","CommandOpenLink","CommandGoBackInChangelist","prevPos","prevChangeInChangeList","CommandGoForwardInChangelist","nextPos","nextChangeInChangeList","CommandInsertAtLastChange","getLastChangeEndPosition","CommandInsertAtFirstCharacter","getFirstNonWhitespaceCharOnLine","CommandInsertAtLineBegin","CommandInsertAfterCursor","CommandInsertAtLineEnd","CommandInsertNewLineAbove","charPos","getLineBeginRespectingIndent","getCursorsAfterSync","endPos","indentAmt","newPos","setIndentationLevel","expandtab","manuallySetCursorPositions","isFakeMultiCursor","CommandInsertNewLineBefore","CommandNavigateBack","jumpBack","CommandNavigateForward","jumpForward","CommandTabNext","TabCommand","TabCommandType","Absolute","Next","CommandTabPrevious","Previous","ActionDeleteChar","getLeftIfEOL","ActionDeleteCharWithDeleteKey","actionsRunPressedKeys","execCount","ActionDeleteLastChar","ActionJoin","firstNonWhitespaceIndex","str","chCode","startPosition","joinspaces","startLineNumber","startColumn","endLineNumber","endColumn","columnDeltaOffset","getLineLength","trimmedLinesContent","lineText","firstNonWhitespaceIdx","insertSpace","lineTextWithoutIndent","deleteStartPosition","deleteEndPosition","execJoinLines","ActionJoinVisualMode","CharacterWise","ActionJoinVisualBlockMode","ActionJoinNoWhitespace","execJoin","joinedText","newCursorColumn","exactCharacter","ActionJoinNoWhitespaceVisualMode","ActionReplaceCharacter","toReplace","vscodeCommand","moveCursor","ActionReplaceCharacterVisual","toInsert","getTabCharacter","visualSelectionOffset","textLength","lineNum","ActionReplaceCharacterVisualBlock","topLeft","visualBlockGetTopLeftPosition","ActionDeleteVisualBlock","lines","BlockWise","ActionShiftDVisualBlock","ActionGoToInsertVisualBlockMode","ActionChangeInVisualBlockMode","width","visualBlockGetBottomRightPosition","ActionChangeToEOLInVisualBlockMode","ActionGoToInsertVisualLineModeCommand","cursorsOnBlankLines","cursorRange","getCursorRangeForLine","isEmptyOrWhitespace","ActionGoToInsertVisualLineMode","startCharacterPosition","lineNumber","firstNonWhitespaceCharacterIndex","ActionGoToInsertVisualLineModeAppend","endCharacterPosition","ActionGoToInsertVisualMode","selectionStart","selectionEnd","ActionGoToInsertVisualModeAppend","ActionGoToInsertVisualBlockModeAppend","newCursors","insertionColumn","POSITIVE_INFINITY","newCursor","ActionDeleteCharVisualLineMode","ActionDeleteLineVisualMode","ActionChangeLineVisualModeS","ActionChangeLineVisualMode","ActionChangeLineVisualBlockMode","ActionChangeChar","ToggleCaseAndMoveForward","toggleCase","newText","toggled","toLocaleUpperCase","shouldWrapKey","getOffsetThroughLineBreaks","IncrementDecrementNumberAction","ranges","getSearchRanges","stepNum","whereToStart","wordLoop","iterateWords","NumericString","suffixOffset","replaceNum","staircase","isVisualMode","startPos","oldLength","newNum","bottomRight","IncrementNumberAction","DecrementNumberAction","IncrementNumberStaircaseAction","DecrementNumberStaircaseAction","CommandUnicodeName","charCode","ActionTriggerHover","ActionOverrideCmdD","ActionOverrideCmdDInsert","curPos","Selection","nextWordEnd","matchWordPos","matchWordLength","wordBegin","ActionOverrideCmdAltDown","ActionOverrideCmdAltUp","ActionShowFileInfo","reportFileInfo","WriteQuit","WriteQuitCommand","Quit","QuitCommand","ActionGoToAlternateFile","altFile","NoAlternateFile","files","doesFileExist","Uri","findFiles","openTextDocument","showTextDocument","ShowFileOutline","CommandLineAction","CommandLineTab","cycleCompletion","isTabForward","autoCompleteItems","autoCompleteIndex","lastPos","preCompleteCharacterPos","lastCmd","preCompleteCommand","evalCmd","restCmd","newCompletionItems","fileRegex","builtinExCommands","filePathInCmd","currentUri","isRemote","remoteName","fullDirPath","baseName","partialPath","getPathDetails","shouldAddDotItems","dirItems","readDirectory","startWithBaseNameRegex","newIndex","completion","ExCommandLineEnter","SearchCommandLineEnter","CommandLineEscape","CommandLineBackspace","backspace","CommandLineDelete","CommandlineHome","home","CommandLineEnd","CommandLineDeleteWord","deleteWord","CommandLineDeleteToBeginning","deleteToBeginning","CommandLineWordLeft","wordLeft","CommandLineWordRight","wordRight","CommandLineHistoryBack","historyBack","CommandLineHistoryForward","historyForward","CommandInsertRegisterContentInCommandLine","NothingInRegister","keyStrokes","registerMode","CommandInsertWord","getWord","CommandLineLeftRight","getTrimmedStatusBarText","statusBarText","CommandLinePaste","textFromClipboard","Paste","CommandCtrlLInSearchMode","currentMatch","getCurrentMatchRange","getSearchState","CommandAdvanceCurrentMatch","advanceCurrentMatch","CommandLineType","typeCharacter","DefaultDigraphs","CommandFold","levels","commandName","CommandToggleFold","CommandCloseFold","CommandCloseAllFolds","CommandOpenFold","CommandOpenAllFolds","CommandCloseAllFoldsRecursively","CommandOpenAllFoldsRecursively","AddFold","BaseOperator","previousSelections","RemoveFold","newCursorPosition","CommandEscInsertMode","returnToInsertAfterCommand","lastActionBeforeEsc","languageId","changeAction","lastContentChanges","CommandInsertPreviousText","NoInsertedTextYet","ArrowsInInsertMode","CommandInsertPreviousTextAndQuit","IndentCommand","tabSize","indentationWidth","getIndentationLevel","newIndentationWidth","insertSpaces","IncreaseIndent","DecreaseIndent","CommandBackspaceInInsertMode","CommandDeleteInInsertMode","CommandInsertInInsertMode","prevHighSurrogate","highSurrogate","isHighSurrogate","setModeData","isLowSurrogate","CommandInsertDigraph","digraph","reverseDigraph","charCodes","digraphs","reverseChars","digraphChars","CommandInsertRegisterContent","CommandOneNormalCommandInInsertMode","actionCount","CommandCtrlW","isAtDocumentBegin","isInLeadingWhitespace","isLineBeginning","getUp","InsertCharAbove","InsertCharBelow","CommandCtrlUInInsertMode","CommandNavigateAutocompleteDown","CommandNavigateAutocompleteUp","CommandCtrlVInInsertMode","clipboard","CommandShowLineAutocomplete","lineCompletionProvider","showLineCompletionsQuickPick","NewLineInsertMode","CommandReplaceAtCursorFromInsertMode","CreateUndoPoint","addChange","finishCurrentStep","firstNonBlankChar","BasePutCommand","overwritesRegisterWithSelection","getRegisterMode","getReplaceRange","getRegisterText","shouldAdjustIndent","lineToMatch","adjustIndent","getCursorPosition","adjustLinewiseRegisterText","getTransformations","advancePositionByText","useSystemClipboard","numNewlinesAfterPut","reportLinesChanged","longestLength","space","tabstop","firstLineIdentationWidth","deletedNewlines","lineLength","leftPadding","rightPadding","insertPos","putBefore","PutCommand","rangeStart","PutBeforeCommand","PlaceCursorAfterText","Base","lastLine","longestLineLength","GPutCommand","GPutBeforeCommand","AdjustIndent","PutWithIndentCommand","PutBeforeWithIndentCommand","ExCommand","setInsertionLine","insertLine","PutFromCmdLine","PutBeforeFromCmdLine","ExitReplaceMode","replaceState","cursorIdx","getChanges","ReplaceModeToInsertMode","BackspaceInReplaceMode","resetChanges","ReplaceInReplaceMode","isNewLineOrTab","CommandEditorScroll","scrolloff","getConfiguration","visibleRange","visibleRanges","linesAboveCursor","linesBelowCursor","withColumn","postponedCodeViewChanges","by","select","CommandCtrlE","CommandCtrlY","CommandScrollAndMoveCursor","smoothScrolling","moveLines","getNumLines","scrollLines","revealCursor","newPositionLine","obeyStartOfLine","CommandMoveFullPageUp","CommandMoveFullPageDown","CommandMoveHalfPageDown","getScrollLines","CommandMoveHalfPageUp","CommandCenterScroll","TextEditorRevealType","InCenter","CommandCenterScrollFirstChar","CommandTopScroll","CommandTopScrollFirstChar","CommandBottomScroll","CommandBottomScrollFirstChar","searchCurrentWord","isExact","currentWord","searchStartCursorPosition","createSearchStateAndMoveToMatch","needle","NoStringUnderCursor","searchCurrentSelection","currentSelection","escapedNeedle","SearchState","ignoreSmartcase","addSearchStateToHistory","CommandSearchCurrentWordExactForward","visualstar","CommandSearchCurrentWordForward","CommandSearchCurrentWordExactBackward","CommandSearchCurrentWordBackward","CommandSearchForwards","CommandSearchBackwards","firstVisibleLineBeforeSearch","SearchObject","TextObject","newSearchState","findContainingMatchRange","getNextSearchMatchRange","SearchObjectForward","SearchObjectBackward","CommandQuit","CommandOnly","OnlyCommand","MoveToRightPane","MoveToLowerPane","MoveToUpperPane","MoveToLeftPane","CycleThroughPanes","VerticalSplit","OrthogonalSplit","EvenPaneWidths","IncreasePaneWidth","DecreasePaneWidth","IncreasePaneHeight","DecreasePaneHeight","supportsLookbehind","PythonDocument","_document","parsed","_parseLines","structure","_parseStructure","reOnlyWhitespace","indentation","_indentation","_parseLine","info","reDefOrClass","endLine","reLastNonWhiteSpaceCharacter","edge","isDirection","elements","elem","element","forward","BasePythonMovement","MovePythonNextFunctionStart","MovePythonPrevFunctionStart","MovePythonNextFunctionEnd","MovePythonPrevFunctionEnd","ExpandingSelection","Expanding","MoveByScreenLine","execActionWithCount","movementType","removed","MoveUpByScreenLine","MoveDownByScreenLine","MoveByScreenLineMaintainDesiredColumn","prevDesiredColumn","prevLine","returnedPos","MoveDownFoldFix","prevChar","moveDownByScreenLine","lineChanged","colChanged","MoveDown","foldfix","MoveUp","MoveUpFoldFix","moveUpByScreenLine","MoveLeft","MoveRight","ArrowsInReplaceMode","CommandNextSearchMatch","PatternNotFound","searchForward","CommandPreviousSearchMatch","prevMatch","MarkMovementBOL","getMark","MarkNotSet","isUppercaseMark","ensureEditorIsActive","MarkMovement","NextMark","positions","getLocalMarks","compareTo","PrevMark","isBefore","NextMarkLinewise","PrevMarkLinewise","getLeftWhile","getRightWhile","MoveDownNonBlank","MoveUpNonBlank","MoveDownUnderscore","MoveToColumn","findHelper","MoveFindForward","sneakReplacesF","SneakForward","ToControlCharacter","lastSemicolonRepeatableMovement","lastCommaRepeatableMovement","MoveFindBackward","SneakBackward","tilHelper","MoveTilForward","toFind","MoveTilBackward","MoveRepeat","movement","MoveRepeatReversed","semiColonMovement","commaMovement","MoveLineEnd","MoveLineBegin","MoveScreenLineBegin","MoveScreenNonBlank","MoveScreenLineEnd","MoveScreenLineEndNonBlank","MoveScreenLineCenter","MoveUpByDisplayLine","MoveDownByDisplayLine","MoveUpByScreenLineVisualLine","MoveDownByScreenLineVisualLine","MoveUpByScreenLineVisualBlock","MoveDownByScreenLineVisualBlock","MoveScreenToRight","MoveScreenToLeft","MoveScreenToRightHalf","MoveScreenToLeftHalf","MoveToLineFromViewPortTop","MoveToLineFromViewPortBottom","MoveToMiddleLineInViewPort","MoveNonBlank","MoveNonBlankFirst","MoveNonBlankLast","EndOfSpecificLine","MoveWordBegin","changeWordIncludesWhitespace","isFirstWordOfLine","MoveFullWordBegin","Big","MoveWordEnd","MoveFullWordEnd","MoveLastWordEnd","prevWordEnd","MoveLastFullWordEnd","MoveBeginningWord","MoveBeginningFullWord","MovePreviousSentenceBegin","getSentenceBegin","GoToOffset","positionAt","MoveNextSentenceBegin","MoveParagraphEnd","iteration","isFirstLineWise","hasOperator","paragraphEnd","getCurrentParagraphEnd","isLineWise","isLastIteration","isAtDocumentEnd","MoveParagraphBegin","getCurrentParagraphBeginning","MoveSectionBoundary","moveClassBoundary","boundary","MoveNextSectionBegin","MoveNextSectionEnd","MovePreviousSectionBegin","MovePreviousSectionEnd","MoveToMatchingBracket","failure","col","currentChar","PairMatcher","getPercentPairing","nextPairedChar","targetLine","trunc","MoveInsideCharacter","includeSurrounding","closingChar","pairings","charToMatch","selStart","selEnd","openPos","closePos","isAfterOrEqual","outerOpenPos","outerClosePos","operatorPositionDiff","MoveInsideParentheses","MoveAroundParentheses","MoveCurlyBrace","openCurlyBraceIndexFromCursor","startSameAsEnd","curlyPos","MoveInsideCurlyBrace","MoveAroundCurlyBrace","MoveInsideCaret","MoveAroundCaret","MoveInsideSquareBracket","MoveAroundSquareBracket","MoveQuoteMatch","adjustForTrailingWhitespace","anyQuote","includeQuotes","which","useSmartQuotes","SmartQuoteMatcher","smartSurroundingQuotes","targets","smartQuotes","aIncludesSurroundingSpaces","trailingWhitespace","characterDelta","quoteIndices","QuoteMatcher","surroundingQuotes","hasRunOperator","MoveInsideSingleQuotes","MoveAroundSingleQuotes","MoveInsideDoubleQuotes","MoveAroundDoubleQuotes","MoveInsideBacktick","MoveAroundBacktick","MoveToUnclosedRoundBracketBackward","MoveToUnclosedRoundBracketForward","MoveToUnclosedCurlyBracketBackward","MoveToUnclosedCurlyBracketForward","MoveTagMatch","includeTag","editorText","offsetAt","tagMatcher","TagMatcher","findOpening","findClosing","endPosition","MoveInsideTag","MoveAroundTag","doesRepeatedOperatorApply","nonCountActions","highlightYankedRanges","highlightedyank","enable","yankDecoration","createTextEditorDecorationType","backgroundColor","color","textColor","setDecorations","dispose","duration","numLinesDeleted","isOnLastLine","startOfLine","DeleteOperatorVisual","extendedEnd","sLine","eLine","numLinesYanked","reportLinesYanked","FilterOperator","cursorsInitialState","ShiftYankOperatorVisual","DeleteOperatorXVisual","ChangeOperatorSVisual","FormatOperator","ChangeCaseOperator","transformText","UpperCaseOperator","UpperCaseWithMotion","LowerCaseOperator","LowerCaseWithMotion","ToggleCaseOperator","ToggleCaseWithMotion","IndentOperator","IndentOperatorVisualAndVisualLine","isRunningDotCommand","dotCommandPreviousVisualSelection","shiftSelectionByNum","IndentOperatorVisualBlock","lineIdx","OutdentOperator","OutdentOperatorVisualAndVisualLine","OutdentOperatorVisualBlock","currentLine","currentLineFromStart","currentLinePosition","distToNonBlankChar","outdentDist","deleteRange","autoindent","firstLineIndent","endOfLine","YankVisualBlockMode","CommentOperator","ROT13Operator","original","rot13","A","CommentBlockOperator","ActionVisualReflowParagraph","getIndentation","indent","reflowParagraph","indentLevel","maximumLineLength","textwidth","chunksToReflow","lastChunk","trimmedLine","commentType","CommentTypes","final","singleLine","inner","content","indentLevelAfterComment","indentAfterComment","commentLength","breakpoint","textToReflow","trigger","leaderCount","BaseEasyMotionCommand","baseOptions","_baseOptions","processMarkers","clearMarkers","markerGenerator","MarkerGenerator","matchPosition","resolveMatchPosition","generateMarker","addMarker","searchOptions","easymotion","getMatches","EasyMotion","markers","getMatchesForString","sortedSearch","regexFlags","ignorecase","smartcase","_options","searchCharCount","charCount","shouldFire","labelPosition","removeTrailingLineBreak","EasyMotionCharMoveCommandBase","_action","searchAction","getMatchesForWord","jumpToAnywhere","easymotionJumpToAnywhereRegex","getMatchesForLineStart","EasyMotionCharInputMode","fire","CommandEscEasyMotionCharInputMode","MoveEasyMotion","nail","accumulation","findMarkers","visibleMarkers","decorations","decorationTypeCache","getDecorationType","fade","hide","onlyVisible","specialCharactersRegex","lineMin","lineMax","Match","computeAboluteDiff","matchIndex","absDiff","getMarkerColor","customizedValue","themeColorId","ThemeColor","getEasymotionMarkerBackgroundColor","easymotionMarkerBackgroundColor","getEasymotionMarkerForegroundColorOneChar","easymotionMarkerForegroundColorOneChar","getEasymotionMarkerForegroundColorTwoCharFirst","easymotionMarkerForegroundColorTwoCharFirst","getEasymotionMarkerForegroundColorTwoCharSecond","easymotionMarkerForegroundColorTwoCharSecond","getEasymotionDimColor","easymotionDimColor","updateDecorations","dimmingZones","dimmingRenderOptions","hiddenChars","keystroke","nextKeystroke","firstCharFontColor","firstCharRange","firstCharRenderOptions","contentText","margin","easymotionMarkerFontWeight","height","renderOptions","dark","light","secondCharFontColor","secondCharRange","secondCharRenderOptions","easymotionDimBackground","prevMarker","prevKeystroke","prevDimPos","offsetPrevDimPos","getDocumentEnd","matchesCount","keyTable","getKeyTable","prefixKeyTable","createPrefixKeyTable","markerPosition","currentStep","totalRemainder","totalSteps","reversed","easymotionKeys","toRange","PluginDefaultMappings","config","defaultMappings","configSwitch","mapping","startingLetter","sneakUseIgnorecaseAndSmartcase","QuoteMatch","quoteDirs","includeCurrent","skipToLeft","skipToRight","buildQuoteMap","quoteMap","openingQuote","escapeChar","Opening","Closing","lc","cc","rc","validatePosition","act","lineSearchAction","breakThroughLines","getNextQuoteThroughLineBreaks","getLastQuoteThroughLineBreaks","searchRes","smartSearch","fst","snd","cursorPos","getNextQuote","getPrevQuote","bracketObjects","whichwrap","CommandLine","historyIndex","getHistory","savedText","historyEntries","getWordLeftInText","getWordRightInText","wordStart","modifiedString","commandText","CommandLineHistory","display","cursorChar","escapeCSSIcons","lineRange","getDecorations","SubstituteCommand","getSubstitutionDecorations","RegisterCommand","recState","commandList","enableNeovim","neovimCapable","nvim","executeWithRange","NotAnEditorCommand","lastCommandDotRepeatable","isRepeatableWithDot","currentMatchDisplacement","items","previousSearchStates","label","item","SearchHistory","val","prevSearchString","getCurrentMatchRelativeIndex","getCurrentMatchPosition","getDecorationsForSearchMatchRanges","incsearch","prevSearchList","scrollView","wrapscan","AsciiCommand","BangCommand","_arguments","getReplaceDiff","numNewlines","check","numWhitespace","externalCommand","resolvedRange","resolveToRange","output","argParser","isSourceBreakpoint","isFunctionBreakpoint","functionName","AddBreakpointCommand","addBreakpoint","Location","addBreakpoints","SourceBreakpoint","workspaceFolder","getWorkspaceFolder","joinPath","FunctionBreakpoint","function","expr","DeleteBreakpointCommand","delBreakpoint","removeBreakpoints","breakpoints","reqUri","reqLine","distFromLocationCharacter","ListBreakpointsCommand","enabled","condition","fsPath","breakpointId","selected","Breakpoints","argParsers","numberParser","fileNameParser","del","BufferDeleteCommand","NoWriteSinceLastChange","buffers","NoBuffersDeleted","bangParser","CloseCommand","visibleTextEditors","CannotCloseLastWindow","oldViewColumn","viewColumn","CopyCommand","address","copyLines","sourceStart","sourceEnd","dest","InvalidAddress","copiedText","Address","parser","DeleteCommand","startLine","getLineEndIncludingEOL","linesToRemove","DigraphsCommand","makeQuickPicks","quickPicks","digraphKey","charDesc","description","digraphKeyAndContent","newDigraphs","FilePosition","NewWindowHorizontalSplit","NewWindowVerticalSplit","getLegacyArgs","editorFileUri","editorFilePath","hidePreviousEditor","untildify","fileUri","fileList","showOpenDialog","fullPath","uriPath","resolveUri","fileExists","pathWithExt","uriPathWithExt","fileOptParser","fileCmdParser","enew","new","vnew","vsplit","FileInfoCommand","GotoCommand","gotoOffset","GotoLineCommand","HistoryCommandType","historyTypeParser","nameAbbrevParser","Cmd","Search","Expr","Input","Debug","All","HistoryCommand","JumpPickItem","jump","detail","JumpsCommand","hasJumps","quickPickItems","jumps","canPickMany","showInformationMessage","ClearJumpsCommand","clearJumps","LeftCommand","LineRange","RightCommand","CenterCommand","MarkQuickPickItem","picked","alwaysShow","MarksCommand","marksFilter","getMarks","marks","DeleteMarksCommand","asciiRange","InvalidArgument","asciiStart","asciiEnd","ascii","resolveMarkList","removeMarks","NohlCommand","PrintCommand","printNumbers","printText","PutExCommand","TrailingCharacters","putCmd","doPut","duplicatedInSplit","quitAll","ReadCommand","textToInsert","getTextToInsert","readFileAsync","SUPPORT_READ_COMMAND","stdout","stderr","registers","getRegisterDisplayValue","regSortOrder","specials","displayRegisterValue","currentRegisterKeys","getKeys","reg","reg1","reg2","registerKeyAndContent","RetabCommand","retab","hasTabs","expanded","spaces","retabLineSegment","segment","replaceSpaces","retabTabstop","newTabstop","detabbed","tabs","retabLine","segments","retabbed","originalLines","replacedContent","lastLineLength","SetCommand","option","optionParser","valueParser","setOperationParser","operation","optionAliases","currentValue","UnknownOption","showOption","NumberRequiredAfterEqual","ShCommand","createTerminal","show","ShiftCommand","numLines","shifts","SmileCommand","smileText","SortCommand","sortLines","unique","uniqueLines","adjustedLine","sortedLines","numeric","NumericStringRadix","Dec","localeCompare","sortedContent","ReplaceString","components","component","substituteState","replaceString","substituteFlagsParser","amp","flagChars","keepPreviousFlags","flag","confirmEach","suppressError","replaceAll","noIgnoreCase","printCount","printLastMatchedLine","printLastMatchedLineWithNumber","printLastMatchedLineWithList","usePreviousPattern","countParser","abort","substitutionAppend","substitutionReplace","searchHighlight","subsArr","inccommand","resolvePatterns","showReplacements","closed","patternString","allMatches","gdefault","substituteGlobalFlag","formatDecorationText","groups","ensureVisible","replaceText","confirmReplacement","cancellationToken","CancellationTokenSource","validSelections","newConfirmationSearchHighlights","cSearchHighlights","decoration","searchMatch","confirmedSubstitution","confirmedSubstitutions","validateInput","token","throwErrors","prevSubstituteState","searchPattern","NoPreviousSubstituteRegularExpression","prevSearchState","NoPreviousRegularExpression","replaceableMatches","replaceableLines","substitutionLines","substitutions","netNewLines","newLines","replaceMatchRange","recordJump","setStatusBarText","SubstituteState","report","Pattern","escaped","replaceStringParser","tabGroup","tabGroups","activeTabGroup","tab","executeCommandWithCount","First","Last","New","isInWorkspace","workspaceFolders","currentFilePath","toOpenPath","workspacePath","Close","Only","Move","bfirst","blast","bnext","bprev","tabclose","tabonly","tabnew","tabmove","TerminalCommand","UndoCommand","VsCodeCommand","ArgumentRequired","WallCommand","saveAll","WriteCommand","background","fs","accessAsync","constants","W_OK","save","accessErr","getMode","chmodAsync","bgWrite","success","WriteQuitAllCommand","quitArgs","wallCmd","wall","quitCmd","quit","fileOpt","YankCommand","linesToYank","yank","charToFind","charToStack","stackHeight","isNextMatchForward","allowCurrentPosition","linePosition","keepSearching","originalLineLength","nextChar","pairMemberChar","pairing","matchpairs","directionless","findPairedChar","corpus","cursorQuoteType","closing","opening","TAG_REGEX","tags","CLOSE_FORWARD_SLASH","TAG_NAME","OPEN_FORWARD_SLASH","matchedTags","openNode","openingTagStart","openingTagEnd","closingTagStart","closingTagEnd","firstNonWhitespacePositionOnLine","startPosOffset","endPosOffset","tagsSurrounding","nodeSurrounding","determineRelevantTag","openStart","closeEnd","openEnd","closeStart","adjustedStartPosOffset","selectionActive","relevantTag","isValid","sel","equals","withNewStart","PositionDiffType","Offset","ExactPosition","ObeyStartOfLine","EndOfLine","ExactCharacter","p1","p2","boundsCheck","resultLine","resultChar","getLineCount","lineDelta","includeEol","getSentenceEnd","newlines","startofline","numLength","negative","isCapital","targetRadix","filteredMatchings","matchings","matching","coreBegin","coreLength","coreRadix","coreSign","coreEnd","core","numPrefix","Oct","Hex","linesWithoutIndentation","lineToStartScanFrom","scanAboveFirst","distanceFromStartLine","sortPriority","getCompletionsForCurrentLine","currentFileName","currentPosition","matchedLines","startingFileName","documentsStartingWith","getCompletionsForText","completions","selectedCompletion","extensionVersion","packagejson","Configuration","leaderDefault","cursorTypeMap","TextEditorCursorStyle","Line","block","Block","underline","Underline","LineThin","BlockOutline","UnderlineThin","handleKeys","shell","useCtrlKeys","overrideCopy","hlsearch","camelCaseMotion","replaceWithRegister","smartRelativeLine","argumentObjectSeparators","argumentObjectOpeningDelimiters","argumentObjectClosingDelimiters","easymotionIncSearchForegroundColor","autoSwitchInputMethod","defaultIM","obtainIMCmd","switchIMCmd","maxmapdepth","showcmd","showmodename","statusBarColorControl","statusBarColors","normal","visual","visualline","visualblock","silent","loggingLevelForAlert","loggingLevelForConsole","searchHighlightColor","searchHighlightTextColor","searchMatchColor","searchMatchTextColor","substitutionColor","substitutionTextColor","mouseSelectionGoesIntoVisualMode","neovimPath","neovimUseConfigFile","neovimConfigPath","vimrc","showMarksInGutter","scroll","cursorStylePerMode","insertModeKeyBindings","insertModeKeyBindingsNonRecursive","normalModeKeyBindings","normalModeKeyBindingsNonRecursive","operatorPendingModeKeyBindings","operatorPendingModeKeyBindingsNonRecursive","visualModeKeyBindings","visualModeKeyBindingsNonRecursive","commandLineModeKeyBindings","commandLineModeKeyBindingsNonRecursive","insertModeKeyBindingsMap","normalModeKeyBindingsMap","operatorPendingModeKeyBindingsMap","visualModeKeyBindingsMap","commandLineModeKeyBindingsMap","vimConfigs","mockConfiguration","unproxify","SUPPORT_VIMRC","vimrcModel","clearKeyBindingsMaps","configurationValidator","validate","keybinding","contributes","keybindings","when","mac","linux","useKey","handleKey","section","resource","cursorStyleFromString","cursorStyle","editorCursorStyle","editorCursorStyleRaw","getCursorStyleForMode","obj","overlapSetting","propertyKey","settingName","vscodeSetting","vimSetting","ConfigurationTarget","Global","validators","registerValidator","validator","ValidatorResults","hasError","disable","_markDecorationCache","letterSpacing","opacity","_createMarkDecoration","svg","isWholeLine","gutterIconPath","gutterIconSize","_default","_searchHighlight","_searchMatch","_substitutionAppend","_substitutionReplace","easyMotionIncSearch","_easyMotionIncSearch","easyMotionDimIncSearch","_easyMotionDimIncSearch","getOrCreateMarkDecoration","decorationType","getMarkDecoration","allMarkDecorations","insertModeVirtualCharacter","_insertModeVirtualCharacter","operatorPendingModeCursor","_operatorPendingModeCursor","operatorPendingModeCursorChar","_operatorPendingModeCursorChar","borderColor","borderStyle","borderWidth","searchHighlightBackgroundColor","overviewRulerColor","searchMatchBackgroundColor","substitutionBackgroundColor","fontWeight","errors","append","validationResult","validationResults","numWarnings","hasWarning","isSurroundedByAngleBrackets","leaderKey","standardNotation","notationMap","shiftedLetterRegex","normalized","remappers","InsertModeRemapper","NormalModeRemapper","VisualModeRemapper","CommandLineModeRemapper","OperatorPendingModeRemapper","isPotentialRemap","remapper","sendKey","Remapper","configKey","remappedModes","_isPotentialRemap","hasPotentialRemap","allowPotentialRemapOnFirstKey","remainingKeys","allowBufferingKeys","userDefinedRemappings","TimeoutFinished","remapping","findMatchingRemap","hasAmbiguousRemap","resetCommandList","wasPerformingRemapThatFinishedWaitingForTimeout","lastRemapLength","keysPressedByUser","ForceStopRemappingError","bufferedKeys","bufferedKeysTimeoutObj","newRemapping","skipFirstCharacter","hasParentRemapping","isCurrentlyPerformingRemapping","mapDepth","recursive","isCurrentlyPerformingNonRecursiveRemapping","remapFailed","vimError","RecursiveMapping","fromVimError","ms","remapUsedACharacter","handleRemapping","specialKey","lastRemapWithoutAmbiguousRemap","commandString","commandArgs","inputtedKeys","getRemappedKeysLengthRange","startingSliceLength","inputtedString","sliceLength","keySlice","verbose","precedingKeys","remappings","keyLengths","remap","countRemapAsPotential","keysAsString","re","keyBindingsConfigKey","InputMethodSwitcherConfigurationValidator","inputMethodConfig","existsAsync","getRawCmd","RemappingValidator","modeKeyBindingsKeys","modeKeyBindingsKey","pluginMapping","getPluginDefaultMappings","isRecursive","modeMapName","modeKeyBindingsMap","remappingError","isRemappingValid","beforeKeys","isCommandValid","getCommandMap","commandMap","getCommands","ErrorMessage","extraValue","reason","HistoryFile","historyFileName","HistoryBase","extensionStoragePath","historyFilePath","historyKey","diffEngine","DiffMatchPatch","DocumentChange","beforeRange","afterRange","HistoryStep","isFinished","cameFromU","timestamp","intersect","intersectLength","howLongAgo","timeDiffMillis","timeDiffSeconds","getHours","getMinutes","getSeconds","globalMarks","UndoStack","historySteps","currentStepIndex","initialMarks","getHistoryStepAtIndex","getCurrentHistoryStepIndex","getStackDepth","getCurrentHistoryStep","stepForward","stepBackward","pushChange","pushHistoryStep","getCurrentMarkList","ChangeList","changeLocations","addChangePosition","nextChangePosition","ChangeListIsEmpty","AtEndOfChangeList","prevChangePosition","AtStartOfChangeList","undoStack","changeList","previousDocumentState","getDocumentText","versionNumber","getDocumentVersion","updateAndReturnMarks","previousMarks","getAllCurrentDocumentMarks","newMarks","newMark","ch","docEnd","getMarkList","isFileMark","putMarkInList","previousIndex","existingMark","getLastChangeStartPosition","getLastHistoryStartPosition","removeLocalMarks","markNames","getGlobalMarks","force","nextStepStartPosition","whatHappened","added","DIFF_INSERT","ignoreChange","currentHistoryStep","changePos","undo","do","changesToUndo","lastChange","undoLine","stepIdx","matchAll","newStep","lastChangeIndex","isSamePosition","_jumps","_currentJumpNumber","isJumpingThroughHistory","currentJumpNumber","currentJump","pushJump","FileNoLongerAvailable","jumpThroughHistory","recordJumpForward","recordJumpBack","getJump","iterations","performFileJump","distance","changePositionForJumpNumber","newLineShiftedUp","removeDuplicateJumps","clearJumpsOnSameLine","linesSeenPerFile","VSCodeVimCursorType","cursorType","TextDecoration","Native","ModeHandler","handlerMap","disposables","lastClickWasPastEol","Remappers","VimState","RemapState","_currentMode","isSnippetSelectionChange","contains","allowedModes","Command","Keyboard","isStatusBarMode","toDraw","newStart","printableKey","oldMode","oldFullMode","oldStatusBarText","oldWaitingForAnotherActionKey","waitingForAnotherActionKey","handledAsRemap","handledAsAction","preventZeroRemap","handleKeyAsAnAction","lastKeyPressedTimestamp","updateShowCmd","forceClearStatusBar","lastMovementFailed","getRelevantAction","actionToRecord","actionCanBeMergedWithDocumentChange","newContentChange","runAction","isInsertion","fromStateBefore","ranRepeatableAction","ranAction","executeMovement","executeTransformations","prevMode","getOperatorState","executeOperator","createUndoPointForBrackets","isReplayingMacro","documentEndPosition","documentLineCount","currentLineLength","currentStartLineLength","offsetAllowed","cursorsToRemove","oldCursorPositionStart","oldCursorPositionStop","startingMode","startingRegisterMode","operators","resultingCursor","recordedMacro","originalLocation","updateSearchHighlights","showHighlights","cacheKey","searchDecorationCacheKey","documentVersion","selectionMode","combinedSelections","previousSelection","getSelectionsCombined","isLastCursorTracked","cursorToTrack","isCursorAboveRange","isCursorBelowRange","revealType","Default","getCursorType","getCursorStyle","cursorStop","iModeVirtualCharDecorationOptions","virtualKey","eolRenderOptions","opCursorDecorations","opCursorCharDecorations","getCharAt","markDecoration","markLine","markRange","easyMotionDimRanges","SearchByNCharCommand","getDocumentBegin","easyMotionHighlightRanges","viewChange","modeHandlerMap","editorId","SUPPORT_NVIM","SUPPORT_IME_SWITCHER","UV_FS_SYMLINK_DIR","UV_FS_SYMLINK_JUNCTION","O_RDONLY","O_WRONLY","O_RDWR","UV_DIRENT_UNKNOWN","UV_DIRENT_FILE","UV_DIRENT_DIR","UV_DIRENT_LINK","UV_DIRENT_FIFO","UV_DIRENT_SOCKET","UV_DIRENT_CHAR","UV_DIRENT_BLOCK","S_IFMT","S_IFREG","S_IFDIR","S_IFCHR","S_IFBLK","S_IFIFO","S_IFLNK","S_IFSOCK","O_CREAT","O_EXCL","UV_FS_O_FILEMAP","O_NOCTTY","O_TRUNC","O_APPEND","O_DIRECTORY","O_NOFOLLOW","O_SYNC","O_DSYNC","O_SYMLINK","O_NONBLOCK","S_IRWXU","S_IRUSR","S_IWUSR","S_IXUSR","S_IRWXG","S_IRGRP","S_IWGRP","S_IXGRP","S_IRWXO","S_IROTH","S_IWOTH","S_IXOTH","F_OK","R_OK","X_OK","UV_FS_COPYFILE_EXCL","COPYFILE_EXCL","UV_FS_COPYFILE_FICLONE","COPYFILE_FICLONE","UV_FS_COPYFILE_FICLONE_FORCE","COPYFILE_FICLONE_FORCE","stat","_e","encoding","readFile","createDirectory","writeFile","workspaceState","parsedData","VsCodeMessage","actionMessages","errorMessage","log","debugMessage","warnMessage","verboseMessage","showMessage","copyToUnnamed","isBlackHoleRegister","isReadOnlyRegister","appendToRegister","overwriteRegister","isValidLowercaseRegister","specialRegisters","isClipboardRegister","processNumberedRegisters","contentByCursor","oldContent","newContent","baseOperator","clipboardContent","registerContent","supportNode","serializableRegisters","writeFileAsync","savedRegisters","JumpTracker","Transformer","regexEscape","regexLeader","regexBufferedKeys","pendingCommandString","commandWithoutCountPrefix","startPositions","_changes","matchRanges","_searchString","searchStringParser","recalculateSearchRanges","cached","fromPosition","relativeIndex","effectiveDirection","_cursors","_cursorsInitialState","inputMethodSwitcher","switchInputMethod","lineNumbers","TextEditorLineNumbersStyle","On","Relative","ReplaceState","_currentRegisterMode","NeovimWrapper","ime","InputMethodSwitcher","statusBarCommandText","replacement","wentOverEOL","showingDefaultMessage","statusBarItem","createStatusBarItem","StatusBarAlignment","Left","MIN_SAFE_INTEGER","recordedStateStatusBarItem","Right","hasModeChanged","updateText","updateColor","macroText","foreground","colorToSet","workbenchConfiguration","currentColorCustomizations","colorCustomizations","reportButton","showErrorMessage","body","letVSCodeHandleKeystrokes","editBuilder","firstNonBlank","whitespaceRegExp","iskeyword","foundRealWord","includeInWord","visibleColumn","screenCharacters","indentString","itrStart","itrEnd","runToLineEnd","lineIndex","endCharacter","wordEnd","isLineBlank","trimWhite","getLine","sentenceEndRegex","getFirstNonWhitespaceInParagraph","newCharacter","getAllPositions","getAllEndPositions","getNextSentenceBegin","paragraphBegin","getPreviousSentenceBegin","SelectWord","SelectABigWord","nextWord","SelectAnExpandingBlock","blocks","smallestRange","cursorStartPos","iMotion","currentSelectedRange","contender","SelectInnerWord","SelectInnerBigWord","SelectSentence","currentSentenceBegin","currentSentenceNonWhitespaceEnd","nextSentenceBegin","SelectInnerSentence","SelectParagraph","currentParagraphBegin","SelectInnerParagraph","SelectEntire","SelectEntireIgnoringLeadingTrailing","IndentObjectMatch","includeLineAbove","includeLineBelow","isChangeOperator","firstValidLineNumber","findFirstValidLine","cursorIndent","findRangeStartOrEnd","startCharacter","startIndex","InsideIndentObject","InsideIndentObjectAbove","InsideIndentObjectBoth","SelectArgument","selectAround","leftSearchStartPosition","rightSearchStartPosition","charAtPos","separatorCharacters","openingDelimiterCharacters","closingDelimiterCharacters","SelectInnerArgument","findLeftArgumentBoundary","findRightArgumentBoundary","leftArgumentBoundary","rightArgumentBoundary","isLeftOnOpening","isRightOnClosing","ignoreSeparators","delimiterPosition","walkingPosition","closedParensCount","isOnBoundary","openedParensCount","SelectAroundArgument","nonBigWordCharRegex","makeWordRegex","nonFileNameRegex","regexForWordType","keywordChars","CharKind","symbolTable","Punctuation","Superscript","Subscript","Braille","Hiragana","Katakana","Ideograph","Hangul","codePointRangePatterns","escapedKeywordChars","codePointRanges","patterns","symbolSegments","wordSegment","makeUnicodeWordRegex","CamelCase","characterSet","firstSegment","makeCamelCaseWordRegex","getWordLeftOnLine","forceFirst","textTransformations","multicursorTextTransformations","isMultiCursorTextTransformation","otherTransformations","accumulatedPositionDifferences","doTextEditorEdit","overlapping","overlappingTransformations","msg","areAllSameTransformation","FromVSCodeSelection","rerunRecordedState","keystrokes","keystrokesExpressionParser","runMacro","firstTransformation","getRangeFromTextTransformation","firstRange","secondRange","writeText","readText","tabsize","newlineReplacement","currentMatchIndex","expandCommand","previousExternalCommand","NoPreviousCommand","stdin","child","write","LoggerImpl","separatePath","searchPath","baseNameIndex","absolutePath","isWindows","isLocalUntitled","updatedPartialPath","dirName","addCurrentAndUp","directoryUri","FileType","Directory","numLinesChanged","modified","progress","matchIdx","numMatches","NoRangeAllowed","NoOpCommand","UnimplementedCommand","commandNameParser","fullName","nameParser","parseArgs","leaderParser","specialCharacters","specialCharacterParser","escapedParser","lineSpecifierParser","offsetParser","nums","specifier","side","InvalidRange","sepEnd","abbrev","suffixes","SearchOffset","inSelection","emptyBranch","haystack","searchOffset","startOffset","searchRange","beforeWrapping","afterWrapping","wrappedOver","matchRange","MAX_SEARCH_TIME","regexString","SPECIAL_CHARS_REGEX","leadingBar","atoms","delim","caseOverride","atom","getIgnoreCase","compileRegex","searchOffsetTypeParser","esb","homeDirectory","pathWithTilde","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","globalThis","nmd","children","activate"],"sourceRoot":""}